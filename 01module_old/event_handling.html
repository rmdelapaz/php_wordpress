<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Handling in JavaScript</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <header>
        <h1>Event Handling in JavaScript</h1>
        <p><a href="index.html">← Back to Syllabus</a> | <a href="module1.html">← Back to Module 1</a></p>
    </header>
    
    <main>
        <section class="introduction">
            <h2>Introduction to Events</h2>
            <p>Events are actions or occurrences that happen in the system you are programming. The system notifies you when these events occur, so you can respond to them in some way if desired. For example, if a user clicks a button on a webpage, you might want to respond to that click event by displaying information.</p>
            
            <div class="analogy">
                <h3>Events as Conversations</h3>
                <p>Think of events like conversations between your webpage and its visitors. The user does something (clicks, types, scrolls), and that's like them saying something to your webpage. Event listeners are like your webpage's ears, waiting for specific phrases. When they hear one, they trigger a specific response (your event handler function).</p>
            </div>
            
            <svg width="700" height="250" viewBox="0 0 700 250" xmlns="http://www.w3.org/2000/svg">
                <!-- Browser Window -->
                <rect x="100" y="20" width="500" height="210" rx="10" ry="10" fill="#f0f0f0" stroke="#333" stroke-width="2"/>
                <rect x="100" y="20" width="500" height="30" rx="10" ry="10" fill="#e0e0e0" stroke="#333" stroke-width="2"/>
                <circle cx="120" cy="35" r="5" fill="#ff6b6b"/>
                <circle cx="140" cy="35" r="5" fill="#ffd93d"/>
                <circle cx="160" cy="35" r="5" fill="#6bff6b"/>
                
                <!-- Webpage Content -->
                <rect x="150" y="80" width="200" height="60" rx="5" ry="5" fill="#4dabf7" stroke="#333" stroke-width="2"/>
                <text x="250" y="115" text-anchor="middle" font-family="Arial" font-size="16" fill="white">Click Me</text>
                
                <!-- User Hand -->
                <path d="M50,150 C30,130 20,90 30,70 C40,50 70,60 70,80 L70,130 L90,140 L50,150Z" fill="#ffccaa" stroke="#333" stroke-width="2"/>
                <path d="M70,80 L90,70 L100,90 L80,100 Z" fill="#ffccaa" stroke="#333" stroke-width="2"/>
                
                <!-- Event Flow -->
                <path d="M90,120 C120,100 150,100 180,110" stroke="#ff6b6b" stroke-width="3" stroke-dasharray="5,5" fill="none" marker-end="url(#arrow)"/>
                <text x="120" y="95" text-anchor="middle" font-family="Arial" font-size="14" fill="#ff6b6b">Click Event</text>
                
                <!-- JavaScript Response -->
                <rect x="400" y="80" width="150" height="100" rx="5" ry="5" fill="#f8f9fa" stroke="#333" stroke-width="2"/>
                <text x="475" y="105" text-anchor="middle" font-family="Arial" font-size="12" fill="#333">Event Listener</text>
                <text x="475" y="125" text-anchor="middle" font-family="Arial" font-size="10" fill="#333">function handleClick() {</text>
                <text x="475" y="145" text-anchor="middle" font-family="Arial" font-size="10" fill="#333">  // Code to run</text>
                <text x="475" y="165" text-anchor="middle" font-family="Arial" font-size="10" fill="#333">}</text>
                
                <!-- Event Flow to Handler -->
                <path d="M240,110 C300,90 350,130 400,130" stroke="#4dabf7" stroke-width="3" stroke-dasharray="5,5" fill="none" marker-end="url(#arrow2)"/>
                
                <defs>
                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                        <path d="M0,0 L0,6 L9,3 z" fill="#ff6b6b"/>
                    </marker>
                    <marker id="arrow2" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                        <path d="M0,0 L0,6 L9,3 z" fill="#4dabf7"/>
                    </marker>
                </defs>
            </svg>
            
            <p>Events are fundamental to creating interactive web applications. By learning how to handle events effectively, you'll be able to create responsive user interfaces that react to user interactions in meaningful ways.</p>
        </section>

        <section class="event-types">
            <h2>Types of Events</h2>
            <p>There are dozens of different events that can occur in a web browser. Here are the most common categories:</p>
            
            <div class="event-categories">
                <div class="event-category">
                    <h3>Mouse Events</h3>
                    <ul>
                        <li><code>click</code> - When an element is clicked</li>
                        <li><code>dblclick</code> - When an element is double-clicked</li>
                        <li><code>mousedown</code> - When a mouse button is pressed on an element</li>
                        <li><code>mouseup</code> - When a mouse button is released over an element</li>
                        <li><code>mousemove</code> - When the mouse is moved while it's over an element</li>
                        <li><code>mouseover</code> - When the mouse enters an element</li>
                        <li><code>mouseout</code> - When the mouse leaves an element</li>
                        <li><code>mouseenter</code> - When the mouse enters an element (doesn't bubble)</li>
                        <li><code>mouseleave</code> - When the mouse leaves an element (doesn't bubble)</li>
                    </ul>
                </div>
                
                <div class="event-category">
                    <h3>Keyboard Events</h3>
                    <ul>
                        <li><code>keydown</code> - When a key is pressed</li>
                        <li><code>keyup</code> - When a key is released</li>
                        <li><code>keypress</code> - When a key that produces a character is pressed (deprecated)</li>
                    </ul>
                </div>
                
                <div class="event-category">
                    <h3>Form Events</h3>
                    <ul>
                        <li><code>submit</code> - When a form is submitted</li>
                        <li><code>reset</code> - When a form is reset</li>
                        <li><code>change</code> - When an input element's value changes (on blur)</li>
                        <li><code>input</code> - When an input element's value changes (immediately)</li>
                        <li><code>focus</code> - When an element receives focus</li>
                        <li><code>blur</code> - When an element loses focus</li>
                        <li><code>select</code> - When text in an input field is selected</li>
                    </ul>
                </div>
                
                <div class="event-category">
                    <h3>Document/Window Events</h3>
                    <ul>
                        <li><code>load</code> - When a resource and its dependencies finish loading</li>
                        <li><code>DOMContentLoaded</code> - When the HTML document is loaded and parsed</li>
                        <li><code>resize</code> - When the window is resized</li>
                        <li><code>scroll</code> - When the document or element is scrolled</li>
                        <li><code>error</code> - When a resource fails to load</li>
                        <li><code>beforeunload</code> - Before the document is about to be unloaded</li>
                        <li><code>unload</code> - When the document is being unloaded</li>
                    </ul>
                </div>
                
                <div class="event-category">
                    <h3>Touch Events</h3>
                    <ul>
                        <li><code>touchstart</code> - When a touch point is placed on the touch surface</li>
                        <li><code>touchend</code> - When a touch point is removed from the touch surface</li>
                        <li><code>touchmove</code> - When a touch point is moved along the touch surface</li>
                        <li><code>touchcancel</code> - When a touch point has been disrupted</li>
                    </ul>
                </div>
            </div>
            
            <div class="real-world-usage">
                <h3>When to Use Different Events</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Use Case</th>
                            <th>Recommended Events</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Button interactions</td>
                            <td><code>click</code></td>
                            <td>Submit form, toggle panel, activate feature</td>
                        </tr>
                        <tr>
                            <td>Form validation</td>
                            <td><code>input</code>, <code>change</code>, <code>submit</code></td>
                            <td>Real-time feedback, submission handling</td>
                        </tr>
                        <tr>
                            <td>Drag-and-drop interfaces</td>
                            <td><code>mousedown</code>, <code>mousemove</code>, <code>mouseup</code></td>
                            <td>File uploads, sortable items, kanban boards</td>
                        </tr>
                        <tr>
                            <td>Hover effects</td>
                            <td><code>mouseenter</code>, <code>mouseleave</code></td>
                            <td>Tooltips, menu expansions, image zooms</td>
                        </tr>
                        <tr>
                            <td>Keyboard shortcuts</td>
                            <td><code>keydown</code></td>
                            <td>Navigation, accessibility features</td>
                        </tr>
                        <tr>
                            <td>Page initialization</td>
                            <td><code>DOMContentLoaded</code></td>
                            <td>Setup app state, initial data loading</td>
                        </tr>
                        <tr>
                            <td>Mobile interfaces</td>
                            <td><code>touchstart</code>, <code>touchend</code></td>
                            <td>Mobile navigation, swiping interfaces</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="mermaid">
                graph TB
                    Events[Browser Events]
                    User[User Initiated]
                    System[System Initiated]
                    
                    Mouse[Mouse Events]
                    Keyboard[Keyboard Events]
                    Touch[Touch Events]
                    Form[Form Events]
                    
                    Load[Page Lifecycle]
                    Network[Network Events]
                    Timer[Timer Events]
                    
                    Events --> User
                    Events --> System
                    
                    User --> Mouse
                    User --> Keyboard
                    User --> Touch
                    User --> Form
                    
                    System --> Load
                    System --> Network
                    System --> Timer
                    
                    Mouse --> click
                    Mouse --> dblclick
                    Mouse --> hover["mouseover/mouseout"]
                    
                    Keyboard --> keydown
                    Keyboard --> keyup
                    
                    Form --> submit
                    Form --> change
                    Form --> focus["focus/blur"]
                    
                    Load --> DOMContentLoaded
                    Load --> load
                    Load --> unload
                    
                    class Events,User,System,Mouse,Keyboard,Touch,Form,Load,Network,Timer headline
                    classDef headline fill:#f9f9f9,stroke:#333,stroke-width:1px
            </div>
        </section>

        <section class="event-handlers">
            <h2>Adding Event Handlers</h2>
            <p>There are several ways to attach event handlers to elements. Let's explore the different methods, from oldest to newest, along with their advantages and disadvantages.</p>

            <h3>Method 1: HTML Attribute Event Handlers</h3>
            <div class="code-example">
                <pre><code>&lt;!-- HTML inline event handlers --&gt;
&lt;button onclick="alert('Button clicked!')"&gt;Click Me&lt;/button&gt;

&lt;!-- Slightly better: calling a function --&gt;
&lt;button onclick="handleClick()"&gt;Click Me&lt;/button&gt;

&lt;script&gt;
function handleClick() {
  alert('Button clicked!');
}
&lt;/script&gt;</code></pre>
            </div>
            
            <div class="pros-cons">
                <div class="pros">
                    <h4>Pros:</h4>
                    <ul>
                        <li>Simple and easy to understand</li>
                        <li>Directly visible in the HTML</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Cons:</h4>
                    <ul>
                        <li>Mixes HTML and JavaScript (poor separation of concerns)</li>
                        <li>Limited to one handler per event type per element</li>
                        <li>Difficult to manage for complex interactions</li>
                        <li>Can cause security issues if used with user input</li>
                        <li>Less maintainable for large applications</li>
                    </ul>
                </div>
            </div>

            <h3>Method 2: DOM Property Event Handlers</h3>
            <div class="code-example">
                <pre><code>&lt;button id="myButton"&gt;Click Me&lt;/button&gt;

&lt;script&gt;
// Select the button
const button = document.getElementById('myButton');

// Assign an event handler to the onclick property
button.onclick = function() {
  alert('Button clicked!');
};

// Can also use a named function
function handleClick() {
  alert('Button clicked in a named function!');
}

// Reassigning overwrites the previous handler
button.onclick = handleClick;
&lt;/script&gt;</code></pre>
            </div>
            
            <div class="pros-cons">
                <div class="pros">
                    <h4>Pros:</h4>
                    <ul>
                        <li>Better separation of HTML and JavaScript</li>
                        <li>Simple syntax</li>
                        <li>Works in all browsers</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Cons:</h4>
                    <ul>
                        <li>Still limited to one handler per event type per element</li>
                        <li>No easy way to remove event handlers</li>
                        <li>Cannot capture events (only bubbling phase)</li>
                    </ul>
                </div>
            </div>

            <h3>Method 3: addEventListener (Modern Method)</h3>
            <div class="code-example">
                <pre><code>&lt;button id="myButton"&gt;Click Me&lt;/button&gt;

&lt;script&gt;
// Select the button
const button = document.getElementById('myButton');

// Add event listener
button.addEventListener('click', function() {
  alert('First handler');
});

// Can add multiple handlers for the same event
button.addEventListener('click', function() {
  alert('Second handler');
});

// Using named functions
function handleClick() {
  alert('Named function handler');
}

button.addEventListener('click', handleClick);

// Can later remove specific listeners
button.removeEventListener('click', handleClick);

// Using options (third parameter)
button.addEventListener('click', function() {
  alert('Once only!');
}, { once: true });  // This handler runs only once

// Capture phase (events normally bubble up the DOM)
document.body.addEventListener('click', function() {
  alert('Captured in body before reaching the button!');
}, { capture: true });
&lt;/script&gt;</code></pre>
            </div>
            
            <div class="pros-cons">
                <div class="pros">
                    <h4>Pros:</h4>
                    <ul>
                        <li>Multiple handlers for the same event type</li>
                        <li>Can add event handlers to groups of elements</li>
                        <li>Can remove specific event handlers</li>
                        <li>Supports both capturing and bubbling phases</li>
                        <li>Additional options (once, passive, signal)</li>
                        <li>Best practice in modern web development</li>
                    </ul>
                </div>
                <div class="cons">
                    <h4>Cons:</h4>
                    <ul>
                        <li>More verbose syntax</li>
                        <li>Need to store function references to remove listeners</li>
                    </ul>
                </div>
            </div>

            <div class="analogy">
                <h3>Event Handling Methods as Communication Systems</h3>
                <p>The three methods of handling events are like different communication systems:</p>
                <ul>
                    <li><strong>HTML attributes</strong> are like writing instructions directly on physical buttons ("Push here to open door"). Simple but limited.</li>
                    <li><strong>DOM properties</strong> are like having a single dedicated phone line to each button. You can call the button, but only one person can be on the line at a time.</li>
                    <li><strong>addEventListener</strong> is like a conference call system. Multiple people can listen and respond to the same call, you can opt-in or out of calls, and you have options for how you participate.</li>
                </ul>
            </div>
        </section>

        <section class="event-object">
            <h2>The Event Object</h2>
            <p>When an event occurs, the browser creates an Event object containing information about the event. This object is automatically passed to your event handler function.</p>

            <div class="code-example">
                <pre><code>const button = document.getElementById('myButton');

button.addEventListener('click', function(event) {
  // 'event' is the Event object
  console.log('Event type:', event.type);  // "click"
  console.log('Target element:', event.target);  // The button element
  console.log('Current target:', event.currentTarget);  // Also the button element
  console.log('Mouse position:', event.clientX, event.clientY);  // Coordinates relative to viewport
});

// Using arrow function syntax
button.addEventListener('click', (event) => {
  console.log('Clicked at:', event.clientX, event.clientY);
});</code></pre>
            </div>

            <h3>Common Event Object Properties</h3>
            <table>
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Description</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>type</code></td>
                        <td>The type of event (e.g., "click", "mouseover")</td>
                        <td><code>event.type</code></td>
                    </tr>
                    <tr>
                        <td><code>target</code></td>
                        <td>The element that triggered the event</td>
                        <td><code>event.target</code></td>
                    </tr>
                    <tr>
                        <td><code>currentTarget</code></td>
                        <td>The element the event handler is attached to</td>
                        <td><code>event.currentTarget</code></td>
                    </tr>
                    <tr>
                        <td><code>timeStamp</code></td>
                        <td>The time when the event occurred</td>
                        <td><code>event.timeStamp</code></td>
                    </tr>
                    <tr>
                        <td><code>bubbles</code></td>
                        <td>Whether the event bubbles up through the DOM</td>
                        <td><code>event.bubbles</code></td>
                    </tr>
                    <tr>
                        <td><code>cancelable</code></td>
                        <td>Whether the event can be canceled</td>
                        <td><code>event.cancelable</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Event-Specific Properties</h3>
            <p>Different event types have different properties:</p>

            <div class="event-property-groups">
                <div class="property-group">
                    <h4>Mouse Event Properties</h4>
                    <ul>
                        <li><code>clientX</code>, <code>clientY</code> - Coordinates within the viewport</li>
                        <li><code>pageX</code>, <code>pageY</code> - Coordinates relative to the document</li>
                        <li><code>screenX</code>, <code>screenY</code> - Coordinates relative to the screen</li>
                        <li><code>altKey</code>, <code>ctrlKey</code>, <code>shiftKey</code>, <code>metaKey</code> - Modifier key states</li>
                        <li><code>button</code> - Which mouse button was pressed</li>
                    </ul>
                </div>
                
                <div class="property-group">
                    <h4>Keyboard Event Properties</h4>
                    <ul>
                        <li><code>key</code> - The key value (e.g., "a", "Enter")</li>
                        <li><code>code</code> - The physical key code (e.g., "KeyA", "Enter")</li>
                        <li><code>keyCode</code> - The key code (deprecated)</li>
                        <li><code>altKey</code>, <code>ctrlKey</code>, <code>shiftKey</code>, <code>metaKey</code> - Modifier key states</li>
                        <li><code>repeat</code> - Whether the key is being held down</li>
                    </ul>
                </div>
                
                <div class="property-group">
                    <h4>Form Event Properties</h4>
                    <ul>
                        <li><code>value</code> (on target) - The current value of the form element</li>
                        <li><code>checked</code> (on target) - For checkboxes/radio buttons</li>
                        <li><code>selected</code> (on target) - For select options</li>
                    </ul>
                </div>
            </div>

            <h3>Common Event Methods</h3>
            <div class="code-example">
                <pre><code>// Prevent default behavior
document.getElementById('myLink').addEventListener('click', function(event) {
  event.preventDefault();  // Prevents navigating to the link
  console.log('Link clicked, but navigation prevented');
});

// Stop event propagation (bubbling)
document.getElementById('innerButton').addEventListener('click', function(event) {
  event.stopPropagation();  // Prevents the event from bubbling up
  console.log('This event will not bubble to parent elements');
});

// Stop immediate propagation (stops other handlers on the same element)
element.addEventListener('click', function(event) {
  event.stopImmediatePropagation();
  console.log('No other click handlers on this element will run');
});</code></pre>
            </div>

            <div class="example-visualization">
                <h3>Event Object Visualization</h3>
                <svg width="600" height="300" viewBox="0 0 600 300" xmlns="http://www.w3.org/2000/svg">
                    <!-- Event Object -->
                    <rect x="50" y="50" width="500" height="200" rx="10" fill="#f8f9fa" stroke="#333" stroke-width="2"/>
                    <text x="300" y="30" text-anchor="middle" font-size="16" font-weight="bold">Event Object</text>
                    
                    <!-- Common Properties Section -->
                    <rect x="70" y="70" width="220" height="160" rx="5" fill="#e2e3e5" stroke="#333" stroke-width="1"/>
                    <text x="180" y="90" text-anchor="middle" font-size="14" font-weight="bold">Common Properties</text>
                    <text x="80" y="115" font-size="12">type: "click"</text>
                    <text x="80" y="135" font-size="12">target: button#submitBtn</text>
                    <text x="80" y="155" font-size="12">currentTarget: button#submitBtn</text>
                    <text x="80" y="175" font-size="12">bubbles: true</text>
                    <text x="80" y="195" font-size="12">cancelable: true</text>
                    <text x="80" y="215" font-size="12">timeStamp: 1234567890</text>
                    
                    <!-- Event Specific Properties -->
                    <rect x="310" y="70" width="220" height="160" rx="5" fill="#d1ecf1" stroke="#333" stroke-width="1"/>
                    <text x="420" y="90" text-anchor="middle" font-size="14" font-weight="bold">Mouse Event Properties</text>
                    <text x="320" y="115" font-size="12">clientX: 250</text>
                    <text x="320" y="135" font-size="12">clientY: 150</text>
                    <text x="320" y="155" font-size="12">button: 0</text>
                    <text x="320" y="175" font-size="12">altKey: false</text>
                    <text x="320" y="195" font-size="12">ctrlKey: false</text>
                    <text x="320" y="215" font-size="12">shiftKey: false</text>
                    
                    <!-- Methods -->
                    <text x="170" y="270" text-anchor="end" font-size="14" font-weight="bold">Methods:</text>
                    <text x="180" y="270" font-size="12">preventDefault(), stopPropagation(), stopImmediatePropagation()</text>
                </svg>
            </div>
        </section>

        <section class="event-propagation">
            <h2>Event Propagation</h2>
            <p>When an event occurs on an element that has parent elements (like a button inside a div inside the body), modern browsers run three different phases:</p>
            
            <div class="propagation-phases">
                <div class="phase">
                    <h3>1. Capturing Phase</h3>
                    <p>The event starts at the root (<code>window</code>) and moves down to the target element. Ancestors get notified before the target.</p>
                </div>
                <div class="phase">
                    <h3>2. Target Phase</h3>
                    <p>The event has reached the target element. Event handlers on the target are executed.</p>
                </div>
                <div class="phase">
                    <h3>3. Bubbling Phase</h3>
                    <p>The event bubbles up from the target to the root. Ancestors get notified after the target.</p>
                </div>
            </div>
            
            <div class="mermaid">
                graph TD
                    window[window]
                    document[document]
                    html[html]
                    body[body]
                    div[div]
                    button[button]
                    
                    window --> document
                    document --> html
                    html --> body
                    body --> div
                    div --> button
                    
                    classDef default fill:#f9f9f9,stroke:#333,stroke-width:1px
                    classDef target fill:#ff6b6b,stroke:#333,stroke-width:2px
                    classDef path fill:#faebce,stroke:#333,stroke-width:1px
                    
                    class button target
                    class window,document,html,body,div path
            </div>
            
            <div class="propagation-explanation">
                <p>If we have a button inside a div inside the body, and we click the button:</p>
                <ol>
                    <li><strong>Capturing Phase</strong>: Events travels from window → document → html → body → div → button</li>
                    <li><strong>Target Phase</strong>: Event arrives at the button (target element)</li>
                    <li><strong>Bubbling Phase</strong>: Event bubbles up from button → div → body → html → document → window</li>
                </ol>
            </div>
            
            <div class="code-example">
                <pre><code>&lt;!-- HTML structure --&gt;
&lt;div id="outer"&gt;
  &lt;div id="middle"&gt;
    &lt;button id="inner"&gt;Click Me&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
// Selecting elements
const outer = document.getElementById('outer');
const middle = document.getElementById('middle');
const inner = document.getElementById('inner');

// Bubbling phase handlers (default)
outer.addEventListener('click', function() {
  console.log('Outer div clicked - bubbling phase');
});

middle.addEventListener('click', function() {
  console.log('Middle div clicked - bubbling phase');
});

inner.addEventListener('click', function() {
  console.log('Button clicked - bubbling phase');
});

// Capturing phase handlers (third parameter is true)
outer.addEventListener('click', function() {
  console.log('Outer div clicked - capturing phase');
}, true);

middle.addEventListener('click', function() {
  console.log('Middle div clicked - capturing phase');
}, true);

inner.addEventListener('click', function() {
  console.log('Button clicked - capturing phase');
}, true);

// When you click the button, you'll see in the console:
// 1. "Outer div clicked - capturing phase"
// 2. "Middle div clicked - capturing phase"
// 3. "Button clicked - capturing phase"
// 4. "Button clicked - bubbling phase"
// 5. "Middle div clicked - bubbling phase"
// 6. "Outer div clicked - bubbling phase"
&lt;/script&gt;</code></pre>
            </div>
            
            <div class="practical-example">
                <h3>Practical Use of Event Propagation: Event Delegation</h3>
                <p>Event delegation is a technique where you attach a single event handler to a parent element instead of multiple handlers to individual children. It relies on event bubbling.</p>
                
                <div class="code-example">
                    <pre><code>&lt;!-- HTML structure --&gt;
&lt;ul id="task-list"&gt;
  &lt;li&gt;Task 1 &lt;button class="delete"&gt;Delete&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;Task 2 &lt;button class="delete"&gt;Delete&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;Task 3 &lt;button class="delete"&gt;Delete&lt;/button&gt;&lt;/li&gt;
  &lt;!-- More items might be added dynamically --&gt;
&lt;/ul&gt;

&lt;script&gt;
// Inefficient approach: Add handler to each button
const deleteButtons = document.querySelectorAll('.delete');
deleteButtons.forEach(button => {
  button.addEventListener('click', function() {
    const li = this.parentElement;
    li.remove();
  });
});
// Problem: New buttons added later won't have the handler!

// Better approach: Event delegation
const taskList = document.getElementById('task-list');
taskList.addEventListener('click', function(event) {
  // Check if the clicked element is a delete button
  if (event.target.className === 'delete') {
    // Find the parent li element and remove it
    const li = event.target.closest('li');
    li.remove();
    
    console.log('Task deleted');
  }
});
// Advantage: Works for dynamically added buttons too!
&lt;/script&gt;</code></pre>
                </div>
                
                <div class="benefits">
                    <h4>Benefits of Event Delegation:</h4>
                    <ul>
                        <li>Memory efficiency: Fewer event handlers</li>
                        <li>Works with dynamically added elements</li>
                        <li>Less code maintenance</li>
                        <li>Cleaner implementation for large lists or tables</li>
                    </ul>
                </div>
            </div>

            <div class="analogy">
                <h3>Event Propagation as a Company Hierarchy</h3>
                <p>Think of event propagation like information flowing through a company:</p>
                <ul>
                    <li><strong>Capturing Phase:</strong> A message from the CEO (window) passes down through executives (document, html), managers (body, div), to finally reach an employee (the button).</li>
                    <li><strong>Target Phase:</strong> The employee (button) receives and processes the message.</li>
                    <li><strong>Bubbling Phase:</strong> The employee's response travels back up through managers, executives, and finally to the CEO.</li>
                    <li><strong>stopPropagation():</strong> Like saying "This information stops here. Don't tell my boss."</li>
                </ul>
            </div>
        </section>

        <section class="real-world-examples">
            <h2>Practical Event Handling Examples</h2>
            
            <h3>Example 1: Form Validation</h3>
            <div class="code-example">
                <pre><code>&lt;!-- HTML structure --&gt;
&lt;form id="signup-form"&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="username"&gt;Username:&lt;/label&gt;
    &lt;input type="text" id="username" name="username" required minlength="3"&gt;
    &lt;span class="error" id="username-error"&gt;&lt;/span&gt;
  &lt;/div&gt;
  
  &lt;div class="form-group"&gt;
    &lt;label for="email"&gt;Email:&lt;/label&gt;
    &lt;input type="email" id="email" name="email" required&gt;
    &lt;span class="error" id="email-error"&gt;&lt;/span&gt;
  &lt;/div&gt;
  
  &lt;div class="form-group"&gt;
    &lt;label for="password"&gt;Password:&lt;/label&gt;
    &lt;input type="password" id="password" name="password" required minlength="8"&gt;
    &lt;span class="error" id="password-error"&gt;&lt;/span&gt;
  &lt;/div&gt;
  
  &lt;button type="submit"&gt;Sign Up&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
// Form validation with event handling
document.addEventListener('DOMContentLoaded', function() {
  const form = document.getElementById('signup-form');
  const username = document.getElementById('username');
  const email = document.getElementById('email');
  const password = document.getElementById('password');
  
  const usernameError = document.getElementById('username-error');
  const emailError = document.getElementById('email-error');
  const passwordError = document.getElementById('password-error');
  
  // Username validation - input event for real-time feedback
  username.addEventListener('input', function() {
    if (username.validity.tooShort) {
      usernameError.textContent = 'Username must be at least 3 characters';
    } else {
      usernameError.textContent = '';
    }
  });
  
  // Email validation - when the user leaves the field
  email.addEventListener('blur', function() {
    if (email.validity.typeMismatch) {
      emailError.textContent = 'Please enter a valid email address';
    } else {
      emailError.textContent = '';
    }
  });
  
  // Password validation - with custom rules
  password.addEventListener('input', function() {
    if (password.value.length < 8) {
      passwordError.textContent = 'Password must be at least 8 characters';
    } else if (!/[A-Z]/.test(password.value)) {
      passwordError.textContent = 'Password must contain an uppercase letter';
    } else if (!/[0-9]/.test(password.value)) {
      passwordError.textContent = 'Password must contain a number';
    } else {
      passwordError.textContent = '';
    }
  });
  
  // Form submission - validate everything together
  form.addEventListener('submit', function(event) {
    let isValid = true;
    
    // Check username
    if (!username.value || username.value.length < 3) {
      usernameError.textContent = 'Username is required (min 3 characters)';
      isValid = false;
    }
    
    // Check email
    if (!email.value || email.validity.typeMismatch) {
      emailError.textContent = 'Valid email is required';
      isValid = false;
    }
    
    // Check password
    if (!password.value || password.value.length < 8 || 
        !/[A-Z]/.test(password.value) || !/[0-9]/.test(password.value)) {
      passwordError.textContent = 'Password must be at least 8 characters with a number and uppercase letter';
      isValid = false;
    }
    
    // If the form is not valid, prevent submission
    if (!isValid) {
      event.preventDefault();
    } else {
      alert('Form submitted successfully!');
      // In a real application, you would typically submit the form
      // or use fetch/AJAX to send the data to the server
    }
  });
});
&lt;/script&gt;</code></pre>
            </div>
            
            <h3>Example 2: Image Gallery with Event Delegation</h3>
            <div class="code-example">
                <pre><code>&lt;!-- HTML structure --&gt;
&lt;div class="gallery-container"&gt;
  &lt;div class="thumbnails" id="thumbnails"&gt;
    &lt;img src="thumb1.jpg" data-full="image1.jpg" alt="Image 1" class="thumbnail"&gt;
    &lt;img src="thumb2.jpg" data-full="image2.jpg" alt="Image 2" class="thumbnail"&gt;
    &lt;img src="thumb3.jpg" data-full="image3.jpg" alt="Image 3" class="thumbnail"&gt;
    &lt;img src="thumb4.jpg" data-full="image4.jpg" alt="Image 4" class="thumbnail"&gt;
  &lt;/div&gt;
  
  &lt;div class="full-image-container"&gt;
    &lt;img id="full-image" src="image1.jpg" alt="Full size image"&gt;
    &lt;div class="image-caption" id="image-caption"&gt;Image 1&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
document.addEventListener('DOMContentLoaded', function() {
  const thumbnailsContainer = document.getElementById('thumbnails');
  const fullImage = document.getElementById('full-image');
  const imageCaption = document.getElementById('image-caption');
  
  // Using event delegation for all thumbnails
  thumbnailsContainer.addEventListener('click', function(event) {
    // Check if we clicked on a thumbnail
    if (event.target.classList.contains('thumbnail')) {
      // Get the full image path from data attribute
      const fullImageSrc = event.target.getAttribute('data-full');
      const altText = event.target.getAttribute('alt');
      
      // Update the full image
      fullImage.src = fullImageSrc;
      fullImage.alt = altText;
      imageCaption.textContent = altText;
      
      // Remove 'active' class from all thumbnails
      const allThumbnails = thumbnailsContainer.querySelectorAll('.thumbnail');
      allThumbnails.forEach(thumb => thumb.classList.remove('active'));
      
      // Add 'active' class to the clicked thumbnail
      event.target.classList.add('active');
    }
  });
  
  // Add keyboard navigation with keydown event
  document.addEventListener('keydown', function(event) {
    const thumbnails = document.querySelectorAll('.thumbnail');
    const activeIndex = Array.from(thumbnails).findIndex(thumb => 
      thumb.classList.contains('active'));
    
    let newIndex;
    
    // Right arrow or Down arrow: next image
    if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
      newIndex = (activeIndex + 1) % thumbnails.length;
    }
    // Left arrow or Up arrow: previous image
    else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
      newIndex = (activeIndex - 1 + thumbnails.length) % thumbnails.length;
    } else {
      return; // Exit if not arrow key
    }
    
    // Simulate a click on the new thumbnail
    thumbnails[newIndex].click();
  });
  
  // Initialize the first thumbnail as active
  const firstThumbnail = thumbnailsContainer.querySelector('.thumbnail');
  if (firstThumbnail) {
    firstThumbnail.classList.add('active');
  }
});
&lt;/script&gt;</code></pre>
            </div>
            
            <h3>Example 3: Drag and Drop Interface</h3>
            <div class="code-example">
                <pre><code>&lt;!-- HTML structure --&gt;
&lt;div class="todo-board"&gt;
  &lt;div class="column" id="todo"&gt;
    &lt;h2&gt;To Do&lt;/h2&gt;
    &lt;div class="task" draggable="true" data-id="task1"&gt;Complete assignment&lt;/div&gt;
    &lt;div class="task" draggable="true" data-id="task2"&gt;Read chapter 5&lt;/div&gt;
    &lt;div class="task" draggable="true" data-id="task3"&gt;Prepare presentation&lt;/div&gt;
  &lt;/div&gt;
  
  &lt;div class="column" id="in-progress"&gt;
    &lt;h2&gt;In Progress&lt;/h2&gt;
  &lt;/div&gt;
  
  &lt;div class="column" id="done"&gt;
    &lt;h2&gt;Done&lt;/h2&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
document.addEventListener('DOMContentLoaded', function() {
  // Get all draggable tasks and drop zones (columns)
  const tasks = document.querySelectorAll('.task');
  const columns = document.querySelectorAll('.column');
  
  let draggedTask = null;
  
  // Set up draggable tasks
  tasks.forEach(task => {
    // When drag starts
    task.addEventListener('dragstart', function(event) {
      draggedTask = task;
      
      // Add dragging class for styling
      task.classList.add('dragging');
      
      // Set data to transfer - required for Firefox
      event.dataTransfer.setData('text/plain', task.dataset.id);
      
      // Make it semi-transparent during drag
      setTimeout(() => {
        task.style.opacity = '0.5';
      }, 0);
    });
    
    // When drag ends
    task.addEventListener('dragend', function() {
      task.classList.remove('dragging');
      task.style.opacity = '1';
      draggedTask = null;
    });
  });
  
  // Set up drop zones (columns)
  columns.forEach(column => {
    // When a draggable element enters a valid drop target
    column.addEventListener('dragenter', function(event) {
      event.preventDefault();
      column.classList.add('drag-over');
    });
    
    // When dragging over a valid drop target
    column.addEventListener('dragover', function(event) {
      event.preventDefault(); // Necessary to allow dropping
      column.classList.add('drag-over');
    });
    
    // When leaving a valid drop target
    column.addEventListener('dragleave', function(event) {
      // Only remove drag-over if we're leaving the column (not entering a child)
      if (event.relatedTarget && !column.contains(event.relatedTarget)) {
        column.classList.remove('drag-over');
      }
    });
    
    // When dropping on a valid target
    column.addEventListener('drop', function(event) {
      event.preventDefault();
      column.classList.remove('drag-over');
      
      // Move the task to this column
      if (draggedTask) {
        column.appendChild(draggedTask);
        
        // In a real app, you would save the new status to a database
        console.log(`Task ${draggedTask.dataset.id} moved to ${column.id}`);
      }
    });
  });
});
&lt;/script&gt;</code></pre>
            </div>
        </section>

        <section class="event-performance">
            <h2>Performance and Best Practices</h2>
            <p>Properly handling events is crucial for building performant web applications. Here are some best practices:</p>
            
            <h3>Event Delegation</h3>
            <p>Use event delegation when dealing with multiple similar elements:</p>
            <div class="code-example">
                <pre><code>// Instead of this (inefficient for many items)
document.querySelectorAll('.menu-item').forEach(item => {
  item.addEventListener('click', handleMenuClick);
});

// Use this (one handler for all menu items)
document.querySelector('.menu').addEventListener('click', function(event) {
  if (event.target.matches('.menu-item')) {
    handleMenuClick(event);
  }
});</code></pre>
            </div>
            
            <h3>Throttling and Debouncing</h3>
            <p>Limit the frequency of event handling for performance-intensive events:</p>
            <div class="code-example">
                <pre><code>// Debounce function: Execute callback after delay has elapsed
function debounce(callback, delay = 300) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      callback.apply(this, args);
    }, delay);
  };
}

// Throttle function: Execute callback at most once per limit
function throttle(callback, limit = 300) {
  let waiting = false;
  return function(...args) {
    if (!waiting) {
      callback.apply(this, args);
      waiting = true;
      setTimeout(() => {
        waiting = false;
      }, limit);
    }
  };
}

// Example: Debounce resize event
window.addEventListener('resize', debounce(function() {
  console.log('Window resized');
  // Update layout or calculations
}, 500));

// Example: Throttle scroll event
window.addEventListener('scroll', throttle(function() {
  console.log('Window scrolled');
  // Update something based on scroll position
}, 200));</code></pre>
            </div>
            
            <div class="analogy">
                <h3>Throttling and Debouncing Analogy</h3>
                <p><strong>Debouncing</strong> is like waiting for a conversation to finish before responding. If someone keeps talking, you keep waiting. Only after they've stopped talking for a certain amount of time do you respond.</p>
                <p><strong>Throttling</strong> is like only responding every few minutes in a conversation, regardless of how much the other person keeps talking.</p>
            </div>
            
            <h3>Remove Event Listeners When No Longer Needed</h3>
            <div class="code-example">
                <pre><code>// Define the handler function (must be named to remove later)
function handleClick(event) {
  console.log('Button clicked');
  
  // Do something once
  
  // Then remove the listener
  this.removeEventListener('click', handleClick);
}

button.addEventListener('click', handleClick);

// For one-time events, you can also use the { once: true } option
button.addEventListener('click', function() {
  console.log('This handler runs exactly once');
}, { once: true });</code></pre>
            </div>
            
            <h3>Use Passive Event Listeners for Scroll Performance</h3>
            <div class="code-example">
                <pre><code>// Modern browsers: Telling the browser you won't call preventDefault()
document.addEventListener('scroll', function() {
  // Scroll handler
}, { passive: true });

// This improves performance, especially on mobile devices</code></pre>
            </div>
            
            <h3>Avoid Inline Event Handlers</h3>
            <p>Don't use HTML attributes like <code>onclick</code>. They mix HTML and JavaScript, are harder to maintain, and have scope limitations.</p>
        </section>

        <section class="event-frameworks">
            <h2>Events in Modern Frameworks</h2>
            <p>While the core principles of event handling apply across all JavaScript applications, modern frameworks provide syntactic sugar and performance optimizations.</p>
            
            <h3>React Events</h3>
            <div class="code-example">
                <pre><code>// React uses a synthetic event system
function Button() {
  const handleClick = (event) => {
    console.log('Button clicked', event);
    // event is a synthetic event, a cross-browser wrapper around the native event
  };
  
  return (
    &lt;button onClick={handleClick}&gt;
      Click Me
    &lt;/button&gt;
  );
}</code></pre>
            </div>
            
            <h3>Vue Events</h3>
            <div class="code-example">
                <pre><code>// Vue template syntax
&lt;template&gt;
  &lt;button @click="handleClick"&gt;Click Me&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  methods: {
    handleClick(event) {
      console.log('Button clicked', event);
    }
  }
}
&lt;/script&gt;</code></pre>
            </div>
            
            <h3>Angular Events</h3>
            <div class="code-example">
                <pre><code>// Angular template binding
&lt;button (click)="handleClick($event)"&gt;Click Me&lt;/button&gt;

// In component class
handleClick(event: Event) {
  console.log('Button clicked', event);
}</code></pre>
            </div>
        </section>

        <section class="custom-events">
            <h2>Creating Custom Events</h2>
            <p>You can create your own custom events to build decoupled, event-driven architectures in JavaScript.</p>
            
            <div class="code-example">
                <pre><code>// Creating a custom event
const productAddedEvent = new CustomEvent('productAdded', {
  bubbles: true, // Allow event to bubble up
  detail: {      // Custom data
    productId: '12345',
    productName: 'Coffee Maker',
    price: 49.99
  }
});

// Dispatching the custom event
document.getElementById('add-to-cart-button').addEventListener('click', function() {
  // Add product to cart logic here
  
  // Then dispatch the event
  document.dispatchEvent(productAddedEvent);
});

// Listening for the custom event
document.addEventListener('productAdded', function(event) {
  console.log('Product added:', event.detail.productName);
  console.log('Price:', event.detail.price);
  
  // Update cart UI or show notification
  updateCartCounter();
  showAddedToCartMessage(event.detail.productName);
});</code></pre>
            </div>
            
            <div class="custom-event-benefits">
                <h3>Benefits of Custom Events</h3>
                <ul>
                    <li><strong>Loose coupling</strong>: Components don't need direct references to each other</li>
                    <li><strong>Scalability</strong>: Easy to add new functionality without modifying existing code</li>
                    <li><strong>Multiple listeners</strong>: Many parts of the application can respond to the same event</li>
                    <li><strong>Cleaner architecture</strong>: Helps maintain separation of concerns</li>
                </ul>
            </div>
            
            <div class="real-world-example">
                <h3>Real-World Example: Shopping Cart System</h3>
                <div class="code-example">
                    <pre><code>// Cart Events Manager
class CartEvents {
  constructor() {
    this.events = {
      productAdded: 'cartProductAdded',
      productRemoved: 'cartProductRemoved',
      cartCleared: 'cartCleared',
      quantityChanged: 'cartQuantityChanged'
    };
  }
  
  dispatch(eventName, data) {
    const event = new CustomEvent(eventName, {
      bubbles: true,
      detail: data
    });
    document.dispatchEvent(event);
  }
}

// Cart functionality
class ShoppingCart {
  constructor() {
    this.items = [];
    this.events = new CartEvents();
  }
  
  addProduct(product) {
    // Add product to cart
    this.items.push(product);
    
    // Dispatch event
    this.events.dispatch(this.events.events.productAdded, {
      product: product,
      cartTotal: this.calculateTotal()
    });
  }
  
  removeProduct(productId) {
    // Remove product from cart
    this.items = this.items.filter(item => item.id !== productId);
    
    // Dispatch event
    this.events.dispatch(this.events.events.productRemoved, {
      productId: productId,
      cartTotal: this.calculateTotal()
    });
  }
  
  clearCart() {
    this.items = [];
    this.events.dispatch(this.events.events.cartCleared, {});
  }
  
  calculateTotal() {
    return this.items.reduce((total, item) => total + item.price, 0);
  }
}

// UI Module that updates the cart display
class CartUI {
  constructor() {
    this.cart = new ShoppingCart();
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    // Listen for product added to cart
    document.addEventListener('cartProductAdded', this.handleProductAdded.bind(this));
    document.addEventListener('cartProductRemoved', this.handleProductRemoved.bind(this));
    document.addEventListener('cartCleared', this.handleCartCleared.bind(this));
    
    // Add to cart buttons
    document.querySelectorAll('.add-to-cart').forEach(button => {
      button.addEventListener('click', this.handleAddToCartClick.bind(this));
    });
  }
  
  handleAddToCartClick(event) {
    const button = event.target;
    const productId = button.dataset.productId;
    const productName = button.dataset.productName;
    const productPrice = parseFloat(button.dataset.productPrice);
    
    const product = {
      id: productId,
      name: productName,
      price: productPrice
    };
    
    this.cart.addProduct(product);
  }
  
  handleProductAdded(event) {
    const product = event.detail.product;
    const cartTotal = event.detail.cartTotal;
    
    // Update UI
    console.log(`Added: ${product.name} - Cart total: $${cartTotal.toFixed(2)}`);
    this.updateCartCounter();
    this.updateCartTotal(cartTotal);
    this.addProductToCartUI(product);
  }
  
  handleProductRemoved(event) {
    // Update UI
    const productId = event.detail.productId;
    const cartTotal = event.detail.cartTotal;
    
    this.removeProductFromCartUI(productId);
    this.updateCartTotal(cartTotal);
    this.updateCartCounter();
  }
  
  handleCartCleared() {
    // Clear cart UI
    document.getElementById('cart-items').innerHTML = '';
    this.updateCartTotal(0);
    this.updateCartCounter();
  }
  
  updateCartCounter() {
    const counter = document.getElementById('cart-counter');
    counter.textContent = this.cart.items.length;
  }
  
  updateCartTotal(total) {
    const totalElement = document.getElementById('cart-total');
    totalElement.textContent = `$${total.toFixed(2)}`;
  }
  
  addProductToCartUI(product) {
    const cartItems = document.getElementById('cart-items');
    const item = document.createElement('div');
    item.className = 'cart-item';
    item.dataset.productId = product.id;
    
    item.innerHTML = `
      <span>${product.name}</span>
      <span>$${product.price.toFixed(2)}</span>
      <button class="remove-item" data-product-id="${product.id}">X</button>
    `;
    
    // Add event listener to the remove button
    item.querySelector('.remove-item').addEventListener('click', (event) => {
      const productId = event.target.dataset.productId;
      this.cart.removeProduct(productId);
    });
    
    cartItems.appendChild(item);
  }
  
  removeProductFromCartUI(productId) {
    const item = document.querySelector(`.cart-item[data-product-id="${productId}"]`);
    if (item) {
      item.remove();
    }
  }
}

// Initialize the cart
document.addEventListener('DOMContentLoaded', () => {
  const cartUI = new CartUI();
});</code></pre>
                </div>
            </div>
        </section>

        <section class="exercises">
            <h2>Practice Exercises</h2>
            
            <div class="exercise">
                <h3>Exercise 1: Interactive To-Do List</h3>
                <p>Create a to-do list application that allows users to:</p>
                <ul>
                    <li>Add new tasks with a form</li>
                    <li>Mark tasks as complete by clicking on them</li>
                    <li>Delete tasks with a delete button</li>
                    <li>Filter tasks (All, Active, Completed) using event delegation</li>
                </ul>
            </div>
            
            <div class="exercise">
                <h3>Exercise 2: Image Carousel</h3>
                <p>Build an image carousel/slider that:</p>
                <ul>
                    <li>Shows one image at a time</li>
                    <li>Has next/previous buttons</li>
                    <li>Supports keyboard navigation (left/right arrow keys)</li>
                    <li>Has indicator dots showing the current position</li>
                    <li>Auto-advances every few seconds</li>
                </ul>
            </div>
            
            <div class="exercise">
                <h3>Exercise 3: Interactive Form</h3>
                <p>Create a multi-step form that:</p>
                <ul>
                    <li>Has at least 3 steps/sections</li>
                    <li>Validates each section before proceeding</li>
                    <li>Shows validation errors in real-time</li>
                    <li>Allows navigation between completed steps</li>
                    <li>Submits all data at the end</li>
                </ul>
            </div>
        </section>

        <section class="resources">
            <h2>Additional Resources</h2>
            <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank">MDN Web Docs: Event</a> - Comprehensive documentation on the Event interface</li>
                <li><a href="https://javascript.info/events" target="_blank">JavaScript.info: Events</a> - In-depth tutorial on events</li>
                <li><a href="https://www.w3schools.com/js/js_events.asp" target="_blank">W3Schools: JavaScript Events</a> - Basic event handling tutorial with examples</li>
                <li><a href="https://htmldom.dev/" target="_blank">HTML DOM</a> - Practical vanilla JavaScript DOM manipulation recipes</li>
            </ul>
        </section>

        <section class="summary">
            <h2>Key Takeaways</h2>
            <ul>
                <li>Events are actions or occurrences that happen in the browser that you can respond to in JavaScript.</li>
                <li>The modern way to handle events is with <code>addEventListener</code>, which allows multiple handlers and more control.</li>
                <li>The Event object contains information about the event and methods to control its behavior.</li>
                <li>Event propagation has three phases: capturing, target, and bubbling.</li>
                <li>Event delegation is a powerful pattern that leverages event bubbling to handle events for multiple elements with a single listener.</li>
                <li>Performance optimization techniques like debouncing and throttling help manage high-frequency events.</li>
                <li>Custom events allow you to create decoupled, event-driven architectures.</li>
            </ul>
        </section>
    </main>
    
    <footer>
        <p>&copy; 2025 PHP WordPress Development Course</p>

    </footer>
</body>
</html>
