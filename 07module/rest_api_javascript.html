<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    
    <!-- SEO Meta Tags -->
    <title>REST API with JavaScript - PHP WordPress Course</title>
    <meta name="description" content="Learn to interact with WordPress REST API using JavaScript. Master Fetch API, async/await, and build interactive applications.">
    <meta name="keywords" content="WordPress, REST API, JavaScript, Fetch API, AJAX, async await">
    <meta name="author" content="PHP WordPress Course">
    
    <!-- Open Graph Tags -->
    <meta property="og:title" content="REST API with JavaScript">
    <meta property="og:description" content="Build interactive applications with WordPress REST API">
    <meta property="og:type" content="article">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon.png">
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">
    
    <!-- Prism.js for syntax highlighting -->
    <link href="/assets/css/prism.css" rel="stylesheet">
</head>
<body>
    <!-- Skip to main content -->
    <a href="#main-content" class="sr-only">Skip to main content</a>
    
    <div class="page-wrapper">
        <!-- Header -->
        <header class="site-header" role="banner">
            <div class="header-container">
                <div class="site-branding">
                    <a href="/" class="site-logo">
                        <h1 class="site-title">PHP WordPress Development</h1>
                    </a>
                </div>
                
                <nav class="main-navigation" role="navigation" aria-label="Main navigation">
                    <button class="mobile-menu-btn" aria-label="Toggle navigation" aria-expanded="false">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                    
                    <div class="nav-menu">
                        <ul class="nav-list">
                            <li class="nav-item"><a href="/" class="nav-link">Home</a></li>
                            <li class="nav-item dropdown">
                                <button class="nav-link dropdown-toggle active" aria-haspopup="true">Modules</button>
                                <div class="dropdown-menu">
                                    <a href="/module1.html" class="dropdown-item">Module 1: Web Fundamentals</a>
                                    <a href="/module2.html" class="dropdown-item">Module 2: PHP Fundamentals</a>
                                    <a href="/module3.html" class="dropdown-item">Module 3: MySQL Database</a>
                                    <a href="/module4.html" class="dropdown-item">Module 4: WordPress & Docker</a>
                                    <a href="/module5.html" class="dropdown-item">Module 5: Theme Development</a>
                                    <a href="/module6.html" class="dropdown-item">Module 6: Plugin Development</a>
                                    <a href="/module7.html" class="dropdown-item active">Module 7: Advanced WordPress</a>
                                    <a href="/module8.html" class="dropdown-item">Module 8: Deployment</a>
                                    <a href="/module9.html" class="dropdown-item">Module 9: Final Project</a>
                                </div>
                            </li>
                            <li class="nav-item"><a href="/resources.html" class="nav-link">Resources</a></li>
                            <li class="nav-item"><a href="/about.html" class="nav-link">About</a></li>
                        </ul>
                    </div>
                </nav>
                
                <div class="search-container">
                    <div class="search-input-wrapper">
                        <svg class="search-icon" width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                        </svg>
                        <input type="search" class="search-input" placeholder="Search lessons..." aria-label="Search">
                    </div>
                    <div class="search-results"></div>
                </div>
            </div>
        </header>
        
        <!-- Progress Bar -->
        <div class="progress-container">
            <div class="progress-header">
                <h2 class="progress-title">Course Progress</h2>
                <span class="progress-text">Loading...</span>
            </div>
            <div class="progress-bar">
                <div class="progress-bar-fill">
                    <span class="progress-bar-text"></span>
                </div>
            </div>
        </div>
        
        <!-- Breadcrumb -->
        <nav class="breadcrumb container" aria-label="Breadcrumb">
            <ol class="breadcrumb-list">
                <li class="breadcrumb-item">
                    <a href="/">Home</a>
                    <span class="breadcrumb-separator">/</span>
                </li>
                <li class="breadcrumb-item">
                    <a href="/module7.html">Module 7</a>
                    <span class="breadcrumb-separator">/</span>
                </li>
                <li class="breadcrumb-item">
                    <span aria-current="page">REST API JavaScript</span>
                </li>
            </ol>
        </nav>
        
        <!-- Main Content -->
        <main id="main-content" class="main-content" role="main">
            <div class="container">
                <!-- Lesson Header -->
                <div class="lesson-header">
                    <h1 class="lesson-title">Interacting with REST API from JavaScript</h1>
                    <p class="lesson-subtitle">Build dynamic applications with WordPress REST API and modern JavaScript</p>
                </div>
                
                <!-- Learning Objectives -->
                <div class="lesson-objectives">
                    <h2>Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Use Fetch API for REST requests</li>
                        <li>Implement async/await patterns</li>
                        <li>Handle authentication in JavaScript</li>
                        <li>Build CRUD operations</li>
                        <li>Create real-time updates</li>
                        <li>Handle errors gracefully</li>
                    </ul>
                </div>
                
                <!-- Lesson Body -->
                <div class="lesson-body">
                    <!-- REST API Client Class -->
                    <section>
                        <h2>WordPress REST API Client</h2>
                        
                        <h3>Complete API Client Implementation</h3>
                        <pre><code class="language-javascript">
/**
 * WordPress REST API Client
 * A comprehensive client for interacting with WordPress REST API
 */
class WPRestClient {
    constructor(config = {}) {
        this.baseURL = config.baseURL || window.location.origin + '/wp-json';
        this.namespace = config.namespace || 'wp/v2';
        this.nonce = config.nonce || window.wpApiSettings?.nonce;
        this.headers = {
            'Content-Type': 'application/json',
            ...config.headers
        };
        
        // Setup authentication
        if (this.nonce) {
            this.headers['X-WP-Nonce'] = this.nonce;
        }
        
        // Request interceptors
        this.requestInterceptors = [];
        this.responseInterceptors = [];
        
        // Cache
        this.cache = new Map();
        this.cacheTimeout = config.cacheTimeout || 5 * 60 * 1000; // 5 minutes
    }
    
    /**
     * Make API request
     */
    async request(endpoint, options = {}) {
        const url = this.buildURL(endpoint);
        
        // Apply request interceptors
        let requestConfig = {
            ...options,
            headers: {
                ...this.headers,
                ...options.headers
            },
            credentials: 'include' // Include cookies
        };
        
        for (const interceptor of this.requestInterceptors) {
            requestConfig = await interceptor(requestConfig);
        }
        
        try {
            const response = await fetch(url, requestConfig);
            
            // Apply response interceptors
            let processedResponse = response;
            for (const interceptor of this.responseInterceptors) {
                processedResponse = await interceptor(processedResponse);
            }
            
            // Handle response
            if (!processedResponse.ok) {
                throw await this.handleError(processedResponse);
            }
            
            // Parse response
            const data = await this.parseResponse(processedResponse);
            
            // Extract pagination from headers
            const pagination = this.extractPagination(processedResponse);
            
            return {
                data,
                pagination,
                headers: processedResponse.headers
            };
            
        } catch (error) {
            console.error('API Request failed:', error);
            throw error;
        }
    }
    
    /**
     * GET request with caching
     */
    async get(endpoint, params = {}, useCache = true) {
        const cacheKey = this.getCacheKey(endpoint, params);
        
        // Check cache
        if (useCache && this.cache.has(cacheKey)) {
            const cached = this.cache.get(cacheKey);
            if (Date.now() - cached.timestamp < this.cacheTimeout) {
                return cached.data;
            }
        }
        
        const queryString = new URLSearchParams(params).toString();
        const fullEndpoint = queryString ? `${endpoint}?${queryString}` : endpoint;
        
        const result = await this.request(fullEndpoint, {
            method: 'GET'
        });
        
        // Cache the result
        if (useCache) {
            this.cache.set(cacheKey, {
                data: result,
                timestamp: Date.now()
            });
        }
        
        return result;
    }
    
    /**
     * POST request
     */
    async post(endpoint, data = {}) {
        return this.request(endpoint, {
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
    
    /**
     * PUT request
     */
    async put(endpoint, data = {}) {
        return this.request(endpoint, {
            method: 'PUT',
            body: JSON.stringify(data)
        });
    }
    
    /**
     * PATCH request
     */
    async patch(endpoint, data = {}) {
        return this.request(endpoint, {
            method: 'PATCH',
            body: JSON.stringify(data)
        });
    }
    
    /**
     * DELETE request
     */
    async delete(endpoint) {
        return this.request(endpoint, {
            method: 'DELETE'
        });
    }
    
    /**
     * Build full URL
     */
    buildURL(endpoint) {
        // Handle full URLs
        if (endpoint.startsWith('http')) {
            return endpoint;
        }
        
        // Handle namespace
        if (!endpoint.startsWith('/')) {
            endpoint = `/${this.namespace}/${endpoint}`;
        }
        
        return `${this.baseURL}${endpoint}`;
    }
    
    /**
     * Parse response based on content type
     */
    async parseResponse(response) {
        const contentType = response.headers.get('content-type');
        
        if (contentType?.includes('application/json')) {
            return response.json();
        } else if (contentType?.includes('text/html')) {
            return response.text();
        } else if (contentType?.includes('text/plain')) {
            return response.text();
        } else {
            return response.blob();
        }
    }
    
    /**
     * Handle API errors
     */
    async handleError(response) {
        let error = {
            status: response.status,
            statusText: response.statusText,
            message: 'An error occurred'
        };
        
        try {
            const data = await response.json();
            error = {
                ...error,
                ...data,
                message: data.message || error.message
            };
        } catch (e) {
            // Response wasn't JSON
        }
        
        return new APIError(error.message, error.status, error);
    }
    
    /**
     * Extract pagination from headers
     */
    extractPagination(response) {
        return {
            total: parseInt(response.headers.get('X-WP-Total') || '0'),
            totalPages: parseInt(response.headers.get('X-WP-TotalPages') || '0'),
            links: this.parseLinkHeader(response.headers.get('Link'))
        };
    }
    
    /**
     * Parse Link header
     */
    parseLinkHeader(header) {
        if (!header) return {};
        
        const links = {};
        const parts = header.split(',');
        
        parts.forEach(part => {
            const match = part.match(/<([^>]+)>;\s*rel="([^"]+)"/);
            if (match) {
                links[match[2]] = match[1];
            }
        });
        
        return links;
    }
    
    /**
     * Get cache key
     */
    getCacheKey(endpoint, params) {
        return `${endpoint}:${JSON.stringify(params)}`;
    }
    
    /**
     * Clear cache
     */
    clearCache(endpoint = null) {
        if (endpoint) {
            // Clear specific endpoint cache
            for (const key of this.cache.keys()) {
                if (key.startsWith(endpoint)) {
                    this.cache.delete(key);
                }
            }
        } else {
            // Clear all cache
            this.cache.clear();
        }
    }
    
    /**
     * Add request interceptor
     */
    addRequestInterceptor(interceptor) {
        this.requestInterceptors.push(interceptor);
    }
    
    /**
     * Add response interceptor
     */
    addResponseInterceptor(interceptor) {
        this.responseInterceptors.push(interceptor);
    }
}

/**
 * Custom API Error class
 */
class APIError extends Error {
    constructor(message, status, data) {
        super(message);
        this.name = 'APIError';
        this.status = status;
        this.data = data;
    }
}
                        </code></pre>
                    </section>
                    
                    <!-- CRUD Operations -->
                    <section>
                        <h2>CRUD Operations</h2>
                        
                        <h3>Complete CRUD Implementation</h3>
                        <pre><code class="language-javascript">
/**
 * WordPress CRUD Operations
 */
class WordPressCRUD {
    constructor(apiClient) {
        this.api = apiClient;
    }
    
    /**
     * Posts CRUD
     */
    posts = {
        // Get all posts with pagination
        async getAll(params = {}) {
            const defaultParams = {
                per_page: 10,
                page: 1,
                _embed: true, // Include embedded data
                ...params
            };
            
            return this.api.get('posts', defaultParams);
        },
        
        // Get single post
        async get(id, params = {}) {
            return this.api.get(`posts/${id}`, {
                _embed: true,
                ...params
            });
        },
        
        // Create post
        async create(data) {
            const postData = {
                title: data.title,
                content: data.content,
                status: data.status || 'draft',
                excerpt: data.excerpt || '',
                featured_media: data.featured_media || 0,
                categories: data.categories || [],
                tags: data.tags || [],
                meta: data.meta || {}
            };
            
            return this.api.post('posts', postData);
        },
        
        // Update post
        async update(id, data) {
            return this.api.put(`posts/${id}`, data);
        },
        
        // Delete post
        async delete(id, force = false) {
            const endpoint = force ? `posts/${id}?force=true` : `posts/${id}`;
            return this.api.delete(endpoint);
        },
        
        // Search posts
        async search(query, params = {}) {
            return this.api.get('posts', {
                search: query,
                ...params
            });
        },
        
        // Get posts by author
        async getByAuthor(authorId, params = {}) {
            return this.api.get('posts', {
                author: authorId,
                ...params
            });
        },
        
        // Get posts by category
        async getByCategory(categoryId, params = {}) {
            return this.api.get('posts', {
                categories: categoryId,
                ...params
            });
        }
    };
    
    /**
     * Media CRUD
     */
    media = {
        // Upload media
        async upload(file, data = {}) {
            const formData = new FormData();
            formData.append('file', file);
            
            // Add additional data
            Object.keys(data).forEach(key => {
                formData.append(key, data[key]);
            });
            
            // Don't use JSON content type for file uploads
            const headers = { ...this.api.headers };
            delete headers['Content-Type'];
            
            const response = await fetch(`${this.api.baseURL}/${this.api.namespace}/media`, {
                method: 'POST',
                headers: {
                    'X-WP-Nonce': this.api.nonce
                },
                credentials: 'include',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error('Upload failed');
            }
            
            return response.json();
        },
        
        // Get media items
        async getAll(params = {}) {
            return this.api.get('media', params);
        },
        
        // Get single media item
        async get(id) {
            return this.api.get(`media/${id}`);
        },
        
        // Update media details
        async update(id, data) {
            return this.api.put(`media/${id}`, data);
        },
        
        // Delete media
        async delete(id, force = false) {
            const endpoint = force ? `media/${id}?force=true` : `media/${id}`;
            return this.api.delete(endpoint);
        }
    };
    
    /**
     * Users CRUD
     */
    users = {
        // Get all users
        async getAll(params = {}) {
            return this.api.get('users', params);
        },
        
        // Get current user
        async getCurrent() {
            return this.api.get('users/me');
        },
        
        // Get single user
        async get(id) {
            return this.api.get(`users/${id}`);
        },
        
        // Create user (requires admin)
        async create(data) {
            return this.api.post('users', data);
        },
        
        // Update user
        async update(id, data) {
            return this.api.put(`users/${id}`, data);
        },
        
        // Delete user (requires admin)
        async delete(id, reassign = null) {
            const endpoint = reassign 
                ? `users/${id}?force=true&reassign=${reassign}`
                : `users/${id}?force=true`;
            return this.api.delete(endpoint);
        }
    };
    
    /**
     * Comments CRUD
     */
    comments = {
        // Get comments
        async getAll(params = {}) {
            return this.api.get('comments', params);
        },
        
        // Get comments for a post
        async getForPost(postId, params = {}) {
            return this.api.get('comments', {
                post: postId,
                ...params
            });
        },
        
        // Create comment
        async create(data) {
            return this.api.post('comments', {
                post: data.post,
                content: data.content,
                author_name: data.author_name || '',
                author_email: data.author_email || '',
                parent: data.parent || 0
            });
        },
        
        // Update comment
        async update(id, data) {
            return this.api.put(`comments/${id}`, data);
        },
        
        // Delete comment
        async delete(id, force = false) {
            const endpoint = force ? `comments/${id}?force=true` : `comments/${id}`;
            return this.api.delete(endpoint);
        }
    };
}

// Usage example
const apiClient = new WPRestClient({
    nonce: wpApiSettings.nonce
});

const wordpress = new WordPressCRUD(apiClient);

// Get posts
wordpress.posts.getAll({ per_page: 5 }).then(result => {
    console.log('Posts:', result.data);
    console.log('Pagination:', result.pagination);
});

// Create a post
wordpress.posts.create({
    title: 'New Post Title',
    content: 'Post content here',
    status: 'publish'
}).then(result => {
    console.log('Created post:', result.data);
});
                        </code></pre>
                    </section>
                    
                    <!-- Real-time Updates -->
                    <section>
                        <h2>Real-time Updates and Polling</h2>
                        
                        <h3>Live Data Updates</h3>
                        <pre><code class="language-javascript">
/**
 * Real-time updates with polling and WebSocket fallback
 */
class RealTimeAPI {
    constructor(apiClient, options = {}) {
        this.api = apiClient;
        this.pollingIntervals = new Map();
        this.websocket = null;
        this.listeners = new Map();
        this.options = {
            pollingInterval: 5000, // 5 seconds
            websocketURL: null,
            reconnectDelay: 3000,
            maxReconnectAttempts: 5,
            ...options
        };
        
        this.reconnectAttempts = 0;
    }
    
    /**
     * Start polling an endpoint
     */
    startPolling(key, endpoint, params = {}, callback) {
        // Clear existing polling for this key
        this.stopPolling(key);
        
        // Initial fetch
        this.fetchAndNotify(endpoint, params, callback);
        
        // Set up polling interval
        const interval = setInterval(() => {
            this.fetchAndNotify(endpoint, params, callback);
        }, this.options.pollingInterval);
        
        this.pollingIntervals.set(key, interval);
    }
    
    /**
     * Stop polling
     */
    stopPolling(key) {
        if (this.pollingIntervals.has(key)) {
            clearInterval(this.pollingIntervals.get(key));
            this.pollingIntervals.delete(key);
        }
    }
    
    /**
     * Fetch and notify
     */
    async fetchAndNotify(endpoint, params, callback) {
        try {
            const result = await this.api.get(endpoint, params, false); // Don't use cache
            callback(result.data, null);
        } catch (error) {
            callback(null, error);
        }
    }
    
    /**
     * Connect to WebSocket for real-time updates
     */
    connectWebSocket() {
        if (!this.options.websocketURL) {
            console.warn('WebSocket URL not configured');
            return;
        }
        
        this.websocket = new WebSocket(this.options.websocketURL);
        
        this.websocket.onopen = () => {
            console.log('WebSocket connected');
            this.reconnectAttempts = 0;
            
            // Authenticate
            this.websocket.send(JSON.stringify({
                type: 'auth',
                nonce: this.api.nonce
            }));
        };
        
        this.websocket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleWebSocketMessage(data);
        };
        
        this.websocket.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
        
        this.websocket.onclose = () => {
            console.log('WebSocket disconnected');
            this.attemptReconnect();
        };
    }
    
    /**
     * Handle WebSocket message
     */
    handleWebSocketMessage(data) {
        const { type, payload } = data;
        
        // Notify all listeners for this type
        if (this.listeners.has(type)) {
            this.listeners.get(type).forEach(callback => {
                callback(payload);
            });
        }
    }
    
    /**
     * Subscribe to WebSocket events
     */
    subscribe(eventType, callback) {
        if (!this.listeners.has(eventType)) {
            this.listeners.set(eventType, new Set());
        }
        
        this.listeners.get(eventType).add(callback);
        
        // Send subscription message to server
        if (this.websocket?.readyState === WebSocket.OPEN) {
            this.websocket.send(JSON.stringify({
                type: 'subscribe',
                event: eventType
            }));
        }
    }
    
    /**
     * Unsubscribe from events
     */
    unsubscribe(eventType, callback) {
        if (this.listeners.has(eventType)) {
            this.listeners.get(eventType).delete(callback);
            
            // If no more listeners, unsubscribe from server
            if (this.listeners.get(eventType).size === 0) {
                this.listeners.delete(eventType);
                
                if (this.websocket?.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify({
                        type: 'unsubscribe',
                        event: eventType
                    }));
                }
            }
        }
    }
    
    /**
     * Attempt to reconnect WebSocket
     */
    attemptReconnect() {
        if (this.reconnectAttempts < this.options.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`Attempting to reconnect... (${this.reconnectAttempts}/${this.options.maxReconnectAttempts})`);
            
            setTimeout(() => {
                this.connectWebSocket();
            }, this.options.reconnectDelay);
        } else {
            console.error('Max reconnection attempts reached');
        }
    }
    
    /**
     * Disconnect WebSocket
     */
    disconnect() {
        if (this.websocket) {
            this.websocket.close();
            this.websocket = null;
        }
        
        // Clear all polling
        this.pollingIntervals.forEach((interval, key) => {
            this.stopPolling(key);
        });
    }
}

// Usage
const realTime = new RealTimeAPI(apiClient, {
    pollingInterval: 3000,
    websocketURL: 'wss://example.com/ws'
});

// Start polling for new posts
realTime.startPolling('recent-posts', 'posts', { per_page: 5 }, (data, error) => {
    if (error) {
        console.error('Polling error:', error);
        return;
    }
    
    updatePostsList(data);
});

// Connect WebSocket for real-time notifications
realTime.connectWebSocket();

// Subscribe to new post events
realTime.subscribe('new-post', (post) => {
    console.log('New post created:', post);
    addPostToList(post);
});

// Subscribe to comment events
realTime.subscribe('new-comment', (comment) => {
    console.log('New comment:', comment);
    addCommentToPost(comment);
});
                        </code></pre>
                    </section>
                    
                    <!-- UI Components -->
                    <section>
                        <h2>Interactive UI Components</h2>
                        
                        <h3>Building Dynamic Interfaces</h3>
                        <pre><code class="language-javascript">
/**
 * Post List Component
 */
class PostListComponent {
    constructor(container, apiClient) {
        this.container = container;
        this.api = apiClient;
        this.wordpress = new WordPressCRUD(apiClient);
        this.posts = [];
        this.currentPage = 1;
        this.totalPages = 1;
        this.loading = false;
        
        this.init();
    }
    
    async init() {
        this.render();
        await this.loadPosts();
        this.attachEventListeners();
    }
    
    render() {
        this.container.innerHTML = `
            <div class="post-list-component">
                <div class="post-list-header">
                    <h2>Posts</h2>
                    <button class="btn btn-primary" id="create-post-btn">
                        <span class="icon">+</span> New Post
                    </button>
                </div>
                
                <div class="post-list-filters">
                    <input type="text" id="search-input" placeholder="Search posts..." />
                    <select id="category-filter">
                        <option value="">All Categories</option>
                    </select>
                    <select id="sort-by">
                        <option value="date">Date</option>
                        <option value="title">Title</option>
                        <option value="modified">Modified</option>
                    </select>
                </div>
                
                <div class="post-list-content">
                    <div class="loading-spinner" style="display: none;">
                        <div class="spinner"></div>
                    </div>
                    <div class="post-list"></div>
                </div>
                
                <div class="post-list-pagination">
                    <button id="prev-page" disabled>Previous</button>
                    <span class="page-info">Page <span id="current-page">1</span> of <span id="total-pages">1</span></span>
                    <button id="next-page">Next</button>
                </div>
            </div>
        `;
        
        this.loadCategories();
    }
    
    async loadPosts(page = 1) {
        if (this.loading) return;
        
        this.loading = true;
        this.showLoading();
        
        try {
            const searchTerm = document.getElementById('search-input').value;
            const categoryId = document.getElementById('category-filter').value;
            const sortBy = document.getElementById('sort-by').value;
            
            const params = {
                page,
                per_page: 10,
                orderby: sortBy,
                order: 'desc',
                _embed: true
            };
            
            if (searchTerm) {
                params.search = searchTerm;
            }
            
            if (categoryId) {
                params.categories = categoryId;
            }
            
            const result = await this.wordpress.posts.getAll(params);
            
            this.posts = result.data;
            this.currentPage = page;
            this.totalPages = result.pagination.totalPages;
            
            this.renderPosts();
            this.updatePagination();
            
        } catch (error) {
            console.error('Failed to load posts:', error);
            this.showError('Failed to load posts');
        } finally {
            this.loading = false;
            this.hideLoading();
        }
    }
    
    renderPosts() {
        const postList = this.container.querySelector('.post-list');
        
        if (this.posts.length === 0) {
            postList.innerHTML = '<p class="no-posts">No posts found</p>';
            return;
        }
        
        postList.innerHTML = this.posts.map(post => `
            <div class="post-item" data-id="${post.id}">
                <div class="post-thumbnail">
                    ${this.getPostThumbnail(post)}
                </div>
                <div class="post-content">
                    <h3 class="post-title">
                        <a href="${post.link}" target="_blank">${post.title.rendered}</a>
                    </h3>
                    <div class="post-meta">
                        <span class="author">By ${this.getAuthorName(post)}</span>
                        <span class="date">${this.formatDate(post.date)}</span>
                        <span class="comments">${post._embedded?.replies?.[0]?.length || 0} comments</span>
                    </div>
                    <div class="post-excerpt">
                        ${post.excerpt.rendered}
                    </div>
                    <div class="post-actions">
                        <button class="btn btn-sm edit-post" data-id="${post.id}">Edit</button>
                        <button class="btn btn-sm delete-post" data-id="${post.id}">Delete</button>
                        <button class="btn btn-sm view-post" data-id="${post.id}">View</button>
                    </div>
                </div>
            </div>
        `).join('');
    }
    
    async loadCategories() {
        try {
            const result = await this.api.get('categories', { per_page: 100 });
            const select = document.getElementById('category-filter');
            
            result.data.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id;
                option.textContent = category.name;
                select.appendChild(option);
            });
        } catch (error) {
            console.error('Failed to load categories:', error);
        }
    }
    
    attachEventListeners() {
        // Search
        let searchTimeout;
        document.getElementById('search-input').addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                this.loadPosts(1);
            }, 500);
        });
        
        // Category filter
        document.getElementById('category-filter').addEventListener('change', () => {
            this.loadPosts(1);
        });
        
        // Sort
        document.getElementById('sort-by').addEventListener('change', () => {
            this.loadPosts(1);
        });
        
        // Pagination
        document.getElementById('prev-page').addEventListener('click', () => {
            if (this.currentPage > 1) {
                this.loadPosts(this.currentPage - 1);
            }
        });
        
        document.getElementById('next-page').addEventListener('click', () => {
            if (this.currentPage < this.totalPages) {
                this.loadPosts(this.currentPage + 1);
            }
        });
        
        // Post actions
        this.container.addEventListener('click', async (e) => {
            if (e.target.classList.contains('edit-post')) {
                const postId = e.target.dataset.id;
                this.editPost(postId);
            } else if (e.target.classList.contains('delete-post')) {
                const postId = e.target.dataset.id;
                await this.deletePost(postId);
            } else if (e.target.classList.contains('view-post')) {
                const postId = e.target.dataset.id;
                this.viewPost(postId);
            }
        });
        
        // Create post
        document.getElementById('create-post-btn').addEventListener('click', () => {
            this.createPost();
        });
    }
    
    async deletePost(postId) {
        if (!confirm('Are you sure you want to delete this post?')) {
            return;
        }
        
        try {
            await this.wordpress.posts.delete(postId);
            await this.loadPosts(this.currentPage);
            this.showSuccess('Post deleted successfully');
        } catch (error) {
            console.error('Failed to delete post:', error);
            this.showError('Failed to delete post');
        }
    }
    
    editPost(postId) {
        // Open edit modal or redirect to edit page
        const modal = new PostEditModal(postId, this.wordpress);
        modal.onSave = () => {
            this.loadPosts(this.currentPage);
        };
        modal.open();
    }
    
    viewPost(postId) {
        const post = this.posts.find(p => p.id == postId);
        if (post) {
            window.open(post.link, '_blank');
        }
    }
    
    createPost() {
        const modal = new PostEditModal(null, this.wordpress);
        modal.onSave = () => {
            this.loadPosts(1);
        };
        modal.open();
    }
    
    updatePagination() {
        document.getElementById('current-page').textContent = this.currentPage;
        document.getElementById('total-pages').textContent = this.totalPages;
        document.getElementById('prev-page').disabled = this.currentPage === 1;
        document.getElementById('next-page').disabled = this.currentPage === this.totalPages;
    }
    
    getPostThumbnail(post) {
        if (post._embedded?.['wp:featuredmedia']?.[0]) {
            const media = post._embedded['wp:featuredmedia'][0];
            return `<img src="${media.source_url}" alt="${media.alt_text}" />`;
        }
        return '<div class="no-thumbnail">No Image</div>';
    }
    
    getAuthorName(post) {
        if (post._embedded?.author?.[0]) {
            return post._embedded.author[0].name;
        }
        return 'Unknown';
    }
    
    formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        });
    }
    
    showLoading() {
        this.container.querySelector('.loading-spinner').style.display = 'flex';
    }
    
    hideLoading() {
        this.container.querySelector('.loading-spinner').style.display = 'none';
    }
    
    showSuccess(message) {
        // Implement toast notification
        console.log('Success:', message);
    }
    
    showError(message) {
        // Implement error notification
        console.error('Error:', message);
    }
}

/**
 * Post Edit Modal
 */
class PostEditModal {
    constructor(postId, wordpress) {
        this.postId = postId;
        this.wordpress = wordpress;
        this.post = null;
        this.modal = null;
        this.onSave = null;
    }
    
    async open() {
        // Load post if editing
        if (this.postId) {
            const result = await this.wordpress.posts.get(this.postId);
            this.post = result.data;
        }
        
        this.render();
        this.attachEventListeners();
    }
    
    render() {
        const modalHTML = `
            <div class="modal-overlay">
                <div class="modal">
                    <div class="modal-header">
                        <h2>${this.postId ? 'Edit Post' : 'Create Post'}</h2>
                        <button class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form id="post-form">
                            <div class="form-group">
                                <label for="post-title">Title</label>
                                <input type="text" id="post-title" value="${this.post?.title?.rendered || ''}" required />
                            </div>
                            <div class="form-group">
                                <label for="post-content">Content</label>
                                <textarea id="post-content" rows="10" required>${this.post?.content?.raw || ''}</textarea>
                            </div>
                            <div class="form-group">
                                <label for="post-status">Status</label>
                                <select id="post-status">
                                    <option value="draft" ${this.post?.status === 'draft' ? 'selected' : ''}>Draft</option>
                                    <option value="publish" ${this.post?.status === 'publish' ? 'selected' : ''}>Publish</option>
                                    <option value="private" ${this.post?.status === 'private' ? 'selected' : ''}>Private</option>
                                </select>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" id="cancel-btn">Cancel</button>
                        <button class="btn btn-primary" id="save-btn">Save</button>
                    </div>
                </div>
            </div>
        `;
        
        const modalContainer = document.createElement('div');
        modalContainer.innerHTML = modalHTML;
        document.body.appendChild(modalContainer);
        this.modal = modalContainer.querySelector('.modal-overlay');
    }
    
    attachEventListeners() {
        this.modal.querySelector('.modal-close').addEventListener('click', () => this.close());
        this.modal.querySelector('#cancel-btn').addEventListener('click', () => this.close());
        this.modal.querySelector('#save-btn').addEventListener('click', () => this.save());
    }
    
    async save() {
        const title = document.getElementById('post-title').value;
        const content = document.getElementById('post-content').value;
        const status = document.getElementById('post-status').value;
        
        const data = {
            title,
            content,
            status
        };
        
        try {
            if (this.postId) {
                await this.wordpress.posts.update(this.postId, data);
            } else {
                await this.wordpress.posts.create(data);
            }
            
            if (this.onSave) {
                this.onSave();
            }
            
            this.close();
        } catch (error) {
            console.error('Failed to save post:', error);
            alert('Failed to save post');
        }
    }
    
    close() {
        this.modal.remove();
    }
}

// Initialize component
document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('post-list-container');
    if (container) {
        const apiClient = new WPRestClient({
            nonce: wpApiSettings.nonce
        });
        
        new PostListComponent(container, apiClient);
    }
});
                        </code></pre>
                    </section>
                    
                    <!-- Error Handling -->
                    <section>
                        <h2>Error Handling and Retry Logic</h2>
                        
                        <h3>Robust Error Management</h3>
                        <pre><code class="language-javascript">
/**
 * Advanced error handling with retry logic
 */
class APIErrorHandler {
    constructor(options = {}) {
        this.options = {
            maxRetries: 3,
            retryDelay: 1000,
            exponentialBackoff: true,
            onError: null,
            ...options
        };
        
        this.retryCount = new Map();
    }
    
    /**
     * Wrap API call with error handling and retry
     */
    async withRetry(fn, context = null) {
        const key = fn.toString();
        let lastError;
        
        for (let attempt = 0; attempt <= this.options.maxRetries; attempt++) {
            try {
                const result = await fn.call(context);
                this.retryCount.delete(key);
                return result;
            } catch (error) {
                lastError = error;
                
                if (!this.shouldRetry(error, attempt)) {
                    break;
                }
                
                const delay = this.calculateDelay(attempt);
                console.log(`Retry attempt ${attempt + 1} after ${delay}ms`);
                
                await this.sleep(delay);
            }
        }
        
        // All retries failed
        this.handleError(lastError);
        throw lastError;
    }
    
    /**
     * Determine if error should trigger retry
     */
    shouldRetry(error, attempt) {
        if (attempt >= this.options.maxRetries) {
            return false;
        }
        
        // Retry on network errors
        if (error.name === 'NetworkError' || error.message === 'Failed to fetch') {
            return true;
        }
        
        // Retry on specific status codes
        if (error.status) {
            const retryableStatuses = [408, 429, 500, 502, 503, 504];
            return retryableStatuses.includes(error.status);
        }
        
        return false;
    }
    
    /**
     * Calculate retry delay
     */
    calculateDelay(attempt) {
        if (this.options.exponentialBackoff) {
            return this.options.retryDelay * Math.pow(2, attempt);
        }
        return this.options.retryDelay;
    }
    
    /**
     * Handle error
     */
    handleError(error) {
        console.error('API Error:', error);
        
        if (this.options.onError) {
            this.options.onError(error);
        }
        
        // Show user-friendly error message
        this.showErrorNotification(error);
    }
    
    /**
     * Show error notification
     */
    showErrorNotification(error) {
        let message = 'An error occurred';
        
        if (error.status === 401) {
            message = 'You are not authorized. Please log in.';
        } else if (error.status === 403) {
            message = 'You do not have permission to perform this action.';
        } else if (error.status === 404) {
            message = 'The requested resource was not found.';
        } else if (error.status === 429) {
            message = 'Too many requests. Please try again later.';
        } else if (error.status >= 500) {
            message = 'Server error. Please try again later.';
        } else if (error.message) {
            message = error.message;
        }
        
        // Create notification element
        const notification = document.createElement('div');
        notification.className = 'error-notification';
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        // Remove after 5 seconds
        setTimeout(() => {
            notification.remove();
        }, 5000);
    }
    
    /**
     * Sleep helper
     */
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Usage
const errorHandler = new APIErrorHandler({
    maxRetries: 3,
    retryDelay: 1000,
    exponentialBackoff: true,
    onError: (error) => {
        // Custom error handling
        if (error.status === 401) {
            // Redirect to login
            window.location.href = '/login';
        }
    }
});

// Wrap API calls
const apiWithRetry = {
    async get(endpoint, params) {
        return errorHandler.withRetry(async () => {
            return apiClient.get(endpoint, params);
        });
    },
    
    async post(endpoint, data) {
        return errorHandler.withRetry(async () => {
            return apiClient.post(endpoint, data);
        });
    }
};
                        </code></pre>
                    </section>
                    
                    <!-- Summary -->
                    <section>
                        <h2>Summary</h2>
                        
                        <div class="summary-box">
                            <h3>Key Takeaways</h3>
                            <ul>
                                <li>Modern JavaScript makes REST API interaction clean and efficient</li>
                                <li>Proper client architecture improves maintainability</li>
                                <li>CRUD operations follow consistent patterns</li>
                                <li>Real-time updates enhance user experience</li>
                                <li>Error handling and retry logic improve reliability</li>
                                <li>UI components should be modular and reusable</li>
                            </ul>
                        </div>
                        
                        <div class="best-practices">
                            <h3>JavaScript API Best Practices</h3>
                            <ul>
                                <li>Use async/await for cleaner code</li>
                                <li>Implement proper error handling</li>
                                <li>Cache responses when appropriate</li>
                                <li>Use interceptors for common logic</li>
                                <li>Implement retry logic for network failures</li>
                                <li>Show loading states for better UX</li>
                                <li>Validate data before sending</li>
                            </ul>
                        </div>
                    </section>
                    
                    <!-- Additional Resources -->
                    <section class="resources">
                        <h2>Additional Resources</h2>
                        <ul>
                            <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank">Fetch API Documentation</a></li>
                            <li><a href="https://developer.wordpress.org/rest-api/using-the-rest-api/client-libraries/" target="_blank">WordPress REST API Client Libraries</a></li>
                            <li><a href="https://javascript.info/async-await" target="_blank">Async/Await Tutorial</a></li>
                            <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank">WebSockets API</a></li>
                        </ul>
                    </section>
                </div>
                
                <!-- Lesson Navigation -->
                <div class="lesson-navigation">
                    <a href="/07module/custom_response_formats.html" class="lesson-nav-button prev">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"/>
                        </svg>
                        <span>
                            <small>Previous</small><br>
                            Response Formats
                        </span>
                    </a>
                    
                    <button class="complete-lesson-btn">
                        Mark as Complete
                    </button>
                    
                    <a href="/07module/homework_rest_api.html" class="lesson-nav-button next">
                        <span>
                            <small>Next</small><br>
                            Homework Project
                        </span>
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"/>
                        </svg>
                    </a>
                </div>
            </div>
        </main>
        
        <!-- Footer -->
        <footer class="site-footer" role="contentinfo">
            <div class="footer-container">
                <div class="footer-content">
                    <div class="footer-section footer-about">
                        <h3>PHP WordPress Development</h3>
                        <p>Complete Web Development Course - From HTML to WordPress</p>
                    </div>
                    
                    <div class="footer-section">
                        <h4>Quick Links</h4>
                        <ul class="footer-links">
                            <li><a href="/">Home</a></li>
                            <li><a href="/module7.html">Module 7</a></li>
                            <li><a href="/resources.html">Resources</a></li>
                            <li><a href="/about.html">About</a></li>
                        </ul>
                    </div>
                </div>
                
                <div class="footer-bottom">
                    <p>&copy; 2025 PHP WordPress Development Course. All rights reserved.</p>
                </div>
            </div>
        </footer>
    </div>
    
    <!-- JavaScript -->
    <script src="/assets/js/prism.js"></script>
    <script src="/assets/js/main.js"></script>
    <script src="/assets/js/lesson.js"></script>
</body>
</html>