<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced OOP Concepts in PHP: Inheritance and Beyond</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <header>
        <h1>Advanced OOP Concepts in PHP</h1>
        <p><a href="index.html">‚Üê Back to Syllabus</a></p>
    </header>
    
    <main>
        <section class="module-intro">
            <h2>Building Complex Applications with PHP OOP</h2>
            <p>Welcome to our exploration of advanced object-oriented programming concepts in PHP! This lesson builds on our previous introduction to OOP fundamentals and will equip you with powerful tools to create more maintainable, flexible, and robust applications.</p>
            
            <div class="note">
                <p><strong>Why These Concepts Matter:</strong> The concepts we'll cover today form the foundation of WordPress core architecture. Understanding inheritance, interfaces, and traits will dramatically improve your ability to extend WordPress functionality and work with its codebase.</p>
            </div>
        </section>

        <section id="inheritance">
            <h2>Inheritance: The Family Tree of Classes</h2>
            
            <p>Inheritance is a fundamental concept in object-oriented programming that allows a class to inherit properties and methods from another class. Think of inheritance like a family tree - children inherit traits from their parents while developing their own unique characteristics.</p>
            
            <div class="diagram">
                <h3>Visualizing Class Inheritance</h3>
                <div class="mermaid">
                    classDiagram
                      class Vehicle {
                        +string make
                        +string model
                        +int year
                        +start()
                        +stop()
                      }
                      class Car {
                        +int numberOfDoors
                        +bool hasAirbags
                        +drive()
                      }
                      class ElectricCar {
                        +int batteryCapacity
                        +int range
                        +charge()
                      }
                      Vehicle <|-- Car
                      Car <|-- ElectricCar
                </div>
            </div>
            
            <h3>How Inheritance Works in PHP</h3>
            
            <p>In PHP, we use the <code>extends</code> keyword to create a child class that inherits from a parent class. The child class (also called a subclass) inherits all non-private properties and methods from the parent class (superclass).</p>
            
            <div class="code-example">
                <h4>Basic Inheritance Example</h4>
                <pre>###CODE_BLOCK_1###</pre>
            </div>
            
            <h3>Key Inheritance Concepts</h3>
            
            <div class="concept-list">
                <div class="concept">
                    <h4>The <code>parent::</code> Keyword</h4>
                    <p>Use <code>parent::</code> to access parent class methods from within the child class. This is particularly useful in constructors and when overriding methods but still needing to access the parent's functionality.</p>
                </div>
                
                <div class="concept">
                    <h4>Access Modifiers and Inheritance</h4>
                    <p><strong>Private</strong> properties/methods are NOT inherited and can only be accessed within the class that defines them.</p>
                    <p><strong>Protected</strong> properties/methods ARE inherited and can be accessed within the class and any of its subclasses.</p>
                    <p><strong>Public</strong> properties/methods ARE inherited and can be accessed from anywhere.</p>
                </div>
                
                <div class="concept">
                    <h4>Multi-level Inheritance</h4>
                    <p>PHP supports multi-level inheritance, where a class can extend another class which itself extends a third class, creating a chain of inheritance.</p>
                    <pre>###CODE_BLOCK_4###</pre>
                </div>
            </div>
            
            <h3>Real-World Application: WordPress Menu System</h3>
            
            <p>WordPress uses inheritance extensively in its menu system. The <code>Walker</code> class is a parent class that provides functionality for traversing hierarchical data structures like menus, categories, and comments.</p>
            
            <div class="code-example">
                <h4>Simplified WordPress Walker Example</h4>
                <pre>###CODE_BLOCK_6###</pre>
            </div>
            
            <div class="pro-tip">
                <h4>When to Use Inheritance</h4>
                <p>Inheritance is best used when you have an "is-a" relationship. A Car "is-a" Vehicle, an ElectricCar "is-a" Car. Use inheritance when:</p>
                <ul>
                    <li>You need to represent a hierarchy of objects</li>
                    <li>There's a clear parent/child relationship</li>
                    <li>The child class adds or modifies behavior while keeping core functionality</li>
                </ul>
                <p>Avoid inheritance when the relationship is "has-a" (use composition instead) or when inheritance would create too complex a hierarchy.</p>
            </div>
        </section>

        <section id="method-overriding">
            <h2>Method Overriding: Customizing Inherited Behavior</h2>
            
            <p>Method overriding is a feature that allows a child class to provide a specific implementation of a method already defined in its parent class. It's like inheriting a family recipe but changing some ingredients to better suit your taste.</p>
            
            <div class="diagram">
                <h3>Method Overriding Visualization</h3>
                <div class="mermaid">
                    sequenceDiagram
                        participant Client
                        participant Car
                        participant Vehicle
                        Client->>Car: Call getInfo()
                        Note right of Car: Car checks if it has its own getInfo()
                        Car->>Car: Execute overridden getInfo()
                        Car->>Vehicle: Call parent::getInfo()
                        Vehicle-->>Car: Return base info
                        Car-->>Client: Return enhanced info
                </div>
            </div>
            
            <h3>Method Overriding Rules in PHP</h3>
            
            <ul>
                <li>The method in the child class must have the same name as the method in the parent class</li>
                <li>The method signature should match (same number and type of parameters)</li>
                <li>The visibility can be changed to be less restrictive but not more restrictive (e.g., protected in parent can become public in child, but not private)</li>
                <li>Type hints and return types must be compatible</li>
            </ul>
            
            <div class="code-example">
                <h4>Method Overriding Example</h4>
                <pre>###CODE_BLOCK_7###</pre>
            </div>
            
            <h3>Real-World Example: WooCommerce Product Types</h3>
            
            <p>In WooCommerce, different product types extend a base Product class and override methods like price calculation to handle their specific needs:</p>
            
            <div class="code-example">
                <h4>Simplified WooCommerce Product Example</h4>
                <pre>###CODE_BLOCK_8###</pre>
            </div>
            
            <div class="pro-tip">
                <h4>Best Practices for Method Overriding</h4>
                <ul>
                    <li>Use <code>parent::methodName()</code> when you want to extend rather than completely replace behavior</li>
                    <li>Keep the method signature consistent for better maintainability</li>
                    <li>Document why you're overriding the method for future developers</li>
                    <li>Don't override unnecessarily - only when the child class truly needs different behavior</li>
                </ul>
            </div>
        </section>

        <section id="abstract-classes">
            <h2>Abstract Classes: Blueprint for Child Classes</h2>
            
            <p>Abstract classes are like blueprints that can't be directly instantiated but serve as a template for other classes. Think of them as an architectural plan - you can't live in the plan itself, but you can build concrete houses based on it.</p>
            
            <div class="diagram">
                <h3>Abstract Class Structure</h3>
                <div class="mermaid">
                    classDiagram
                      class Database {
                        <<abstract>>
                        #connection
                        +connect()
                        +disconnect()
                        +query()*
                        +getLastError()*
                      }
                      class MySQLDatabase {
                        +query()
                        +getLastError()
                      }
                      class PostgreSQLDatabase {
                        +query()
                        +getLastError()
                      }
                      Database <|-- MySQLDatabase
                      Database <|-- PostgreSQLDatabase
                      note for Database "Methods with * are abstract"
                </div>
            </div>
            
            <h3>Key Features of Abstract Classes</h3>
            
            <ul>
                <li>Cannot be instantiated directly (cannot use <code>new AbstractClass()</code>)</li>
                <li>Can contain a mix of abstract and concrete methods</li>
                <li>Abstract methods only have a signature, no implementation</li>
                <li>Classes that extend an abstract class MUST implement all its abstract methods</li>
                <li>Can contain properties and constants like regular classes</li>
                <li>Can define constructor and destructor methods</li>
            </ul>
            
            <div class="code-example">
                <h4>Abstract Class Example</h4>
                <pre>###CODE_BLOCK_11###</pre>
            </div>
            
            <h3>When to Use Abstract Classes</h3>
            
            <ul>
                <li>When you want to provide a common base implementation with some required methods</li>
                <li>When you have multiple related classes that share common behavior</li>
                <li>When you want to enforce a certain structure on child classes</li>
                <li>When you need constructor logic in the parent class</li>
            </ul>
            
            <h3>Real-World Example: WordPress Customizer</h3>
            
            <p>WordPress uses abstract classes for its Customizer framework, where different control types share common functionality but require specific implementations:</p>
            
            <div class="code-example">
                <h4>Simplified WordPress Customizer Example</h4>
                <pre>###CODE_BLOCK_12###</pre>
            </div>
            
            <div class="pro-tip">
                <h4>Abstract Classes vs. Interfaces</h4>
                <p>People often confuse abstract classes with interfaces. Here's the key difference:</p>
                <ul>
                    <li><strong>Abstract Class:</strong> "Is a partial implementation" - can contain both concrete and abstract methods, and can have properties</li>
                    <li><strong>Interface:</strong> "Is a contract only" - can only contain method signatures, no implementation, no properties</li>
                </ul>
                <p>Use abstract classes when child classes share common functionality. Use interfaces when you need multiple unrelated classes to implement the same contract.</p>
            </div>
        </section>

        <section id="interfaces">
            <h2>Interfaces: Contracts for Classes</h2>
            
            <p>Interfaces are contracts that specify what methods a class must implement, without specifying how those methods should be implemented. Think of interfaces as a job description listing required skills, while the employee (implementing class) decides how to apply those skills.</p>
            
            <div class="diagram">
                <h3>Interface Implementation</h3>
                <div class="mermaid">
                    classDiagram
                      class Loggable {
                        <<interface>>
                        +log(message)
                        +getLogHistory()
                      }
                      class FileSystem {
                        <<interface>>
                        +read(path)
                        +write(path, content)
                        +delete(path)
                      }
                      class FileLogger {
                        -logFile
                        +log(message)
                        +getLogHistory()
                      }
                      class DatabaseLogger {
                        -dbConnection
                        +log(message)
                        +getLogHistory()
                      }
                      class LocalFileSystem {
                        +read(path)
                        +write(path, content)
                        +delete(path)
                      }
                      Loggable <|.. FileLogger
                      Loggable <|.. DatabaseLogger
                      FileSystem <|.. LocalFileSystem
                </div>
            </div>
            
            <h3>Key Features of Interfaces</h3>
            
            <ul>
                <li>Define a contract with method signatures only (no implementation)</li>
                <li>Cannot contain properties (only constants)</li>
                <li>All methods must be public</li>
                <li>A class can implement multiple interfaces</li>
                <li>Cannot be instantiated directly</li>
                <li>Since PHP 8.0, interfaces can define constants</li>
            </ul>
            
            <div class="code-example">
                <h4>Interface Example</h4>
                <pre>###CODE_BLOCK_13###</pre>
            </div>
            
            <h3>Real-World Example: WordPress Hooks System</h3>
            
            <p>WordPress uses interfaces to define contracts for objects that need to interact with its hooks system:</p>
            
            <div class="code-example">
                <h4>Simplified WordPress Hook Example</h4>
                <pre>###CODE_BLOCK_14###</pre>
            </div>
            
            <div class="pro-tip">
                <h4>When to Use Interfaces</h4>
                <ul>
                    <li>When you need multiple unrelated classes to follow the same contract</li>
                    <li>When you want to achieve multiple inheritance-like functionality</li>
                    <li>When you need to define a contract without implementation details</li>
                    <li>When you want to type-hint in method parameters or return types</li>
                    <li>When you're creating a plugin or framework that others will extend</li>
                </ul>
            </div>
        </section>

        <section id="namespaces">
            <h2>Namespaces: Organizing Your Code</h2>
            
            <p>Namespaces are like zip codes or neighborhoods in a city - they help organize and group related classes, functions, and constants to prevent naming conflicts. Think of namespaces as organizing your code into different folders.</p>
            
            <div class="diagram">
                <h3>Namespace Organization</h3>
                <div class="mermaid">
                    graph TD
                        Root[PHP Application]
                        App[App Namespace]
                        Controllers[App\\Controllers]
                        Models[App\Models]
                        Utils[App\Utils]
                        Payments[App\Payments]
                        PayPal[App\Payments\PayPal]
                        Stripe[App\Payments\\Stripe]
                        
                        Root --> App
                        App --> Controllers
                        App --> Models
                        App --> Utils
                        App --> Payments
                        Payments --> PayPal
                        Payments --> Stripe
                </div>
            </div>
            
            <h3>Key Features of Namespaces</h3>
            
            <ul>
                <li>Help avoid name collisions between classes, functions, and constants</li>
                <li>Allow for better organization of code in larger applications</li>
                <li>Support sub-namespaces using the backslash (\) character</li>
                <li>Include mechanism for importing namespaces with <code>use</code> statements</li>
                <li>Can be aliased using the <code>as</code> keyword</li>
            </ul>
            
            <div class="code-example">
                <h4>Namespace Examples</h4>
                <pre>###CODE_BLOCK_17###</pre>
            </div>
            
            <h3>Global Namespace and Special Namespace Keywords</h3>
            
            <ul>
                <li><code>\</code> (leading backslash) - References the global namespace</li>
                <li><code>namespace</code> keyword - Used to define a namespace</li>
                <li><code>use</code> keyword - Imports a namespace</li>
                <li><code>as</code> keyword - Creates an alias for an imported namespace</li>
            </ul>
            
            <div class="code-example">
                <h4>Special Namespace Features</h4>
                <pre>###CODE_BLOCK_22###</pre>
            </div>
            
            <h3>Real-World Example: WordPress Plugin Organization</h3>
            
            <p>Modern WordPress plugins use namespaces to organize their code and prevent conflicts with other plugins:</p>
            
            <div class="code-example">
                <h4>WordPress Plugin Namespace Example</h4>
                <pre>###CODE_BLOCK_23###</pre>
            </div>
            
            <div class="pro-tip">
                <h4>Namespace Best Practices</h4>
                <ul>
                    <li>Follow PSR-4 autoloading standards where namespace structure mirrors directory structure</li>
                    <li>Use vendor names for plugins and themes (e.g., <code>YourCompany\PluginName</code>)</li>
                    <li>Group related functionality in sub-namespaces (Admin, Frontend, API, etc.)</li>
                    <li>Import only the classes you need, not entire namespaces</li>
                    <li>Consider using Composer's autoloader for automatic class loading</li>
                </ul>
            </div>
        </section>

        <section id="traits">
            <h2>Traits: Reusable Code Snippets</h2>
            
            <p>Traits are a mechanism for code reuse in single inheritance languages like PHP. Think of traits as mix-ins or building blocks that you can use to add functionality to classes without inheritance. Like recipe components you can mix and match to create different dishes.</p>
            
            <div class="diagram">
                <h3>Traits in Action</h3>
                <div class="mermaid">
                    classDiagram
                      class LoggableTrait {
                        <<trait>>
                        -logFile
                        +log(message)
                        +getLogHistory()
                      }
                      class SingletonTrait {
                        <<trait>>
                        -static instance
                        +static getInstance()
                      }
                      class UserRepository {
                        -users
                        +findById(id)
                        +save(user)
                      }
                      class ConfigManager {
                        -settings
                        +get(key)
                        +set(key, value)
                      }
                      LoggableTrait -- UserRepository : uses
                      SingletonTrait -- ConfigManager : uses
                      LoggableTrait -- ConfigManager : uses
                </div>
            </div>
            
            <h3>Key Features of Traits</h3>
            
            <ul>
                <li>Allows horizontal code reuse (sharing code between unrelated classes)</li>
                <li>Can contain properties, methods, and abstract methods</li>
                <li>Cannot be instantiated on their own</li>
                <li>A class can use multiple traits</li>
                <li>Supports method precedence rules to resolve conflicts</li>
                <li>Can declare abstract methods that using classes must implement</li>
            </ul>
            
            <div class="code-example">
                <h4>Trait Example</h4>
                <pre>###CODE_BLOCK_25###</pre>
            </div>
            
            <h3>Trait Conflict Resolution</h3>
            
            <p>When a class uses multiple traits with the same method names, PHP provides mechanisms to resolve these conflicts:</p>
            
            <div class="code-example">
                <h4>Trait Conflict Resolution Example</h4>
                <pre>###CODE_BLOCK_26###</pre>
            </div>
            
            <h3>Real-World Example: WordPress WP_REST_Controller</h3>
            
            <p>WordPress uses traits in its REST API framework to share functionality between controller classes:</p>
            
            <div class="code-example">
                <h4>Simplified WordPress REST API Trait Example</h4>
                <pre>###CODE_BLOCK_27###</pre>
            </div>
            
            <div class="pro-tip">
                <h4>When to Use Traits</h4>
                <ul>
                    <li>When you need to share functionality between unrelated classes</li>
                    <li>When you want to avoid deep inheritance hierarchies</li>
                    <li>For cross-cutting concerns like logging, caching, or validation</li>
                    <li>When you need multiple inheritance-like behavior</li>
                    <li>For utility methods that don't justify a base class</li>
                </ul>
                <p><strong>Warning:</strong> Overuse of traits can lead to "trait soup" and make code harder to understand and maintain. Use traits for well-defined, focused functionality.</p>
            </div>
        </section>

        <section id="homework">
            <h2>Homework: Extend Your Previous Class with Inheritance</h2>
            
            <p>For this assignment, you'll take the simple class you created in the previous homework and extend it using inheritance and the other OOP concepts we've covered.</p>
            
            <div class="assignment">
                <h3>Assignment Overview</h3>
                <p>Create a small application that demonstrates inheritance, method overriding, abstract classes, interfaces, and traits. The application will be a simple product management system.</p>
                
                <h4>Requirements</h4>
                <ol>
                    <li>Create an abstract <code>Product</code> base class with:
                        <ul>
                            <li>Properties for name, price, and SKU</li>
                            <li>A constructor that sets these properties</li>
                            <li>Getters and setters for each property</li>
                            <li>A concrete <code>getInfo()</code> method that returns basic product information</li>
                            <li>An abstract <code>calculateTax()</code> method</li>
                        </ul>
                    </li>
                    <li>Create at least two child classes (e.g., <code>PhysicalProduct</code> and <code>DigitalProduct</code>) that extend the <code>Product</code> class:
                        <ul>
                            <li>Each should implement the abstract <code>calculateTax()</code> method differently</li>
                            <li>Each should override the <code>getInfo()</code> method to include child-specific information</li>
                            <li>Each should have at least one unique property and method</li>
                        </ul>
                    </li>
                    <li>Create an interface <code>Discountable</code> with methods:
                        <ul>
                            <li><code>applyDiscount($percentage)</code></li>
                            <li><code>hasActiveDiscount()</code></li>
                        </ul>
                    </li>
                    <li>Create a trait <code>Loggable</code> with methods:
                        <ul>
                            <li><code>log($message)</code></li>
                            <li><code>getLogHistory()</code></li>
                        </ul>
                    </li>
                    <li>Have at least one of your product classes implement the <code>Discountable</code> interface</li>
                    <li>Apply the <code>Loggable</code> trait to your product classes</li>
                    <li>Use namespaces to organize your code:
                        <ul>
                            <li>Place abstract classes in <code>App\Abstracts</code></li>
                            <li>Place interfaces in <code>App\Interfaces</code></li>
                            <li>Place traits in <code>App\Traits</code></li>
                            <li>Place concrete classes in <code>App\Products</code></li>
                        </ul>
                    </li>
                    <li>Create a simple index.php file that demonstrates all of these concepts working together</li>
                </ol>
                
                <h4>Starter Code</h4>
                <pre>###CODE_BLOCK_48###</pre>
                
                <h4>Bonus Challenges</h4>
                <ul>
                    <li>Create a <code>ProductRepository</code> class that uses the Singleton pattern (via a trait)</li>
                    <li>Add a <code>Searchable</code> interface and implement it in your product classes</li>
                    <li>Create a product factory to instantiate different types of products</li>
                    <li>Add unit tests for your classes using PHPUnit</li>
                </ul>
            </div>
        </section>

        <section class="summary">
            <h2>Key Takeaways</h2>
            
            <div class="takeaways">
                <div class="takeaway">
                    <h3>Inheritance</h3>
                    <p>Allows classes to inherit properties and methods from parent classes, creating a hierarchy of "is-a" relationships.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Method Overriding</h3>
                    <p>Enables child classes to provide specific implementations of methods defined in parent classes.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Abstract Classes</h3>
                    <p>Create partially implemented blueprints that define a common structure for related classes.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Interfaces</h3>
                    <p>Define contracts that classes must follow, enforcing consistent method signatures across unrelated classes.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Namespaces</h3>
                    <p>Organize and group related code to prevent naming conflicts and improve maintainability.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Traits</h3>
                    <p>Enable horizontal code reuse by injecting functionality into classes without using inheritance.</p>
                </div>
            </div>
            
            <div class="next-steps">
                <h3>Next Steps</h3>
                <p>Now that you understand these advanced OOP concepts, you'll be able to create more maintainable, flexible, and professional PHP applications. In the upcoming sessions, we'll continue building on these concepts as we dive into database integration and begin working with WordPress.</p>
            </div>
        </section>

        <section class="resources">
            <h2>Additional Resources</h2>
            
            <ul>
                <li><a href="https://www.php.net/manual/en/language.oop5.php" target="_blank">PHP Official Documentation on OOP</a></li>
                <li><a href="https://phptherightway.com/#object-oriented-programming" target="_blank">PHP The Right Way - OOP Best Practices</a></li>
                <li><a href="https://developer.wordpress.org/plugins/intro/" target="_blank">WordPress Plugin Developer Handbook</a></li>
                <li><a href="https://developer.wordpress.org/themes/basics/incorporating-the-theme-options-page/" target="_blank">WordPress Theme Developer Handbook</a></li>
            </ul>
        </section>
    </main>
    
    <footer>
        <p>&copy; 2025 PHP WordPress Development Course</p>
        <p><a href="module2.html">Back to Module 2 Overview</a> | <a href="index.html">Back to Syllabus</a></p>
    </footer>
</body>
</html>
