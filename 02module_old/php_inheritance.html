<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced OOP Concepts in PHP: Inheritance and Beyond</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <header>
        <h1>Advanced OOP Concepts in PHP</h1>
        <p><a href="index.html">‚Üê Back to Syllabus</a></p>
    </header>
    
    <main>
        <section class="module-intro">
            <h2>Building Complex Applications with PHP OOP</h2>
            <p>Welcome to our exploration of advanced object-oriented programming concepts in PHP! This lesson builds on our previous introduction to OOP fundamentals and will equip you with powerful tools to create more maintainable, flexible, and robust applications.</p>
            
            <div class="note">
                <p><strong>Why These Concepts Matter:</strong> The concepts we'll cover today form the foundation of WordPress core architecture. Understanding inheritance, interfaces, and traits will dramatically improve your ability to extend WordPress functionality and work with its codebase.</p>
            </div>
        </section>

        <section id="inheritance">
            <h2>Inheritance: The Family Tree of Classes</h2>
            
            <p>Inheritance is a fundamental concept in object-oriented programming that allows a class to inherit properties and methods from another class. Think of inheritance like a family tree - children inherit traits from their parents while developing their own unique characteristics.</p>
            
            <div class="diagram">
                <h3>Visualizing Class Inheritance</h3>
                <div class="mermaid">
                    classDiagram
                      class Vehicle {
                        +string make
                        +string model
                        +int year
                        +start()
                        +stop()
                      }
                      class Car {
                        +int numberOfDoors
                        +bool hasAirbags
                        +drive()
                      }
                      class ElectricCar {
                        +int batteryCapacity
                        +int range
                        +charge()
                      }
                      Vehicle <|-- Car
                      Car <|-- ElectricCar
                </div>
            </div>
            
            <h3>How Inheritance Works in PHP</h3>
            
            <p>In PHP, we use the <code>extends</code> keyword to create a child class that inherits from a parent class. The child class (also called a subclass) inherits all non-private properties and methods from the parent class (superclass).</p>
            
            <div class="code-example">
                <h4>Basic Inheritance Example</h4>
                <pre><code>
// Parent class
class Vehicle {
    // Properties
    protected $make;
    protected $model;
    protected $year;
    
    // Constructor
    public function __construct($make, $model, $year) {
        $this->make = $make;
        $this->model = $model;
        $this->year = $year;
    }
    
    // Methods
    public function getInfo() {
        return "Vehicle: {$this->year} {$this->make} {$this->model}";
    }
    
    public function start() {
        return "The vehicle is starting...";
    }
    
    public function stop() {
        return "The vehicle is stopping...";
    }
}

// Child class
class Car extends Vehicle {
    // Additional properties
    private $numberOfDoors;
    
    // Constructor
    public function __construct($make, $model, $year, $numberOfDoors) {
        // Call parent constructor
        parent::__construct($make, $model, $year);
        
        // Set child-specific property
        $this->numberOfDoors = $numberOfDoors;
    }
    
    // Additional method
    public function drive() {
        return "The car is driving on the road...";
    }
    
    // Enhanced method that includes parent info
    public function getInfo() {
        return parent::getInfo() . " with {$this->numberOfDoors} doors";
    }
}

// Create instances
$vehicle = new Vehicle("Generic", "Model X", 2025);
$car = new Car("Toyota", "Corolla", 2025, 4);

// Test functionality
echo $vehicle->getInfo(); // "Vehicle: 2025 Generic Model X"
echo $car->getInfo(); // "Vehicle: 2025 Toyota Corolla with 4 doors"
echo $car->start(); // "The vehicle is starting..."
echo $car->drive(); // "The car is driving on the road..."
                </code></pre>
            </div>
            
            <h3>Key Inheritance Concepts</h3>
            
            <div class="concept-list">
                <div class="concept">
                    <h4>The <code>parent::</code> Keyword</h4>
                    <p>Use <code>parent::</code> to access parent class methods from within the child class. This is particularly useful in constructors and when overriding methods but still needing to access the parent's functionality.</p>
                </div>
                
                <div class="concept">
                    <h4>Access Modifiers and Inheritance</h4>
                    <p><strong>Private</strong> properties/methods are NOT inherited and can only be accessed within the class that defines them.</p>
                    <p><strong>Protected</strong> properties/methods ARE inherited and can be accessed within the class and any of its subclasses.</p>
                    <p><strong>Public</strong> properties/methods ARE inherited and can be accessed from anywhere.</p>
                </div>
                
                <div class="concept">
                    <h4>Multi-level Inheritance</h4>
                    <p>PHP supports multi-level inheritance, where a class can extend another class which itself extends a third class, creating a chain of inheritance.</p>
                    <pre><code>
class ElectricCar extends Car {
    private $batteryCapacity;
    
    public function __construct($make, $model, $year, $doors, $batteryCapacity) {
        parent::__construct($make, $model, $year, $doors);
        $this->batteryCapacity = $batteryCapacity;
    }
    
    public function charge() {
        return "The electric car is charging...";
    }
}
                    </code></pre>
                </div>
            </div>
            
            <h3>Real-World Application: WordPress Menu System</h3>
            
            <p>WordPress uses inheritance extensively in its menu system. The <code>Walker</code> class is a parent class that provides functionality for traversing hierarchical data structures like menus, categories, and comments.</p>
            
            <div class="code-example">
                <h4>Simplified WordPress Walker Example</h4>
                <pre><code>
// Simplified version of WordPress Walker class (parent)
class Walker {
    public function walk($elements, $max_depth) {
        // Common logic for walking through hierarchical elements
        // ...
    }
    
    public function display_element($element, &$children_elements, $max_depth, $depth, $args, &$output) {
        // Common display logic
        // ...
    }
}

// Child class for navigation menus
class Walker_Nav_Menu extends Walker {
    // Override the parent methods with nav menu specific behavior
    public function start_el(&$output, $item, $depth, $args) {
        // Menu-specific starting element HTML
        $output .= "<li class='menu-item'>";
        $output .= "<a href='{$item->url}'>{$item->title}</a>";
    }
    
    public function end_el(&$output, $item, $depth, $args) {
        // Menu-specific ending element HTML
        $output .= "</li>";
    }
}

// Further specialized class for custom menu styles
class My_Custom_Menu_Walker extends Walker_Nav_Menu {
    public function start_el(&$output, $item, $depth, $args) {
        // Enhanced menu styling with custom attributes
        $output .= "<li class='custom-menu-item level-{$depth}'>";
        $output .= "<a href='{$item->url}' class='custom-link'>{$item->title}</a>";
    }
}
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h4>When to Use Inheritance</h4>
                <p>Inheritance is best used when you have an "is-a" relationship. A Car "is-a" Vehicle, an ElectricCar "is-a" Car. Use inheritance when:</p>
                <ul>
                    <li>You need to represent a hierarchy of objects</li>
                    <li>There's a clear parent/child relationship</li>
                    <li>The child class adds or modifies behavior while keeping core functionality</li>
                </ul>
                <p>Avoid inheritance when the relationship is "has-a" (use composition instead) or when inheritance would create too complex a hierarchy.</p>
            </div>
        </section>

        <section id="method-overriding">
            <h2>Method Overriding: Customizing Inherited Behavior</h2>
            
            <p>Method overriding is a feature that allows a child class to provide a specific implementation of a method already defined in its parent class. It's like inheriting a family recipe but changing some ingredients to better suit your taste.</p>
            
            <div class="diagram">
                <h3>Method Overriding Visualization</h3>
                <div class="mermaid">
                    sequenceDiagram
                        participant Client
                        participant Car
                        participant Vehicle
                        Client->>Car: Call getInfo()
                        Note right of Car: Car checks if it has its own getInfo()
                        Car->>Car: Execute overridden getInfo()
                        Car->>Vehicle: Call parent::getInfo()
                        Vehicle-->>Car: Return base info
                        Car-->>Client: Return enhanced info
                </div>
            </div>
            
            <h3>Method Overriding Rules in PHP</h3>
            
            <ul>
                <li>The method in the child class must have the same name as the method in the parent class</li>
                <li>The method signature should match (same number and type of parameters)</li>
                <li>The visibility can be changed to be less restrictive but not more restrictive (e.g., protected in parent can become public in child, but not private)</li>
                <li>Type hints and return types must be compatible</li>
            </ul>
            
            <div class="code-example">
                <h4>Method Overriding Example</h4>
                <pre><code>
class Animal {
    public function makeSound() {
        return "The animal makes a sound";
    }
    
    protected function move() {
        return "The animal moves";
    }
}

class Dog extends Animal {
    // Override the makeSound method
    public function makeSound() {
        return "The dog barks: Woof! Woof!";
    }
    
    // Override protected method and make it public (less restrictive)
    public function move() {
        return "The dog runs on four legs";
    }
}

class Cat extends Animal {
    // Override with parent method call
    public function makeSound() {
        return parent::makeSound() . ", and the cat says: Meow!";
    }
}

$animal = new Animal();
$dog = new Dog();
$cat = new Cat();

echo $animal->makeSound(); // "The animal makes a sound"
echo $dog->makeSound(); // "The dog barks: Woof! Woof!"
echo $cat->makeSound(); // "The animal makes a sound, and the cat says: Meow!"
                </code></pre>
            </div>
            
            <h3>Real-World Example: WooCommerce Product Types</h3>
            
            <p>In WooCommerce, different product types extend a base Product class and override methods like price calculation to handle their specific needs:</p>
            
            <div class="code-example">
                <h4>Simplified WooCommerce Product Example</h4>
                <pre><code>
// Base product class
class WC_Product {
    protected $price;
    protected $name;
    
    public function get_price() {
        return $this->price;
    }
    
    public function get_name() {
        return $this->name;
    }
}

// Simple product (basic override)
class WC_Product_Simple extends WC_Product {
    // Simple override to format price
    public function get_price() {
        return '$' . number_format(parent::get_price(), 2);
    }
}

// Variable product (more complex override)
class WC_Product_Variable extends WC_Product {
    protected $variations = [];
    
    // Complex override to calculate price range
    public function get_price() {
        if (empty($this->variations)) {
            return parent::get_price();
        }
        
        $prices = array_map(function($variation) {
            return $variation->get_price();
        }, $this->variations);
        
        $min_price = min($prices);
        $max_price = max($prices);
        
        if ($min_price === $max_price) {
            return '$' . number_format($min_price, 2);
        } else {
            return '$' . number_format($min_price, 2) . ' - $' . number_format($max_price, 2);
        }
    }
}
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h4>Best Practices for Method Overriding</h4>
                <ul>
                    <li>Use <code>parent::methodName()</code> when you want to extend rather than completely replace behavior</li>
                    <li>Keep the method signature consistent for better maintainability</li>
                    <li>Document why you're overriding the method for future developers</li>
                    <li>Don't override unnecessarily - only when the child class truly needs different behavior</li>
                </ul>
            </div>
        </section>

        <section id="abstract-classes">
            <h2>Abstract Classes: Blueprint for Child Classes</h2>
            
            <p>Abstract classes are like blueprints that can't be directly instantiated but serve as a template for other classes. Think of them as an architectural plan - you can't live in the plan itself, but you can build concrete houses based on it.</p>
            
            <div class="diagram">
                <h3>Abstract Class Structure</h3>
                <div class="mermaid">
                    classDiagram
                      class Database {
                        <<abstract>>
                        #connection
                        +connect()
                        +disconnect()
                        +query()*
                        +getLastError()*
                      }
                      class MySQLDatabase {
                        +query()
                        +getLastError()
                      }
                      class PostgreSQLDatabase {
                        +query()
                        +getLastError()
                      }
                      Database <|-- MySQLDatabase
                      Database <|-- PostgreSQLDatabase
                      note for Database "Methods with * are abstract"
                </div>
            </div>
            
            <h3>Key Features of Abstract Classes</h3>
            
            <ul>
                <li>Cannot be instantiated directly (cannot use <code>new AbstractClass()</code>)</li>
                <li>Can contain a mix of abstract and concrete methods</li>
                <li>Abstract methods only have a signature, no implementation</li>
                <li>Classes that extend an abstract class MUST implement all its abstract methods</li>
                <li>Can contain properties and constants like regular classes</li>
                <li>Can define constructor and destructor methods</li>
            </ul>
            
            <div class="code-example">
                <h4>Abstract Class Example</h4>
                <pre><code>
// Abstract Database class
abstract class Database {
    // Regular property
    protected $connection;
    protected $host;
    protected $username;
    protected $password;
    
    // Constructor (concrete method)
    public function __construct($host, $username, $password) {
        $this->host = $host;
        $this->username = $username;
        $this->password = $password;
    }
    
    // Concrete method with implementation
    public function connect() {
        echo "Establishing connection to database...";
        // Common connection logic here
    }
    
    // Concrete method with implementation
    public function disconnect() {
        echo "Disconnecting from database...";
        $this->connection = null;
    }
    
    // Abstract methods (no implementation)
    abstract public function query($sql);
    abstract public function getLastError();
}

// Concrete MySQL implementation
class MySQLDatabase extends Database {
    // Implementation of abstract methods
    public function query($sql) {
        return "MySQL executing query: {$sql}";
    }
    
    public function getLastError() {
        return "MySQL error: " . mysqli_error($this->connection);
    }
    
    // Can add additional methods specific to MySQL
    public function useDatabase($dbName) {
        return "MySQL selecting database: {$dbName}";
    }
}

// Concrete PostgreSQL implementation
class PostgreSQLDatabase extends Database {
    // Implementation of abstract methods
    public function query($sql) {
        return "PostgreSQL executing query: {$sql}";
    }
    
    public function getLastError() {
        return "PostgreSQL error: " . pg_last_error($this->connection);
    }
}

// This would cause an error - cannot instantiate abstract class
// $db = new Database("localhost", "user", "pass");

// These work fine
$mysql = new MySQLDatabase("localhost", "root", "password");
$postgres = new PostgreSQLDatabase("localhost", "postgres", "password");

echo $mysql->query("SELECT * FROM users");
echo $postgres->query("SELECT * FROM users");
                </code></pre>
            </div>
            
            <h3>When to Use Abstract Classes</h3>
            
            <ul>
                <li>When you want to provide a common base implementation with some required methods</li>
                <li>When you have multiple related classes that share common behavior</li>
                <li>When you want to enforce a certain structure on child classes</li>
                <li>When you need constructor logic in the parent class</li>
            </ul>
            
            <h3>Real-World Example: WordPress Customizer</h3>
            
            <p>WordPress uses abstract classes for its Customizer framework, where different control types share common functionality but require specific implementations:</p>
            
            <div class="code-example">
                <h4>Simplified WordPress Customizer Example</h4>
                <pre><code>
// Abstract base control class
abstract class WP_Customize_Control {
    protected $id;
    protected $label;
    protected $setting;
    
    public function __construct($id, $label, $setting) {
        $this->id = $id;
        $this->label = $label;
        $this->setting = $setting;
    }
    
    // Common method for all controls
    public function get_link() {
        return "data-customize-setting-link='{$this->setting}'";
    }
    
    // Abstract method that each control type must implement
    abstract public function render_content();
}

// Text control implementation
class WP_Customize_Text_Control extends WP_Customize_Control {
    public function render_content() {
        echo "&lt;label for='{$this->id}'&gt;{$this->label}&lt;/label&gt;";
        echo "&lt;input type='text' id='{$this->id}' {$this->get_link()} /&gt;";
    }
}

// Color control implementation
class WP_Customize_Color_Control extends WP_Customize_Control {
    public function render_content() {
        echo "&lt;label for='{$this->id}'&gt;{$this->label}&lt;/label&gt;";
        echo "&lt;input type='color' id='{$this->id}' {$this->get_link()} /&gt;";
    }
}
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h4>Abstract Classes vs. Interfaces</h4>
                <p>People often confuse abstract classes with interfaces. Here's the key difference:</p>
                <ul>
                    <li><strong>Abstract Class:</strong> "Is a partial implementation" - can contain both concrete and abstract methods, and can have properties</li>
                    <li><strong>Interface:</strong> "Is a contract only" - can only contain method signatures, no implementation, no properties</li>
                </ul>
                <p>Use abstract classes when child classes share common functionality. Use interfaces when you need multiple unrelated classes to implement the same contract.</p>
            </div>
        </section>

        <section id="interfaces">
            <h2>Interfaces: Contracts for Classes</h2>
            
            <p>Interfaces are contracts that specify what methods a class must implement, without specifying how those methods should be implemented. Think of interfaces as a job description listing required skills, while the employee (implementing class) decides how to apply those skills.</p>
            
            <div class="diagram">
                <h3>Interface Implementation</h3>
                <div class="mermaid">
                    classDiagram
                      class Loggable {
                        <<interface>>
                        +log(message)
                        +getLogHistory()
                      }
                      class FileSystem {
                        <<interface>>
                        +read(path)
                        +write(path, content)
                        +delete(path)
                      }
                      class FileLogger {
                        -logFile
                        +log(message)
                        +getLogHistory()
                      }
                      class DatabaseLogger {
                        -dbConnection
                        +log(message)
                        +getLogHistory()
                      }
                      class LocalFileSystem {
                        +read(path)
                        +write(path, content)
                        +delete(path)
                      }
                      Loggable <|.. FileLogger
                      Loggable <|.. DatabaseLogger
                      FileSystem <|.. LocalFileSystem
                </div>
            </div>
            
            <h3>Key Features of Interfaces</h3>
            
            <ul>
                <li>Define a contract with method signatures only (no implementation)</li>
                <li>Cannot contain properties (only constants)</li>
                <li>All methods must be public</li>
                <li>A class can implement multiple interfaces</li>
                <li>Cannot be instantiated directly</li>
                <li>Since PHP 8.0, interfaces can define constants</li>
            </ul>
            
            <div class="code-example">
                <h4>Interface Example</h4>
                <pre><code>
// Define a Loggable interface
interface Loggable {
    // Constants in interfaces (PHP 8.0+)
    const LOG_LEVEL_INFO = 'info';
    const LOG_LEVEL_WARNING = 'warning';
    const LOG_LEVEL_ERROR = 'error';
    
    // Method signatures (no implementation)
    public function log($message, $level = self::LOG_LEVEL_INFO);
    public function getLogHistory();
}

// Define a FileSystem interface
interface FileSystem {
    public function read($path);
    public function write($path, $content);
    public function delete($path);
}

// Class implementing a single interface
class FileLogger implements Loggable {
    private $logFile;
    private $logHistory = [];
    
    public function __construct($logFile) {
        $this->logFile = $logFile;
    }
    
    public function log($message, $level = self::LOG_LEVEL_INFO) {
        $logEntry = date('Y-m-d H:i:s') . " [{$level}] {$message}";
        $this->logHistory[] = $logEntry;
        file_put_contents($this->logFile, $logEntry . PHP_EOL, FILE_APPEND);
    }
    
    public function getLogHistory() {
        return $this->logHistory;
    }
}

// Class implementing multiple interfaces
class Cloud implements FileSystem, Loggable {
    private $logHistory = [];
    private $storage = [];
    
    // FileSystem interface implementation
    public function read($path) {
        if (isset($this->storage[$path])) {
            $this->log("Reading file: {$path}");
            return $this->storage[$path];
        }
        return null;
    }
    
    public function write($path, $content) {
        $this->storage[$path] = $content;
        $this->log("Writing to file: {$path}");
        return true;
    }
    
    public function delete($path) {
        if (isset($this->storage[$path])) {
            unset($this->storage[$path]);
            $this->log("Deleted file: {$path}", self::LOG_LEVEL_WARNING);
            return true;
        }
        return false;
    }
    
    // Loggable interface implementation
    public function log($message, $level = self::LOG_LEVEL_INFO) {
        $logEntry = date('Y-m-d H:i:s') . " [{$level}] {$message}";
        $this->logHistory[] = $logEntry;
    }
    
    public function getLogHistory() {
        return $this->logHistory;
    }
}

// Usage
$fileLogger = new FileLogger('/path/to/log.txt');
$fileLogger->log("User logged in", Loggable::LOG_LEVEL_INFO);

$cloud = new Cloud();
$cloud->write('/documents/resume.docx', 'My Resume Content');
$cloud->read('/documents/resume.docx');
$cloud->delete('/documents/resume.docx');

// Check if instance implements an interface
if ($cloud instanceof Loggable) {
    echo "Cloud supports logging functionality";
}

// Type hinting with interfaces
function processLogs(Loggable $logger) {
    $logs = $logger->getLogHistory();
    // Process logs...
}

processLogs($fileLogger); // Works
processLogs($cloud); // Also works
                </code></pre>
            </div>
            
            <h3>Real-World Example: WordPress Hooks System</h3>
            
            <p>WordPress uses interfaces to define contracts for objects that need to interact with its hooks system:</p>
            
            <div class="code-example">
                <h4>Simplified WordPress Hook Example</h4>
                <pre><code>
// Interface for hook providers
interface Hook_Provider {
    public function register_hooks();
}

// Custom theme features as a hook provider
class Theme_Features implements Hook_Provider {
    public function register_hooks() {
        // Register theme features when WordPress initializes
        add_action('after_setup_theme', [$this, 'setup_theme_features']);
    }
    
    public function setup_theme_features() {
        // Add theme support for various features
        add_theme_support('post-thumbnails');
        add_theme_support('custom-logo');
        add_theme_support('automatic-feed-links');
    }
}

// Custom admin modifications as a hook provider
class Admin_Customizations implements Hook_Provider {
    public function register_hooks() {
        // Register admin customizations
        add_action('admin_menu', [$this, 'customize_admin_menu']);
        add_action('admin_footer_text', [$this, 'custom_admin_footer']);
    }
    
    public function customize_admin_menu() {
        // Remove unnecessary menu items
        remove_menu_page('tools.php');
    }
    
    public function custom_admin_footer() {
        echo 'Thank you for creating with our WordPress theme';
    }
}

// Bootstrap class to initialize all hook providers
class Theme_Bootstrap {
    private $providers = [];
    
    public function register_provider(Hook_Provider $provider) {
        $this->providers[] = $provider;
    }
    
    public function initialize() {
        foreach ($this->providers as $provider) {
            $provider->register_hooks();
        }
    }
}

// Usage
$bootstrap = new Theme_Bootstrap();
$bootstrap->register_provider(new Theme_Features());
$bootstrap->register_provider(new Admin_Customizations());
$bootstrap->initialize();
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h4>When to Use Interfaces</h4>
                <ul>
                    <li>When you need multiple unrelated classes to follow the same contract</li>
                    <li>When you want to achieve multiple inheritance-like functionality</li>
                    <li>When you need to define a contract without implementation details</li>
                    <li>When you want to type-hint in method parameters or return types</li>
                    <li>When you're creating a plugin or framework that others will extend</li>
                </ul>
            </div>
        </section>

        <section id="namespaces">
            <h2>Namespaces: Organizing Your Code</h2>
            
            <p>Namespaces are like zip codes or neighborhoods in a city - they help organize and group related classes, functions, and constants to prevent naming conflicts. Think of namespaces as organizing your code into different folders.</p>
            
            <div class="diagram">
                <h3>Namespace Organization</h3>
                <div class="mermaid">
                    graph TD
                        Root[PHP Application]
                        App[App Namespace]
                        Controllers[App\Controllers]
                        Models[App\Models]
                        Utils[App\Utils]
                        Payments[App\Payments]
                        PayPal[App\Payments\PayPal]
                        Stripe[App\Payments\Stripe]
                        
                        Root --> App
                        App --> Controllers
                        App --> Models
                        App --> Utils
                        App --> Payments
                        Payments --> PayPal
                        Payments --> Stripe
                </div>
            </div>
            
            <h3>Key Features of Namespaces</h3>
            
            <ul>
                <li>Help avoid name collisions between classes, functions, and constants</li>
                <li>Allow for better organization of code in larger applications</li>
                <li>Support sub-namespaces using the backslash (\) character</li>
                <li>Include mechanism for importing namespaces with <code>use</code> statements</li>
                <li>Can be aliased using the <code>as</code> keyword</li>
            </ul>
            
            <div class="code-example">
                <h4>Namespace Examples</h4>
                <pre><code>
// File: app/Models/User.php
namespace App\Models;

class User {
    private $username;
    private $email;
    
    public function __construct($username, $email) {
        $this->username = $username;
        $this->email = $email;
    }
    
    public function getProfile() {
        return [
            'username' => $this->username,
            'email' => $this->email
        ];
    }
}

// File: app/Controllers/UserController.php
namespace App\Controllers;

// Import the User class from Models namespace
use App\Models\User;
// Import with an alias
use App\Services\UserService as UserSrv;

class UserController {
    public function register($username, $email) {
        // Create a new user
        $user = new User($username, $email);
        
        // Use an aliased class
        $service = new UserSrv();
        $service->saveUser($user);
        
        // Use a fully qualified name without importing
        $validator = new \App\Validation\UserValidator();
        $validator->validate($user);
        
        return $user->getProfile();
    }
}

// File: index.php
// Use classes from namespaces
require_once 'autoload.php';

use App\Controllers\UserController;

$controller = new UserController();
$profile = $controller->register('johndoe', 'john@example.com');
var_dump($profile);
                </code></pre>
            </div>
            
            <h3>Global Namespace and Special Namespace Keywords</h3>
            
            <ul>
                <li><code>\</code> (leading backslash) - References the global namespace</li>
                <li><code>namespace</code> keyword - Used to define a namespace</li>
                <li><code>use</code> keyword - Imports a namespace</li>
                <li><code>as</code> keyword - Creates an alias for an imported namespace</li>
            </ul>
            
            <div class="code-example">
                <h4>Special Namespace Features</h4>
                <pre><code>
namespace App\Services;

// Import multiple classes from the same namespace
use App\Models\{User, Profile, Subscription};

// Import a global class (like PHP's DateTime)
use \DateTime;

// Import with an alias to avoid naming conflicts
use App\Utilities\Logger as AppLogger;
use External\Logger as ExternalLogger;

class UserService {
    public function createUser() {
        // Using an imported class
        $user = new User();
        
        // Using a global namespace function
        $serialized = \json_encode($user);
        
        // Using a class from the current namespace
        $helper = new UserHelper();
        
        // Using aliased classes
        $logger1 = new AppLogger();
        $logger2 = new ExternalLogger();
        
        // Using an absolute path without importing
        $validator = new \App\Validation\UserValidator();
    }
}
                </code></pre>
            </div>
            
            <h3>Real-World Example: WordPress Plugin Organization</h3>
            
            <p>Modern WordPress plugins use namespaces to organize their code and prevent conflicts with other plugins:</p>
            
            <div class="code-example">
                <h4>WordPress Plugin Namespace Example</h4>
                <pre><code>
// File: my-plugin/src/Admin/Settings.php
namespace MyPlugin\Admin;

class Settings {
    public function register_hooks() {
        add_action('admin_menu', [$this, 'add_settings_page']);
    }
    
    public function add_settings_page() {
        add_menu_page(
            'My Plugin Settings',
            'My Plugin',
            'manage_options',
            'my-plugin-settings',
            [$this, 'render_settings_page']
        );
    }
    
    public function render_settings_page() {
        // Settings page HTML
    }
}

// File: my-plugin/src/Frontend/Shortcodes.php
namespace MyPlugin\Frontend;

class Shortcodes {
    public function register_hooks() {
        add_shortcode('my_plugin', [$this, 'render_shortcode']);
    }
    
    public function render_shortcode($atts, $content = null) {
        // Shortcode rendering logic
    }
}

// File: my-plugin/my-plugin.php (main plugin file)
// Bootstrap code
require_once 'vendor/autoload.php';

use MyPlugin\Admin\Settings;
use MyPlugin\Frontend\Shortcodes;

// Initialize plugin components
function initialize_plugin() {
    $settings = new Settings();
    $settings->register_hooks();
    
    $shortcodes = new Shortcodes();
    $shortcodes->register_hooks();
}

// Hook into WordPress
add_action('plugins_loaded', 'initialize_plugin');
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h4>Namespace Best Practices</h4>
                <ul>
                    <li>Follow PSR-4 autoloading standards where namespace structure mirrors directory structure</li>
                    <li>Use vendor names for plugins and themes (e.g., <code>YourCompany\PluginName</code>)</li>
                    <li>Group related functionality in sub-namespaces (Admin, Frontend, API, etc.)</li>
                    <li>Import only the classes you need, not entire namespaces</li>
                    <li>Consider using Composer's autoloader for automatic class loading</li>
                </ul>
            </div>
        </section>

        <section id="traits">
            <h2>Traits: Reusable Code Snippets</h2>
            
            <p>Traits are a mechanism for code reuse in single inheritance languages like PHP. Think of traits as mix-ins or building blocks that you can use to add functionality to classes without inheritance. Like recipe components you can mix and match to create different dishes.</p>
            
            <div class="diagram">
                <h3>Traits in Action</h3>
                <div class="mermaid">
                    classDiagram
                      class LoggableTrait {
                        <<trait>>
                        -logFile
                        +log(message)
                        +getLogHistory()
                      }
                      class SingletonTrait {
                        <<trait>>
                        -static instance
                        +static getInstance()
                      }
                      class UserRepository {
                        -users
                        +findById(id)
                        +save(user)
                      }
                      class ConfigManager {
                        -settings
                        +get(key)
                        +set(key, value)
                      }
                      LoggableTrait -- UserRepository : uses
                      SingletonTrait -- ConfigManager : uses
                      LoggableTrait -- ConfigManager : uses
                </div>
            </div>
            
            <h3>Key Features of Traits</h3>
            
            <ul>
                <li>Allows horizontal code reuse (sharing code between unrelated classes)</li>
                <li>Can contain properties, methods, and abstract methods</li>
                <li>Cannot be instantiated on their own</li>
                <li>A class can use multiple traits</li>
                <li>Supports method precedence rules to resolve conflicts</li>
                <li>Can declare abstract methods that using classes must implement</li>
            </ul>
            
            <div class="code-example">
                <h4>Trait Example</h4>
                <pre><code>
// Define a Loggable trait
trait Loggable {
    // Properties in traits
    private $logHistory = [];
    
    // Methods in traits
    public function log($message) {
        $logEntry = date('Y-m-d H:i:s') . ": {$message}";
        $this->logHistory[] = $logEntry;
        
        // Check if class has a custom logging method
        if (method_exists($this, 'customLog')) {
            $this->customLog($logEntry);
        }
    }
    
    public function getLogHistory() {
        return $this->logHistory;
    }
    
    // Abstract method that must be implemented by using class
    abstract protected function getLogIdentifier();
}

// Define a Singleton trait
trait Singleton {
    private static $instance;
    
    // Private constructor to prevent direct instantiation
    private function __construct() {
        // Initialization code
    }
    
    public static function getInstance() {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }
}

// Class using a single trait
class UserRepository {
    use Loggable;
    
    private $users = [];
    
    public function findById($id) {
        $this->log("Looking for user with ID: {$id}");
        
        return isset($this->users[$id]) ? $this->users[$id] : null;
    }
    
    public function save($user) {
        $id = $user['id'] ?? uniqid();
        $this->users[$id] = $user;
        $this->log("Saved user with ID: {$id}");
        
        return $id;
    }
    
    // Implement abstract method from trait
    protected function getLogIdentifier() {
        return 'UserRepository';
    }
}

// Class using multiple traits
class ConfigManager {
    // Use multiple traits
    use Singleton, Loggable {
        // Resolve conflicts or customize trait methods
        Loggable::log insteadof Singleton; // If both traits had log method
        Loggable::log as logMessage; // Create alias for method
    }
    
    private $settings = [];
    
    public function get($key) {
        $this->log("Getting config value for: {$key}");
        return $this->settings[$key] ?? null;
    }
    
    public function set($key, $value) {
        $this->settings[$key] = $value;
        $this->log("Setting config value for: {$key}");
    }
    
    // Custom method that trait will use
    protected function customLog($logEntry) {
        // Store logs in a file
        file_put_contents('config.log', $logEntry . PHP_EOL, FILE_APPEND);
    }
    
    // Implement abstract method from trait
    protected function getLogIdentifier() {
        return 'ConfigManager';
    }
}

// Usage
$userRepo = new UserRepository();
$userRepo->save(['name' => 'John', 'email' => 'john@example.com']);
print_r($userRepo->getLogHistory());

// Singleton usage
$config = ConfigManager::getInstance();
$config->set('app_name', 'My PHP App');
echo $config->get('app_name');
print_r($config->getLogHistory());
                </code></pre>
            </div>
            
            <h3>Trait Conflict Resolution</h3>
            
            <p>When a class uses multiple traits with the same method names, PHP provides mechanisms to resolve these conflicts:</p>
            
            <div class="code-example">
                <h4>Trait Conflict Resolution Example</h4>
                <pre><code>
trait Logger {
    public function log($message) {
        echo "Logger: {$message}";
    }
}

trait Debugger {
    public function log($message) {
        echo "Debugger: {$message}";
    }
    
    public function debug($message) {
        echo "Debug: {$message}";
    }
}

class Application {
    // Use both traits but resolve the conflict
    use Logger, Debugger {
        // Prefer Logger's log method over Debugger's
        Logger::log insteadof Debugger;
        
        // Create an alias for Debugger's log method
        Debugger::log as debugLog;
    }
    
    public function process() {
        $this->log("Processing application"); // Uses Logger::log
        $this->debugLog("Processing details"); // Uses Debugger::log
        $this->debug("Processing complete"); // Uses Debugger::debug
    }
}
                </code></pre>
            </div>
            
            <h3>Real-World Example: WordPress WP_REST_Controller</h3>
            
            <p>WordPress uses traits in its REST API framework to share functionality between controller classes:</p>
            
            <div class="code-example">
                <h4>Simplified WordPress REST API Trait Example</h4>
                <pre><code>
// Simplified version of a WordPress REST API trait
trait REST_API_Validation {
    // Validate common parameters
    protected function validate_request_param($param, $request, $key) {
        $value = $request->get_param($key);
        
        if (null === $value) {
            return new WP_Error(
                'rest_missing_callback_param',
                sprintf('Missing parameter: %s', $key),
                ['status' => 400]
            );
        }
        
        return true;
    }
    
    // Sanitize common parameters
    protected function sanitize_request_param($param, $request, $key) {
        $value = $request->get_param($key);
        
        switch ($param['type']) {
            case 'string':
                return sanitize_text_field($value);
            case 'integer':
                return (int) $value;
            case 'boolean':
                return (bool) $value;
            default:
                return $value;
        }
    }
}

// REST API controller using the trait
class Product_REST_Controller {
    use REST_API_Validation;
    
    public function register_routes() {
        register_rest_route('wc/v3', '/products', [
            'methods' => 'GET',
            'callback' => [$this, 'get_items'],
            'permission_callback' => [$this, 'get_items_permissions_check'],
        ]);
    }
    
    public function get_items($request) {
        // Use methods from the trait for validation
        $validation = $this->validate_request_param([
            'type' => 'integer',
            'required' => true,
        ], $request, 'per_page');
        
        if (is_wp_error($validation)) {
            return $validation;
        }
        
        $per_page = $this->sanitize_request_param([
            'type' => 'integer',
        ], $request, 'per_page');
        
        // Rest of the controller logic
    }
}
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h4>When to Use Traits</h4>
                <ul>
                    <li>When you need to share functionality between unrelated classes</li>
                    <li>When you want to avoid deep inheritance hierarchies</li>
                    <li>For cross-cutting concerns like logging, caching, or validation</li>
                    <li>When you need multiple inheritance-like behavior</li>
                    <li>For utility methods that don't justify a base class</li>
                </ul>
                <p><strong>Warning:</strong> Overuse of traits can lead to "trait soup" and make code harder to understand and maintain. Use traits for well-defined, focused functionality.</p>
            </div>
        </section>

        <section id="homework">
            <h2>Homework: Extend Your Previous Class with Inheritance</h2>
            
            <p>For this assignment, you'll take the simple class you created in the previous homework and extend it using inheritance and the other OOP concepts we've covered.</p>
            
            <div class="assignment">
                <h3>Assignment Overview</h3>
                <p>Create a small application that demonstrates inheritance, method overriding, abstract classes, interfaces, and traits. The application will be a simple product management system.</p>
                
                <h4>Requirements</h4>
                <ol>
                    <li>Create an abstract <code>Product</code> base class with:
                        <ul>
                            <li>Properties for name, price, and SKU</li>
                            <li>A constructor that sets these properties</li>
                            <li>Getters and setters for each property</li>
                            <li>A concrete <code>getInfo()</code> method that returns basic product information</li>
                            <li>An abstract <code>calculateTax()</code> method</li>
                        </ul>
                    </li>
                    <li>Create at least two child classes (e.g., <code>PhysicalProduct</code> and <code>DigitalProduct</code>) that extend the <code>Product</code> class:
                        <ul>
                            <li>Each should implement the abstract <code>calculateTax()</code> method differently</li>
                            <li>Each should override the <code>getInfo()</code> method to include child-specific information</li>
                            <li>Each should have at least one unique property and method</li>
                        </ul>
                    </li>
                    <li>Create an interface <code>Discountable</code> with methods:
                        <ul>
                            <li><code>applyDiscount($percentage)</code></li>
                            <li><code>hasActiveDiscount()</code></li>
                        </ul>
                    </li>
                    <li>Create a trait <code>Loggable</code> with methods:
                        <ul>
                            <li><code>log($message)</code></li>
                            <li><code>getLogHistory()</code></li>
                        </ul>
                    </li>
                    <li>Have at least one of your product classes implement the <code>Discountable</code> interface</li>
                    <li>Apply the <code>Loggable</code> trait to your product classes</li>
                    <li>Use namespaces to organize your code:
                        <ul>
                            <li>Place abstract classes in <code>App\Abstracts</code></li>
                            <li>Place interfaces in <code>App\Interfaces</code></li>
                            <li>Place traits in <code>App\Traits</code></li>
                            <li>Place concrete classes in <code>App\Products</code></li>
                        </ul>
                    </li>
                    <li>Create a simple index.php file that demonstrates all of these concepts working together</li>
                </ol>
                
                <h4>Starter Code</h4>
                <pre><code>
// Abstract Product class
abstract class Product {
    protected $name;
    protected $price;
    protected $sku;
    
    public function __construct($name, $price, $sku) {
        $this->name = $name;
        $this->price = $price;
        $this->sku = $sku;
    }
    
    // Getters and setters
    public function getName() {
        return $this->name;
    }
    
    public function setName($name) {
        $this->name = $name;
    }
    
    // Add remaining getters/setters
    
    public function getInfo() {
        return "Product: {$this->name}, Price: \${$this->price}, SKU: {$this->sku}";
    }
    
    // Abstract method
    abstract public function calculateTax();
}

// Now complete the exercise by implementing the remaining classes,
// interfaces, and traits according to the requirements...
                </code></pre>
                
                <h4>Bonus Challenges</h4>
                <ul>
                    <li>Create a <code>ProductRepository</code> class that uses the Singleton pattern (via a trait)</li>
                    <li>Add a <code>Searchable</code> interface and implement it in your product classes</li>
                    <li>Create a product factory to instantiate different types of products</li>
                    <li>Add unit tests for your classes using PHPUnit</li>
                </ul>
            </div>
        </section>

        <section class="summary">
            <h2>Key Takeaways</h2>
            
            <div class="takeaways">
                <div class="takeaway">
                    <h3>Inheritance</h3>
                    <p>Allows classes to inherit properties and methods from parent classes, creating a hierarchy of "is-a" relationships.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Method Overriding</h3>
                    <p>Enables child classes to provide specific implementations of methods defined in parent classes.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Abstract Classes</h3>
                    <p>Create partially implemented blueprints that define a common structure for related classes.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Interfaces</h3>
                    <p>Define contracts that classes must follow, enforcing consistent method signatures across unrelated classes.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Namespaces</h3>
                    <p>Organize and group related code to prevent naming conflicts and improve maintainability.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Traits</h3>
                    <p>Enable horizontal code reuse by injecting functionality into classes without using inheritance.</p>
                </div>
            </div>
            
            <div class="next-steps">
                <h3>Next Steps</h3>
                <p>Now that you understand these advanced OOP concepts, you'll be able to create more maintainable, flexible, and professional PHP applications. In the upcoming sessions, we'll continue building on these concepts as we dive into database integration and begin working with WordPress.</p>
            </div>
        </section>

        <section class="resources">
            <h2>Additional Resources</h2>
            
            <ul>
                <li><a href="https://www.php.net/manual/en/language.oop5.php" target="_blank">PHP Official Documentation on OOP</a></li>
                <li><a href="https://phptherightway.com/#object-oriented-programming" target="_blank">PHP The Right Way - OOP Best Practices</a></li>
                <li><a href="https://developer.wordpress.org/plugins/intro/" target="_blank">WordPress Plugin Developer Handbook</a></li>
                <li><a href="https://developer.wordpress.org/themes/basics/incorporating-the-theme-options-page/" target="_blank">WordPress Theme Developer Handbook</a></li>
            </ul>
        </section>
    </main>
    
    <footer>
        <p>&copy; 2025 PHP WordPress Development Course</p>
        <p><a href="module2.html">Back to Module 2 Overview</a> | <a href="index.html">Back to Syllabus</a></p>
    </footer>
</body>
</html>
