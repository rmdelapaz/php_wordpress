<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="ie=edge" http-equiv="X-UA-Compatible"/>
<!-- SEO Meta Tags -->
<title>Interfaces in PHP: Building Flexible Contracts - PHP WordPress Course</title>
<meta content="Welcome to our exploration of interfaces in PHP! In our previous lessons, we've covered classes, inheritance, and abstract classes. Today, we'll be diving into " name="description"/>
<meta content="PHP, WordPress, web development, php, interfaces" name="keywords"/>
<meta content="PHP WordPress Course" name="author"/>
<!-- Favicon -->
<link href="/favicon.png" rel="icon" type="image/png"/>
<link href="/favicon.png" rel="apple-touch-icon"/>
<!-- CSS -->
<link href="/assets/css/main.css" rel="stylesheet"/><link href="/assets/css/sidebar-enhanced.css" rel="stylesheet"/><link href="/assets/css/sidebar-toggle.css" rel="stylesheet"/>

<style>
/* Global diagram and SVG styles */
.mermaid-converted,
.svg-container,
.diagram {
    margin: 1.5rem auto !important;
    padding: 1rem !important;
    text-align: center !important;
    overflow: hidden !important;
    max-width: 100% !important;
    background: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #dee2e6;
}

.mermaid-converted svg,
.svg-container svg,
.diagram svg {
    max-width: 100% !important;
    height: auto !important;
    display: block !important;
    margin: 0 auto !important;
}

/* Fix for decision diamonds */
.decision-node polygon,
polygon.decision {
    fill: #fff3cd !important;
    stroke: #856404 !important;
    stroke-width: 2px !important;
}

/* Remove excessive bottom margins */
.mermaid-converted + *,
.svg-container + *,
.diagram + * {
    margin-top: 1.5rem !important;
}

/* Center content vertically in containers */
.mermaid-converted > *,
.svg-container > *,
.diagram > * {
    vertical-align: middle;
}
</style>


<style>
/* Mermaid Diagram Specific Styles */
.mermaid-converted,
.mermaid,
.mermaid-container,
.mermaid-diagram {
    margin: 1.5rem auto 0 !important;
    margin-bottom: 0 !important;
    padding: 1rem !important;
    text-align: center !important;
    overflow: visible !important;
    max-width: 100% !important;
    background: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #dee2e6;
    box-sizing: border-box;
}

/* Ensure next element doesn't have excessive top margin */
.mermaid-converted + *,
.mermaid + *,
.mermaid-container + *,
.mermaid-diagram + * {
    margin-top: 1.5rem !important;
}

/* SVG within Mermaid containers */
.mermaid-converted svg,
.mermaid svg,
.mermaid-container svg,
.mermaid-diagram svg {
    max-width: 100% !important;
    height: auto !important;
    display: block !important;
    margin: 0 auto !important;
    overflow: visible !important;
}

/* Standardized decision diamonds */
polygon.decision,
.decision-node polygon,
polygon[class*="decision"] {
    fill: #fff3cd !important;
    stroke: #856404 !important;
    stroke-width: 2px !important;
}

/* Prevent text overlap */
text {
    pointer-events: none;
    z-index: 1000;
}

/* Fix for overlapping elements */
rect, circle, polygon, ellipse {
    pointer-events: all;
}

/* Remove any default margins that might cause issues */
.mermaid-converted > :last-child,
.mermaid > :last-child,
.mermaid-container > :last-child,
.mermaid-diagram > :last-child {
    margin-bottom: 0 !important;
}

/* Ensure proper spacing between consecutive diagrams */
.mermaid-converted + .mermaid-converted,
.mermaid + .mermaid,
.mermaid-container + .mermaid-container,
.mermaid-diagram + .mermaid-diagram {
    margin-top: 2rem !important;
}
</style>

</head>
<body>
<!-- Skip to main content -->
<a class="sr-only" href="#main-content">Skip to main content</a>
<div class="page-wrapper">
<!-- Header -->
<header class="site-header" role="banner">
<div class="header-container">
<div class="site-branding">
<a class="site-logo" href="/">
<h1 class="site-title">PHP WordPress Development</h1>
</a>
</div>
<nav aria-label="Main navigation" class="main-navigation" role="navigation">
<button aria-expanded="false" aria-label="Toggle navigation" class="mobile-menu-btn">
<span></span>
<span></span>
<span></span>
</button>
<div class="nav-menu">
<ul class="nav-list">
<li class="nav-item"><a class="nav-link" href="/">Home</a></li>
<li class="nav-item dropdown">
<button aria-haspopup="true" class="nav-link dropdown-toggle active">Modules</button>
<div class="dropdown-menu">
<a class="dropdown-item" href="/module1.html">Module 1: Web Fundamentals</a>
<a class="dropdown-item active" href="/module2.html">Module 2: PHP Fundamentals</a>
<a class="dropdown-item" href="/module3.html">Module 3: MySQL Database</a>
<a class="dropdown-item" href="/module4.html">Module 4: WordPress &amp; Docker</a>
<a class="dropdown-item" href="/module5.html">Module 5: Theme Development</a>
<a class="dropdown-item" href="/module6.html">Module 6: Plugin Development</a>
<a class="dropdown-item" href="/module7.html">Module 7: Advanced WordPress</a>
<a class="dropdown-item" href="/module8.html">Module 8: Deployment</a>
<a class="dropdown-item" href="/module9.html">Module 9: Final Project</a>
</div>
</li>
<li class="nav-item"><a class="nav-link" href="/resources.html">Resources</a></li>
<li class="nav-item"><a class="nav-link" href="/about.html">About</a></li>
</ul>
</div>
</nav>
<div class="search-container">
<div class="search-input-wrapper">
<svg class="search-icon" fill="currentColor" height="20" viewbox="0 0 20 20" width="20" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" viewBox="0 0 20 20">
<path clip-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" fill-rule="evenodd"></path>
</svg>
<input aria-label="Search" class="search-input" placeholder="Search lessons..." type="search"/>
</div>
<div class="search-results"></div>
</div>
</div>
</header>
<!-- Progress Bar -->
<div class="progress-container">
<div class="progress-header">
<h2 class="progress-title">Course Progress</h2>
<span class="progress-text">Loading...</span>
</div>
<div class="progress-bar">
<div class="progress-bar-fill">
<span class="progress-bar-text"></span>
</div>
</div>
</div>
<!-- Breadcrumb -->
<nav aria-label="Breadcrumb" class="breadcrumb container">
<ol class="breadcrumb-list">
<li class="breadcrumb-item">
<a href="/">Home</a>
<span class="breadcrumb-separator">/</span>
</li>
<li class="breadcrumb-item">
<a href="/module2.html">Module 2</a>
<span class="breadcrumb-separator">/</span>
</li>
<li class="breadcrumb-item">
<span aria-current="page">PHP Interfaces</span>
</li>
</ol>
</nav>
<!-- Main Content -->
<main class="main-content" id="main-content" role="main">
<div class="container">
<div class="content-with-sidebar">
<!-- Sidebar -->
<aside class="sidebar">

<div class="sidebar-nav">
<h3 class="sidebar-title">Module 2: PHP Fundamentals</h3>
<div class="sidebar-section">
<h4 class="sidebar-section-title">Session 9</h4>
<ul class="sidebar-menu">
<li><a class="sidebar-link" href="/02module/php_inheritance.html">Inheritance</a></li>
<li><a class="sidebar-link" href="/02module/php_method_overriding.html">Method Overriding</a></li>
<li><a class="sidebar-link" href="/02module/php_abstract_classes.html">Abstract Classes</a></li>
<li class="active"><a class="sidebar-link active" href="/02module/php_interfaces.html">Interfaces</a></li>
<li><a class="sidebar-link" href="/02module/php_namespaces.html">Namespaces</a></li>
<li><a class="sidebar-link" href="/02module/php_traits.html">Traits</a></li>
<li><a class="sidebar-link" href="/02module/homework_php_extend_with_inheritance.html">Homework: Inheritance</a></li>
</ul>
</div>
<div class="sidebar-section">
<h4 class="sidebar-section-title">Quick Links</h4>
<ul class="sidebar-menu">
<li><a class="sidebar-link" href="/module2.html">Module Overview</a></li>
<li><a class="sidebar-link prev-session" href="/02module/php_oop_concepts.html">← Prev: Session 8: OOP Intro</a></li>
<li><a class="sidebar-link next-session" href="/02module/php_planning_php_application.html">Next: Session 10: Project →</a></li>
<li><a class="sidebar-link" href="/module1.html">← Previous Module</a></li>
<li><a class="sidebar-link" href="/module3.html">Next Module →</a></li>
<li><a class="sidebar-link" href="/resources.html">Resources</a></li>
</ul>
</div>
</div></aside>
<!-- Main Lesson Content -->
<article class="lesson-content">
<header class="lesson-header">
<h1>Interfaces in PHP: Building Flexible Contracts</h1>
<div class="lesson-meta">
<div class="lesson-meta-item">
<svg fill="currentColor" height="20" width="20" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" viewBox="0 0 20 20">
<path d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<span>Duration: 45 minutes</span>
</div>
<div class="lesson-meta-item">
<svg fill="currentColor" height="20" width="20" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" viewBox="0 0 20 20">
<path d="M12 14l9-5-9-5-9 5 9 5z"></path>
</svg>
<span>Module 2: Object-Oriented PHP</span>
</div>
</div>
</header>
<!-- Learning Objectives -->
<div class="lesson-objectives">
<h2>Learning Objectives</h2>
<ul>
<li>Master PHP programming concepts</li>
<li>Write clean, maintainable code</li>
<li>Apply best practices</li>
<li>Build dynamic applications</li>
</ul>
</div>
<!-- Lesson Body -->
<div class="lesson-body">
<section class="module-intro">
            <h2>Understanding Contracts in Code</h2>
            <p>Welcome to our exploration of interfaces in PHP! In our previous lessons, we've covered classes, inheritance, and abstract classes. Today, we'll be diving into interfaces - one of the most powerful tools in object-oriented programming for creating flexible, maintainable systems.</p>
            
            <div class="note">
                <p><strong>Why Interfaces Matter:</strong> In WordPress development, interfaces form the backbone of plugin systems, hook implementations, and API integrations. Understanding interfaces will dramatically improve your ability to create extensible plugins and themes that other developers can easily build upon.</p>
            </div>
        </section>

        <section id="interface-basics">
            <h2>What Are Interfaces?</h2>
            
            <p>Think of an interface as a contract or a promise. When a class implements an interface, it's making a promise to provide specific functionality. It's like a restaurant signing up for a food delivery service - the restaurant promises to prepare food according to certain standards, while the delivery service handles getting it to customers.</p>
            
            <div class="diagram" style="margin: 1.5rem auto; padding: 1rem; text-align: center; overflow: hidden; max-width: 100%;">
<h3>Interface Relationship</h3>
                
<div class="mermaid-converted" style="margin: 1.5rem auto 0; padding: 1rem; text-align: center; overflow: visible; max-width: 100%; min-height: auto;">
<div style="margin-bottom: 10px; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 1px;">Diagram
</div>
    <svg viewBox="0 0 600 300" xmlns="http://www.w3.org/2000/svg" 
     style="max-width: 100%; height: auto; display: block; margin: 0 auto;; max-width: 100%; height: auto; display: block; margin: 0 auto;">
    <!-- Background -->
    <rect x="0" y="0" width="600" height="300" rx="8" fill="#f3e5f5" 
          stroke="#7b1fa2" stroke-width="2"/>
    
    <!-- Icon -->
    <g transform="translate(300, 100)">
        <rect x="-40" y="-30" width="80" height="60" rx="5" 
              fill="white" stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="-10" x2="20" y2="-10" 
              stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="0" x2="20" y2="0" 
              stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="10" x2="20" y2="10" 
              stroke="#7b1fa2" stroke-width="2"/>
    </g>
    
    <!-- Text -->
    <text x="300" y="180" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="18" 
          fill="#4a148c" font-weight="bold">
        Class Diagram
    </text>
<text x="300" y="210" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="14" 
          fill="#4a148c" opacity="0.8">
        (Diagram converted to static representation)
    </text>
    
    <!-- Original content hint -->
    <text x="300" y="240" text-anchor="middle" 
          font-family="monospace" font-size="10" 
          fill="#4a148c" opacity="0.5">
        classDiagram class Loggable { &gt; +log(message) +get...
    </text>
</svg>
</div>
</div><p>In this diagram, the <code>Loggable</code> interface defines a contract that any class wanting to be "loggable" must fulfill. Multiple completely different classes can implement this interface, each providing its own implementation of the required methods.</p>
            
            <div class="analogy">
                <h3>The Orchestra Analogy</h3>
                <p>Think of an interface as a musical score, and classes as different musicians. The score (interface) dictates what notes must be played (methods that must be implemented), but each musician (class) plays those notes with their own instrument and style. A violin and a piano can both play the same melody (implement the same interface), but they do so in their own unique ways.</p>
                <p>This allows a conductor (your application) to work with any instrument that can play the required score, without needing to know the specifics of how each instrument produces its sound.</p>
            </div>
        </section>

        <section id="interface-syntax">
            <h2>Interface Syntax in PHP</h2>
            
            <p>In PHP, interfaces are declared using the <code>interface</code> keyword, followed by the interface name. By convention, interface names often end with "able" or "Interface" (e.g., <code>Countable</code>, <code>LoggerInterface</code>) to make their purpose clear.</p>
            
            <div class="code-example">
                <h3>Basic Interface Syntax</h3>
                <pre><code>
// Define an interface
interface Loggable {
    // Method signatures (no implementation)
    public function log($message);
    public function getLogHistory();
}

// Class implementing the interface
class FileLogger implements Loggable {
    private $logFile;
    private $logHistory = [];
    
    public function __construct($logFile) {
        $this->logFile = $logFile;
    }
    
    // Must implement all interface methods
    public function log($message) {
        $logEntry = date('Y-m-d H:i:s') . ': ' . $message;
        $this->logHistory[] = $logEntry;
        
        // Write to log file
        file_put_contents($this->logFile, $logEntry . PHP_EOL, FILE_APPEND);
    }
    
    public function getLogHistory() {
        return $this->logHistory;
    }
    
    // Can add additional methods not in the interface
    public function clearLog() {
        $this->logHistory = [];
        file_put_contents($this->logFile, '');
    }
}

// Another class implementing the same interface
class DatabaseLogger implements Loggable {
    private $dbConnection;
    private $logHistory = [];
    
    public function __construct($dbConnection) {
        $this->dbConnection = $dbConnection;
    }
    
    // Different implementation of the same interface methods
    public function log($message) {
        $logEntry = date('Y-m-d H:i:s') . ': ' . $message;
        $this->logHistory[] = $logEntry;
        
        // Log to database (simplified example)
        $query = "INSERT INTO logs (message, created_at) VALUES ('{$message}', NOW())";
        // $this->dbConnection->exec($query);
    }
    
    public function getLogHistory() {
        return $this->logHistory;
    }
}

// Usage: can use either logger interchangeably
function processUserAction(Loggable $logger, $action) {
    // ... process the action ...
    $logger->log("User performed action: {$action}");
    
    // Return log history
    return $logger->getLogHistory();
}

// Works with any class that implements Loggable
$fileLogger = new FileLogger('/path/to/log.txt');
$dbLogger = new DatabaseLogger($dbConnection);

$fileLogHistory = processUserAction($fileLogger, 'login');
$dbLogHistory = processUserAction($dbLogger, 'update_profile');
                </code></pre>
            </div>
            
            <h3>Key Rules for Interfaces</h3>
            
            <ul>
                <li>Interfaces can only contain method declarations, not implementations</li>
                <li>All methods declared in an interface must be public</li>
                <li>A class that implements an interface must implement ALL methods declared in the interface</li>
                <li>A class can implement multiple interfaces</li>
                <li>Interfaces can extend other interfaces</li>
                <li>Interfaces cannot be instantiated directly</li>
                <li>Interfaces can contain constants but no properties</li>
            </ul>
        </section>

        <section id="interfaces-vs-abstract">
            <h2>Interfaces vs. Abstract Classes</h2>
            
            <p>In our previous lesson on abstract classes, we explored how they provide a partial implementation for child classes. Interfaces are different - they provide no implementation at all, only a contract. Let's compare the two:</p>
            
            <div class="comparison-table">
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Interface</th>
                            <th>Abstract Class</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Instantiation</td>
                            <td>Cannot be instantiated</td>
                            <td>Cannot be instantiated</td>
                        </tr>
                        <tr>
                            <td>Method implementation</td>
                            <td>No implementation (PHP 8+ allows default implementations)</td>
                            <td>Can have both abstract and concrete methods</td>
                        </tr>
                        <tr>
                            <td>Properties</td>
                            <td>Cannot have properties (only constants)</td>
                            <td>Can have properties</td>
                        </tr>
                        <tr>
                            <td>Multiple inheritance</td>
                            <td>A class can implement multiple interfaces</td>
                            <td>A class can extend only one abstract class</td>
                        </tr>
                        <tr>
                            <td>Access modifiers</td>
                            <td>All methods are implicitly public</td>
                            <td>Can use public, protected, private</td>
                        </tr>
                        <tr>
                            <td>Constructor</td>
                            <td>Cannot have a constructor</td>
                            <td>Can have a constructor</td>
                        </tr>
                        <tr>
                            <td>Use case</td>
                            <td>"Can-do" relationship (capabilities)</td>
                            <td>"Is-a" relationship with shared implementation</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="analogy">
                <h3>The Blueprint vs. Contract Analogy</h3>
                <p>Think of abstract classes as partial blueprints for a building. They specify some complete rooms (concrete methods) and some unfinished areas (abstract methods) that must be completed by the builder.</p>
                <p>Interfaces, on the other hand, are like a contract with a list of requirements. They don't tell you how to build anything; they just specify what features the final building must have (e.g., "must have four bedrooms, three bathrooms").</p>
                <p>A building can only follow one blueprint (extend one abstract class) but can satisfy multiple contracts (implement multiple interfaces).</p>
            </div>
            
            <div class="code-example">
                <h3>When to Use Each Approach</h3>
                <pre><code>
// Use an abstract class when you have an "is-a" relationship with shared code
abstract class Animal {
    protected $name;
    
    public function __construct($name) {
        $this->name = $name;
    }
    
    // Shared method implementation
    public function getName() {
        return $this->name;
    }
    
    // Method to be implemented by subclasses
    abstract public function makeSound();
}

class Dog extends Animal {
    public function makeSound() {
        return "Woof!";
    }
}

// Use interfaces for "can-do" capabilities that unrelated classes might share
interface Swimmable {
    public function swim();
    public function getMaxDepth();
}

// These classes aren't related, but both can swim
class Duck extends Animal implements Swimmable {
    public function makeSound() {
        return "Quack!";
    }
    
    public function swim() {
        return "{$this->name} is paddling across the pond.";
    }
    
    public function getMaxDepth() {
        return 2; // meters
    }
}

class Submarine implements Swimmable {
    private $name;
    private $maxDepth;
    
    public function __construct($name, $maxDepth) {
        $this->name = $name;
        $this->maxDepth = $maxDepth;
    }
    
    public function swim() {
        return "{$this->name} is diving beneath the waves.";
    }
    
    public function getMaxDepth() {
        return $this->maxDepth;
    }
}

// Function that works with any Swimmable object
function startRescueMission(Swimmable $rescuer, $depth) {
    if ($depth <= $rescuer->getMaxDepth()) {
        echo "Rescue mission started! ";
        echo $rescuer->swim();
    } else {
        echo "This rescuer cannot dive to the required depth!";
    }
}

$duck = new Duck("Donald");
$submarine = new Submarine("Deep Explorer", 1000);

startRescueMission($duck, 1); // Works with a Duck
startRescueMission($submarine, 500); // Works with a Submarine
                </code></pre>
            </div>
        </section>

        <section id="multiple-interfaces">
            <h2>Implementing Multiple Interfaces</h2>
            
            <p>One of the most powerful aspects of interfaces is that a class can implement multiple interfaces. This allows for a form of multiple inheritance in PHP, which doesn't support extending multiple classes.</p>
            
            <div class="diagram" style="margin: 1.5rem auto; padding: 1rem; text-align: center; overflow: hidden; max-width: 100%;">
<h3>Multiple Interface Implementation</h3>
                
<div class="mermaid-converted" style="margin: 1.5rem auto 0; padding: 1rem; text-align: center; overflow: visible; max-width: 100%; min-height: auto;">
<div style="margin-bottom: 10px; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 1px;">Diagram
</div>
    <svg viewBox="0 0 600 300" xmlns="http://www.w3.org/2000/svg" 
     style="max-width: 100%; height: auto; display: block; margin: 0 auto;; max-width: 100%; height: auto; display: block; margin: 0 auto;">
    <!-- Background -->
    <rect x="0" y="0" width="600" height="300" rx="8" fill="#f3e5f5" 
          stroke="#7b1fa2" stroke-width="2"/>
    
    <!-- Icon -->
    <g transform="translate(300, 100)">
        <rect x="-40" y="-30" width="80" height="60" rx="5" 
              fill="white" stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="-10" x2="20" y2="-10" 
              stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="0" x2="20" y2="0" 
              stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="10" x2="20" y2="10" 
              stroke="#7b1fa2" stroke-width="2"/>
    </g>
    
    <!-- Text -->
    <text x="300" y="180" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="18" 
          fill="#4a148c" font-weight="bold">
        Class Diagram
    </text>
<text x="300" y="210" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="14" 
          fill="#4a148c" opacity="0.8">
        (Diagram converted to static representation)
    </text>
    
    <!-- Original content hint -->
    <text x="300" y="240" text-anchor="middle" 
          font-family="monospace" font-size="10" 
          fill="#4a148c" opacity="0.5">
        classDiagram class Serializable { &gt; +serialize() +...
    </text>
</svg>
</div>
</div><div class="code-example">
                <h3>Implementing Multiple Interfaces</h3>
                <pre><code>
interface Serializable {
    public function serialize();
    public function unserialize($data);
}

interface JsonSerializable {
    public function jsonSerialize();
}

interface Loggable {
    public function log($message);
    public function getLogHistory();
}

class UserProfile implements Serializable, JsonSerializable, Loggable {
    private $id;
    private $username;
    private $email;
    private $logHistory = [];
    
    public function __construct($id, $username, $email) {
        $this->id = $id;
        $this->username = $username;
        $this->email = $email;
    }
    
    // Serializable implementation
    public function serialize() {
        return serialize([
            'id' => $this->id,
            'username' => $this->username,
            'email' => $this->email
        ]);
    }
    
    public function unserialize($data) {
        $data = unserialize($data);
        $this->id = $data['id'];
        $this->username = $data['username'];
        $this->email = $data['email'];
    }
    
    // JsonSerializable implementation
    public function jsonSerialize() {
        return [
            'id' => $this->id,
            'username' => $this->username,
            'email' => $this->email
        ];
    }
    
    // Loggable implementation
    public function log($message) {
        $this->logHistory[] = date('Y-m-d H:i:s') . ': ' . $message;
    }
    
    public function getLogHistory() {
        return $this->logHistory;
    }
    
    // Additional class-specific methods
    public function getUsername() {
        return $this->username;
    }
    
    public function getEmail() {
        return $this->email;
    }
}

// Usage example
$user = new UserProfile(1, 'johndoe', 'john@example.com');

// Using Loggable functionality
$user->log('Profile viewed');
$user->log('Profile updated');
print_r($user->getLogHistory());

// Using JsonSerializable functionality
$json = json_encode($user);
echo $json; // {"id":1,"username":"johndoe","email":"john@example.com"}

// Using Serializable functionality
$serialized = $user->serialize();
$newUser = new UserProfile(0, '', '');
$newUser->unserialize($serialized);
echo $newUser->getUsername(); // "johndoe"
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h3>Interface Segregation Principle</h3>
                <p>The Interface Segregation Principle (ISP) is one of the SOLID principles of object-oriented design. It states that "clients should not be forced to depend on methods they do not use." In practice, this means it's better to have many small, focused interfaces rather than a few large, general-purpose ones.</p>
                <div class="code-example">
                    <h4>Before (violating ISP)</h4>
                    <pre><code>
// One large interface - forces implementing classes to define methods they might not need
interface WorkerInterface {
    public function work();
    public function eat();
    public function sleep();
}

class Robot implements WorkerInterface {
    public function work() {
        return "Robot is working";
    }
    
    public function eat() {
        // Robots don't eat, but forced to implement this
        return null;
    }
    
    public function sleep() {
        // Robots don't sleep, but forced to implement this
        return null;
    }
}
                    </code></pre>
                    <h4>After (following ISP)</h4>
                    <pre><code>
// Segregated into smaller, focused interfaces
interface Workable {
    public function work();
}

interface Eatable {
    public function eat();
}

interface Sleepable {
    public function sleep();
}

// Human needs all capabilities
class Human implements Workable, Eatable, Sleepable {
    public function work() {
        return "Human is working";
    }
    
    public function eat() {
        return "Human is eating";
    }
    
    public function sleep() {
        return "Human is sleeping";
    }
}

// Robot only implements what it needs
class Robot implements Workable {
    public function work() {
        return "Robot is working";
    }
}
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="interface-inheritance">
            <h2>Interface Inheritance</h2>
            
            <p>Just as classes can extend other classes, interfaces can extend other interfaces. This allows you to create hierarchies of interface contracts, where a more specific interface includes all the requirements of a more general one, plus additional requirements.</p>
            
            <div class="diagram" style="margin: 1.5rem auto; padding: 1rem; text-align: center; overflow: hidden; max-width: 100%;">
<h3>Interface Inheritance</h3>
                
<div class="mermaid-converted" style="margin: 1.5rem auto 0; padding: 1rem; text-align: center; overflow: visible; max-width: 100%; min-height: auto;">
<div style="margin-bottom: 10px; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 1px;">Diagram
</div>
    <svg viewBox="0 0 600 300" xmlns="http://www.w3.org/2000/svg" 
     style="max-width: 100%; height: auto; display: block; margin: 0 auto;; max-width: 100%; height: auto; display: block; margin: 0 auto;">
    <!-- Background -->
    <rect x="0" y="0" width="600" height="300" rx="8" fill="#f3e5f5" 
          stroke="#7b1fa2" stroke-width="2"/>
    
    <!-- Icon -->
    <g transform="translate(300, 100)">
        <rect x="-40" y="-30" width="80" height="60" rx="5" 
              fill="white" stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="-10" x2="20" y2="-10" 
              stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="0" x2="20" y2="0" 
              stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="10" x2="20" y2="10" 
              stroke="#7b1fa2" stroke-width="2"/>
    </g>
    
    <!-- Text -->
    <text x="300" y="180" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="18" 
          fill="#4a148c" font-weight="bold">
        Class Diagram
    </text>
<text x="300" y="210" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="14" 
          fill="#4a148c" opacity="0.8">
        (Diagram converted to static representation)
    </text>
    
    <!-- Original content hint -->
    <text x="300" y="240" text-anchor="middle" 
          font-family="monospace" font-size="10" 
          fill="#4a148c" opacity="0.5">
        classDiagram class Readable { &gt; +read() } class Wr...
    </text>
</svg>
</div>
</div><div class="code-example">
                <h3>Interface Inheritance Example</h3>
                <pre><code>
// Basic interfaces
interface Readable {
    public function read();
}

interface Writable {
    public function write($data);
}

// Combined interface extending both Readable and Writable
interface Storage extends Readable, Writable {
    public function delete();
}

// More specialized interface
interface AdvancedStorage extends Storage {
    public function search($query);
    public function getSize();
}

// Implementing the specialized interface
class FileStorage implements AdvancedStorage {
    private $filename;
    private $data = [];
    
    public function __construct($filename) {
        $this->filename = $filename;
        // Load data from file if it exists
        if (file_exists($filename)) {
            $this->data = json_decode(file_get_contents($filename), true) ?? [];
        }
    }
    
    // From Readable
    public function read() {
        return $this->data;
    }
    
    // From Writable
    public function write($data) {
        $this->data = $data;
        $this->saveToFile();
        return true;
    }
    
    // From Storage
    public function delete() {
        $this->data = [];
        $this->saveToFile();
        return true;
    }
    
    // From AdvancedStorage
    public function search($query) {
        $results = [];
        foreach ($this->data as $key => $value) {
            if (strpos(json_encode($value), $query) !== false) {
                $results[$key] = $value;
            }
        }
        return $results;
    }
    
    public function getSize() {
        return filesize($this->filename) ?? 0;
    }
    
    // Helper method (not required by any interface)
    private function saveToFile() {
        file_put_contents($this->filename, json_encode($this->data));
    }
}

// Usage with type hinting for different interface levels
function readData(Readable $storage) {
    return $storage->read();
}

function storeData(Writable $storage, $data) {
    $storage->write($data);
    echo "Data stored successfully.";
}

function fullBackup(Storage $storage) {
    $data = $storage->read();
    // Make a backup...
    echo "Backup completed with " . count($data) . " records.";
}

function searchAndReport(AdvancedStorage $storage, $query) {
    $results = $storage->search($query);
    echo "Found " . count($results) . " results. Total storage size: " . $storage->getSize() . " bytes.";
}

// Create a storage instance
$fileStorage = new FileStorage('data.json');

// Works with all functions because it implements all interfaces
readData($fileStorage);
storeData($fileStorage, ['user' => 'John', 'email' => 'john@example.com']);
fullBackup($fileStorage);
searchAndReport($fileStorage, 'john');
                </code></pre>
            </div>
        </section>

        <section id="type-hinting">
            <h2>Type Hinting with Interfaces</h2>
            
            <p>One of the most powerful uses of interfaces is in type hinting. By type hinting with interfaces instead of concrete classes, you create more flexible, decoupled code that can work with any class that implements the required interface.</p>
            
            <div class="code-example">
                <h3>Type Hinting for Flexibility</h3>
                <pre><code>
interface PaymentProcessor {
    public function processPayment($amount);
    public function refundPayment($transactionId);
}

class StripePaymentProcessor implements PaymentProcessor {
    public function processPayment($amount) {
        // Stripe-specific implementation
        return "Stripe payment processed: ${$amount}";
    }
    
    public function refundPayment($transactionId) {
        // Stripe-specific refund
        return "Stripe payment {$transactionId} refunded";
    }
}

class PayPalPaymentProcessor implements PaymentProcessor {
    public function processPayment($amount) {
        // PayPal-specific implementation
        return "PayPal payment processed: ${$amount}";
    }
    
    public function refundPayment($transactionId) {
        // PayPal-specific refund
        return "PayPal payment {$transactionId} refunded";
    }
}

// Flexible order processing that works with any payment processor
class OrderProcessor {
    private $paymentProcessor;
    
    // Type hint with the interface
    public function __construct(PaymentProcessor $paymentProcessor) {
        $this->paymentProcessor = $paymentProcessor;
    }
    
    public function checkout($items) {
        $total = $this->calculateTotal($items);
        
        // Process payment using whatever payment processor was injected
        $transactionId = $this->paymentProcessor->processPayment($total);
        
        return [
            'status' => 'success',
            'total' => $total,
            'transaction_id' => $transactionId
        ];
    }
    
    private function calculateTotal($items) {
        return array_sum(array_column($items, 'price'));
    }
}

// Usage
$items = [
    ['name' => 'Product 1', 'price' => 29.99],
    ['name' => 'Product 2', 'price' => 49.99]
];

// Can use any payment processor
$stripeProcessor = new StripePaymentProcessor();
$paypalProcessor = new PayPalPaymentProcessor();

// Create order processor with Stripe
$orderProcessor = new OrderProcessor($stripeProcessor);
$stripeResult = $orderProcessor->checkout($items);

// Create order processor with PayPal
$orderProcessor = new OrderProcessor($paypalProcessor);
$paypalResult = $orderProcessor->checkout($items);
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h3>Dependency Inversion Principle</h3>
                <p>The Dependency Inversion Principle (DIP) states that high-level modules should not depend on low-level modules; both should depend on abstractions. Interfaces are perfect for creating these abstractions.</p>
                
<div class="mermaid-converted" style="margin: 1.5rem auto 0; padding: 1rem; text-align: center; overflow: visible; max-width: 100%; min-height: auto;">
<div style="margin-bottom: 10px; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 1px;">Diagram
</div>
    <svg viewBox="0 0 800 700" xmlns="http://www.w3.org/2000/svg" 
     style="max-width: 100%; height: auto; display: block; margin: 0 auto; background: white; border-radius: 8px;; max-width: 100%; height: auto; display: block; margin: 0 auto;">
    <!-- Embedded styles for this diagram only -->
    <defs>
        <style type="text/css">
            .node-rect { fill: #e1f5fe; stroke: #01579b; stroke-width: 2px; }
            .node-rect:hover { fill: #b3e5fc; }
            .node-text { fill: #01579b; font-family: 'Segoe UI', Arial, sans-serif; font-size: 14px; font-weight: 500; }
            .connection-line { stroke: #546e7a; stroke-width: 2px; fill: none; }
            .arrow-marker { fill: #546e7a; }
            .diagram-title { fill: #263238; font-size: 18px; font-weight: bold; }
            .subgraph-rect { fill: #fff3e0; stroke: #e65100; stroke-width: 1px; stroke-dasharray: 5,5; opacity: 0.3; }
        </style>
        
        <!-- Arrow marker -->
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,6 L9,3 z" class="arrow-marker"/>
        </marker>
    </defs>
    
    <!-- Background -->
    <rect x="0" y="0" width="800" height="700" fill="#fafafa" rx="8"/>
    
    <line x1="330.0" y1="80" x2="225.0" y2="200" 
          class="connection-line" marker-end="url(#arrow)"/>
    <line x1="610.0" y1="80" x2="400.0" y2="200" 
          class="connection-line" marker-end="url(#arrow)"/>
    <line x1="400.0" y1="200" x2="575.0" y2="200" 
          class="connection-line" marker-end="url(#arrow)"/>
    <line x1="610.0" y1="80" x2="575.0" y2="200" 
          class="connection-line" marker-end="url(#arrow)"/>
    <text x="592.5" y="135.0" text-anchor="middle" 
          class="node-text" font-size="12">&gt; F[Interface] F </text>
    <rect x="108.0" y="55" width="164" height="50" 
          rx="5" class="node-rect"/>
    <text x="190.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">Without Interfaces</text>
    <rect x="252.0" y="55" width="156" height="50" 
          rx="5" class="node-rect"/>
    <text x="330.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">High-Level Module</text>
    <rect x="151.0" y="175" width="148" height="50" 
          rx="5" class="node-rect"/>
    <text x="225.0" y="200" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">Low-Level Module</text>
    <rect x="400.0" y="55" width="140" height="50" 
          rx="5" class="node-rect"/>
    <text x="470.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">With Interfaces</text>
    <rect x="532.0" y="55" width="156" height="50" 
          rx="5" class="node-rect"/>
    <text x="610.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">High-Level Module</text>
    <rect x="340.0" y="175" width="120" height="50" 
          rx="5" class="node-rect"/>
    <text x="400.0" y="200" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">Interface</text>
    <rect x="501.0" y="175" width="148" height="50" 
          rx="5" class="node-rect"/>
    <text x="575.0" y="200" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">Low-Level Module</text>
</svg>
</div><p>By having the high-level module (like <code>OrderProcessor</code>) depend on an interface (<code>PaymentProcessor</code>) rather than concrete implementations (<code>StripePaymentProcessor</code>, <code>PayPalPaymentProcessor</code>), we create more flexible, maintainable code.</p>
            </div>
        </section>

        <section id="interface-constants">
            <h2>Constants in Interfaces</h2>
            
            <p>While interfaces cannot contain properties, they can define constants. These constants are implicitly public and can be accessed through the interface name. Any class implementing the interface also inherits these constants.</p>
            
            <div class="code-example">
                <h3>Interface Constants Example</h3>
                <pre><code>
interface PaymentStatus {
    // Constants
    const PENDING = 'pending';
    const COMPLETED = 'completed';
    const FAILED = 'failed';
    const REFUNDED = 'refunded';
}

class Payment implements PaymentStatus {
    private $status;
    
    public function __construct() {
        // Access constant from interface
        $this->status = self::PENDING;
    }
    
    public function processPayment() {
        // Simulate payment processing
        $success = (rand(0, 10) > 2); // 80% success rate
        
        // Update status based on result
        if ($success) {
            $this->status = self::COMPLETED;
            return true;
        } else {
            $this->status = self::FAILED;
            return false;
        }
    }
    
    public function refund() {
        if ($this->status !== self::COMPLETED) {
            throw new Exception("Cannot refund a payment that isn't completed");
        }
        
        $this->status = self::REFUNDED;
        return true;
    }
    
    public function getStatus() {
        return $this->status;
    }
}

// Even without implementing the interface, you can access the constants
echo "Statuses: " . PaymentStatus::PENDING . ", " . PaymentStatus::COMPLETED;

// Create a payment
$payment = new Payment();
echo "Initial status: " . $payment->getStatus(); // "pending"

if ($payment->processPayment()) {
    echo "Payment completed successfully.";
} else {
    echo "Payment failed.";
}

// Access via implementing class
if ($payment->getStatus() === Payment::COMPLETED) {
    $payment->refund();
    echo "Payment refunded.";
}
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h3>Using Interface Constants for Type Safety</h3>
                <p>Interface constants are great for defining a fixed set of values that a method should accept. This provides a form of type safety in PHP.</p>
                <pre><code>
interface LogLevel {
    const DEBUG = 'debug';
    const INFO = 'info';
    const WARNING = 'warning';
    const ERROR = 'error';
}

class Logger implements LogLevel {
    private $logEntries = [];
    
    public function log($message, $level = self::INFO) {
        // Validate level using interface constants
        $validLevels = [self::DEBUG, self::INFO, self::WARNING, self::ERROR];
        
        if (!in_array($level, $validLevels)) {
            throw new InvalidArgumentException("Invalid log level");
        }
        
        $this->logEntries[] = [
            'timestamp' => date('Y-m-d H:i:s'),
            'level' => $level,
            'message' => $message
        ];
    }
    
    // Rest of the class...
}

// Usage
$logger = new Logger();
$logger->log("User logged in", LogLevel::INFO);
$logger->log("Failed login attempt", LogLevel::WARNING);
$logger->log("Database connection failed", LogLevel::ERROR);

// Invalid level would throw an exception
// $logger->log("Test message", "invalid_level");
                </code></pre>
            </div>
        </section>

        <section id="default-implementations">
            <h2>Default Method Implementations (PHP 8.0+)</h2>
            
            <p>Starting with PHP 8.0, interfaces can include default implementations for methods. This brings interfaces closer to abstract classes, but with the key difference that a class can still implement multiple interfaces.</p>
            
            <div class="code-example">
                <h3>Interface with Default Methods</h3>
                <pre><code>
// PHP 8.0+ only
interface Loggable {
    // Method with default implementation
    public function log($message) {
        // Default logging to error_log
        error_log("[" . date('Y-m-d H:i:s') . "] {$message}");
    }
    
    // Method without default implementation
    public function getLogHistory();
}

// Implementing class can use the default implementation
class SimpleLogger implements Loggable {
    private $logHistory = [];
    
    // Uses default log() implementation from interface
    
    // Must implement the method without a default
    public function getLogHistory() {
        return $this->logHistory;
    }
}

// Implementing class can override the default implementation
class CustomLogger implements Loggable {
    private $logHistory = [];
    
    // Override the default implementation
    public function log($message) {
        $logEntry = "[" . date('Y-m-d H:i:s') . "] {$message}";
        $this->logHistory[] = $logEntry;
        
        // Custom logging to both error_log and file
        error_log($logEntry);
        file_put_contents('custom.log', $logEntry . PHP_EOL, FILE_APPEND);
    }
    
    public function getLogHistory() {
        return $this->logHistory;
    }
}
                </code></pre>
            </div>
            
            <div class="note">
                <p><strong>Compatibility Note:</strong> Default method implementations in interfaces are only available in PHP 8.0 and later. If you're working in an environment with older PHP versions (which is common with WordPress installations), you'll need to stick with the traditional approach of interfaces without implementations.</p>
            </div>
        </section>

        <section id="real-world-examples">
            <h2>Real-World Examples in WordPress</h2>
            
            <p>WordPress makes extensive use of interfaces in its codebase, especially in more recent versions and in modern plugins. Let's explore a few real-world examples:</p>
            
            <h3>WP_Hook_Interface</h3>
            
            <p>WordPress has an interface for its hooks system, which is the foundation of WordPress's plugin architecture.</p>
            
            <div class="code-example">
                <h4>Simplified WP_Hook_Interface Example</h4>
                <pre><code>
/**
 * Interface for all hooks (actions and filters).
 */
interface WP_Hook_Interface {
    /**
     * Adds a callback function to a hook.
     *
     * @param string   $tag             The hook name.
     * @param callable $function_to_add The callback function.
     * @param int      $priority        The priority.
     * @param int      $accepted_args   The number of args the callback accepts.
     * @return true
     */
    public function add_filter($tag, $function_to_add, $priority, $accepted_args);

    /**
     * Removes a callback function from a hook.
     *
     * @param string   $tag                The hook name.
     * @param callable $function_to_remove The callback to remove.
     * @param int      $priority           The priority.
     * @return bool True if removed, false if not found.
     */
    public function remove_filter($tag, $function_to_remove, $priority);

    /**
     * Executes a hook's callbacks.
     *
     * @param string $tag   The hook name.
     * @param mixed  $value The value to filter.
     * @param array  $args  Additional arguments.
     * @return mixed The filtered value.
     */
    public function apply_filters($tag, $value, $args);

    /**
     * Executes an action hook.
     *
     * @param string $tag  The hook name.
     * @param array  $args The action arguments.
     */
    public function do_action($tag, $args);

    /**
     * Checks if a hook has callbacks.
     *
     * @param string $tag      The hook name.
     * @param bool   $priority Optional. Whether to check a specific priority.
     * @return bool|int
     */
    public function has_filter($tag, $priority = false);
}

// WordPress implements this interface with the WP_Hook class
class WP_Hook implements WP_Hook_Interface {
    // Implementation of all the required methods
}
                </code></pre>
            </div>
            
            <p>This interface allows WordPress to potentially swap out its hook implementation while maintaining backward compatibility with plugins that rely on the hook system.</p>
            
            <h3>WP_HTTP_Response_Interface</h3>
            
            <p>WordPress uses interfaces for its HTTP response handling, particularly in the REST API.</p>
            
            <div class="code-example">
                <h4>WordPress HTTP Response Interface Example</h4>
                <pre><code>
/**
 * Interface for HTTP responses.
 */
interface WP_HTTP_Response_Interface {
    /**
     * Gets the response data.
     *
     * @return mixed The response data.
     */
    public function get_data();

    /**
     * Sets the response data.
     *
     * @param mixed $data Response data.
     * @return $this
     */
    public function set_data($data);

    /**
     * Gets the response status code.
     *
     * @return int The response status code.
     */
    public function get_status();

    /**
     * Sets the response status code.
     *
     * @param int $code The status code.
     * @return $this
     */
    public function set_status($code);

    /**
     * Gets the response headers.
     *
     * @return array The response headers.
     */
    public function get_headers();

    /**
     * Sets the response headers.
     *
     * @param array $headers The headers to set.
     * @return $this
     */
    public function set_headers($headers);
}

// WordPress has multiple implementations
class WP_REST_Response implements WP_HTTP_Response_Interface {
    // Implementation for REST API responses
}

class WP_HTTP_Response implements WP_HTTP_Response_Interface {
    // Base implementation for HTTP responses
}
                </code></pre>
            </div>

            <h3>Creating a Custom Widget Interface</h3>
            
            <p>While WordPress's widget system pre-dates extensive use of interfaces, we can demonstrate how a modern approach might use interfaces for widget development:</p>
            
            <div class="code-example">
                <h4>Custom Widget Interface Example</h4>
                <pre><code>
/**
 * Interface for custom widgets.
 */
interface CustomWidgetInterface {
    /**
     * Renders the widget on the front end.
     *
     * @param array $args     Display arguments.
     * @param array $instance Settings for this widget instance.
     */
    public function render_widget($args, $instance);
    
    /**
     * Renders the widget form in the admin.
     *
     * @param array $instance Current settings.
     */
    public function render_form($instance);
    
    /**
     * Updates the widget settings.
     *
     * @param array $new_instance New settings.
     * @param array $old_instance Old settings.
     * @return array Updated settings.
     */
    public function update_settings($new_instance, $old_instance);
}

/**
 * Base class that integrates with WordPress widget API
 */
abstract class Base_Custom_Widget extends WP_Widget implements CustomWidgetInterface {
    /**
     * Base_Custom_Widget constructor.
     *
     * @param string $id_base         Optional Base ID.
     * @param string $name            Name.
     * @param array  $widget_options  Optional.
     * @param array  $control_options Optional.
     */
    public function __construct($id_base, $name, $widget_options = [], $control_options = []) {
        parent::__construct($id_base, $name, $widget_options, $control_options);
    }
    
    /**
     * WordPress widget API method.
     */
    public function widget($args, $instance) {
        $this->render_widget($args, $instance);
    }
    
    /**
     * WordPress widget API method.
     */
    public function form($instance) {
        $this->render_form($instance);
    }
    
    /**
     * WordPress widget API method.
     */
    public function update($new_instance, $old_instance) {
        return $this->update_settings($new_instance, $old_instance);
    }
}

/**
 * Example implementation of a custom widget.
 */
class Recent_Posts_Widget extends Base_Custom_Widget {
    /**
     * Constructor.
     */
    public function __construct() {
        parent::__construct(
            'recent_posts_widget',
            'Recent Posts Widget',
            [
                'description' => 'Displays recent posts with custom formatting.',
            ]
        );
    }
    
    /**
     * Renders the widget.
     */
    public function render_widget($args, $instance) {
        echo $args['before_widget'];
        echo $args['before_title'] . $instance['title'] . $args['after_title'];
        
        // Query recent posts
        $posts = get_posts([
            'numberposts' => $instance['number'],
            'post_status' => 'publish',
        ]);
        
        if ($posts) {
            echo '&lt;ul class="recent-posts"&gt;';
            foreach ($posts as $post) {
                echo '&lt;li&gt;';
                echo '&lt;a href="' . get_permalink($post) . '"&gt;' . $post->post_title . '&lt;/a&gt;';
                echo '&lt;/li&gt;';
            }
            echo '&lt;/ul&gt;';
        } else {
            echo '&lt;p&gt;No recent posts found.&lt;/p&gt;';
        }
        
        echo $args['after_widget'];
    }
    
    /**
     * Renders the form.
     */
    public function render_form($instance) {
        $title = isset($instance['title']) ? $instance['title'] : 'Recent Posts';
        $number = isset($instance['number']) ? (int) $instance['number'] : 5;
        
        echo '&lt;p&gt;';
        echo '&lt;label for="' . $this->get_field_id('title') . '"&gt;Title:&lt;/label&gt;';
        echo '&lt;input class="widefat" id="' . $this->get_field_id('title') . '" name="' . $this->get_field_name('title') . '" type="text" value="' . esc_attr($title) . '"&gt;';
        echo '&lt;/p&gt;';
        
        echo '&lt;p&gt;';
        echo '&lt;label for="' . $this->get_field_id('number') . '"&gt;Number of posts:&lt;/label&gt;';
        echo '&lt;input class="tiny-text" id="' . $this->get_field_id('number') . '" name="' . $this->get_field_name('number') . '" type="number" step="1" min="1" value="' . esc_attr($number) . '" size="3"&gt;';
        echo '&lt;/p&gt;';
    }
    
    /**
     * Updates the settings.
     */
    public function update_settings($new_instance, $old_instance) {
        $instance = [];
        $instance['title'] = !empty($new_instance['title']) ? sanitize_text_field($new_instance['title']) : '';
        $instance['number'] = !empty($new_instance['number']) ? (int) $new_instance['number'] : 5;
        
        return $instance;
    }
}

// Register the widget
function register_recent_posts_widget() {
    register_widget('Recent_Posts_Widget');
}
add_action('widgets_init', 'register_recent_posts_widget');
                </code></pre>
            </div>
        </section>

        <section id="interface-best-practices">
            <h2>Interface Best Practices</h2>
            
            <div class="best-practices">
                <div class="practice">
                    <h3>Keep Interfaces Focused and Small</h3>
                    <p>Following the Interface Segregation Principle, create small, focused interfaces rather than large, general-purpose ones. A good rule of thumb is that an interface should have no more than a handful of methods, all related to a single responsibility.</p>
                    <div class="code-example">
                        <h4>Good: Focused interfaces</h4>
                        <pre><code>
interface Readable {
    public function read($id);
}

interface Writable {
    public function create($data);
    public function update($id, $data);
    public function delete($id);
}

// Class can implement only what it needs
class ReadOnlyRepository implements Readable {
    public function read($id) {
        // Implementation
    }
}

class FullRepository implements Readable, Writable {
    public function read($id) {
        // Implementation
    }
    
    public function create($data) {
        // Implementation
    }
    
    public function update($id, $data) {
        // Implementation
    }
    
    public function delete($id) {
        // Implementation
    }
}
                        </code></pre>
                    </div>
                </div>
                
                <div class="practice">
                    <h3>Use Descriptive Method Names</h3>
                    <p>Since interfaces are contracts, use clear, descriptive method names that explain what the method does, not how it's implemented.</p>
                    <div class="code-example">
                        <h4>Good: Descriptive method names</h4>
                        <pre><code>
// Good
interface UserRepository {
    public function findUserById($id);
    public function findUsersByRole($role);
    public function saveUser(User $user);
    public function deleteUser($id);
}

// Bad
interface UserRepo {
    public function getFromDatabase($id); // How, not what
    public function executeQuery($role); // How, not what
    public function insertOrUpdate(User $user); // Mixing concerns
    public function executeDelete($id); // How, not what
}
                        </code></pre>
                    </div>
                </div>
                
                <div class="practice">
                    <h3>Use Type Hinting</h3>
                    <p>Take advantage of PHP's type hinting capabilities to make interfaces more robust. Use strict types where appropriate.</p>
                    <div class="code-example">
                        <h4>Good: Type hinting in interfaces</h4>
                        <pre><code>
// PHP 7.0+
interface UserRepository {
    public function findById(int $id): ?User;
    public function findByEmail(string $email): ?User;
    public function save(User $user): bool;
    public function delete(int $id): bool;
}
                        </code></pre>
                    </div>
                </div>
                
                <div class="practice">
                    <h3>Document Interface Methods Thoroughly</h3>
                    <p>Since interfaces are contracts that others will implement, document them thoroughly with PHPDoc comments.</p>
                    <div class="code-example">
                        <h4>Good: Well-documented interface</h4>
                        <pre><code>
/**
 * Interface for payment gateways.
 */
interface PaymentGateway {
    /**
     * Process a payment transaction.
     *
     * @param float  $amount          The amount to charge.
     * @param string $currency        The currency code (e.g., 'USD').
     * @param array  $customer_data   Customer information.
     * @param array  $payment_details Payment method details.
     *
     * @return array Transaction result containing:
     *               - 'success' (bool): Whether the transaction succeeded.
     *               - 'transaction_id' (string): The gateway transaction ID.
     *               - 'message' (string): Success/error message.
     *               - 'error_code' (string|null): Error code if failed.
     *
     * @throws PaymentException If there's a critical error processing the payment.
     */
    public function processPayment(
        float $amount,
        string $currency,
        array $customer_data,
        array $payment_details
    ): array;
    
    /**
     * Refund a previous payment transaction.
     *
     * @param string $transaction_id The transaction ID to refund.
     * @param float  $amount         The amount to refund, or null for full refund.
     *
     * @return bool True if the refund was successful, false otherwise.
     *
     * @throws RefundException If there's a critical error processing the refund.
     */
    public function refundPayment(string $transaction_id, ?float $amount = null): bool;
}
                        </code></pre>
                    </div>
                </div>
                
                <div class="practice">
                    <h3>Use Interfaces for Dependency Injection</h3>
                    <p>Interfaces are ideal for dependency injection, allowing you to swap implementations easily.</p>
                    <div class="code-example">
                        <h4>Good: Dependency injection with interfaces</h4>
                        <pre><code>
// Service class depends on an interface, not a concrete class
class NotificationService {
    private $notifier;
    
    // Type hint with the interface
    public function __construct(NotifierInterface $notifier) {
        $this->notifier = $notifier;
    }
    
    public function sendNotification($user, $message) {
        // Use the injected implementation
        $this->notifier->notify($user, $message);
    }
}

// Different implementations can be injected
$emailNotifier = new EmailNotifier();
$smsNotifier = new SMSNotifier();
$pushNotifier = new PushNotifier();

// Create the service with any implementation
$service = new NotificationService($emailNotifier);
// Later can switch to a different implementation
$service = new NotificationService($smsNotifier);
                        </code></pre>
                    </div>
                </div>
                
                <div class="practice">
                    <h3>Consider Using Standards Interfaces</h3>
                    <p>PHP includes several standard interfaces (like <code>Iterator</code>, <code>Countable</code>, <code>JsonSerializable</code>) that you can implement to make your classes work with built-in PHP functionality.</p>
                    <div class="code-example">
                        <h4>Using Standard PHP Interfaces</h4>
                        <pre><code>
// Making a class work with count() function
class UserCollection implements Countable, Iterator {
    private $users = [];
    private $position = 0;
    
    public function addUser(User $user) {
        $this->users[] = $user;
    }
    
    // Countable interface implementation
    public function count(): int {
        return count($this->users);
    }
    
    // Iterator interface implementation
    public function current() {
        return $this->users[$this->position];
    }
    
    public function key() {
        return $this->position;
    }
    
    public function next() {
        ++$this->position;
    }
    
    public function rewind() {
        $this->position = 0;
    }
    
    public function valid() {
        return isset($this->users[$this->position]);
    }
}

// Usage
$collection = new UserCollection();
$collection->addUser(new User('John'));
$collection->addUser(new User('Jane'));

// Works with count() function
echo count($collection); // 2

// Works with foreach
foreach ($collection as $user) {
    echo $user->getName();
}
                        </code></pre>
                    </div>
                </div>
            </div>
        </section>

        <section id="homework">
            <h2>Homework: Building a WordPress Plugin with Interfaces</h2>
            
            <div class="assignment">
                <h3>Assignment: Create a Simple Notification System</h3>
                
                <p>For this assignment, you'll create a simple WordPress plugin that sends notifications through different channels (email, admin notice, etc.) using interfaces to define the contract between components.</p>
                
                <h4>Requirements:</h4>
                <ol>
                    <li>Create a <code>NotifierInterface</code> with methods for sending and logging notifications</li>
                    <li>Implement at least two notifier classes:
                        <ul>
                            <li><code>EmailNotifier</code>: Sends notifications via email</li>
                            <li><code>AdminNotifier</code>: Displays notifications as WordPress admin notices</li>
                        </ul>
                    </li>
                    <li>Create a <code>NotificationManager</code> class that can:
                        <ul>
                            <li>Register multiple notifiers</li>
                            <li>Send notifications through all registered notifiers or a specific notifier</li>
                            <li>Track notification history</li>
                        </ul>
                    </li>
                    <li>Add a simple admin page to test sending notifications</li>
                    <li>Use proper type hinting and documentation throughout your code</li>
                </ol>
                
                <h4>Starter Code:</h4>
                <pre><code>
<?php
/**
 * Plugin Name: Simple Notification System
 * Description: A notification system using interfaces
 * Version: 1.0.0
 * Author: Your Name
 */

// Prevent direct access
if (!defined('ABSPATH')) {
    exit;
}

/**
 * Interface for notification services.
 */
interface NotifierInterface {
    /**
     * Send a notification.
     *
     * @param string $recipient The recipient of the notification.
     * @param string $subject   The subject of the notification.
     * @param string $message   The message content.
     * @param array  $options   Additional options for the notification.
     *
     * @return bool True if notification was sent successfully, false otherwise.
     */
    public function send($recipient, $subject, $message, array $options = []);
    
    /**
     * Get the name of the notifier.
     *
     * @return string The name of the notifier.
     */
    public function getName();
    
    /**
     * Get the notification history.
     *
     * @return array List of previous notifications.
     */
    public function getHistory();
}

// TODO: Implement EmailNotifier class

// TODO: Implement AdminNotifier class

// TODO: Implement NotificationManager class

// TODO: Add admin page for testing
                </code></pre>
                
                <h4>Bonus Challenges:</h4>
                <ul>
                    <li>Add a <code>SMSNotifier</code> that simulates sending SMS notifications (you don't need to actually send SMS messages)</li>
                    <li>Create a <code>NotificationFormatterInterface</code> to allow different formatting strategies for different notification types</li>
                    <li>Add notification priority levels and the ability to filter notifications based on priority</li>
                    <li>Implement a <code>DatabaseLogger</code> that stores notification history in the WordPress database</li>
                </ul>
            </div>
        </section>

        <section class="summary">
            <h2>Key Takeaways</h2>
            
            <div class="takeaways">
                <div class="takeaway">
                    <h3>Contract-Based Programming</h3>
                    <p>Interfaces define contracts that implementing classes must fulfill, creating a clear separation between what a class can do and how it does it.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Multiple Implementation</h3>
                    <p>Unlike abstract classes, a class can implement multiple interfaces, allowing for a form of multiple inheritance in PHP.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Decoupling and Flexibility</h3>
                    <p>Using interfaces in type hints creates more flexible, decoupled code that can work with any class implementing the required interface.</p>
                </div>
                
                <div class="takeaway">
                    <h3>SOLID Principles</h3>
                    <p>Interfaces support key SOLID principles like Interface Segregation and Dependency Inversion, leading to more maintainable code.</p>
                </div>
                
                <div class="takeaway">
                    <h3>WordPress Integration</h3>
                    <p>Understanding interfaces helps you work with modern WordPress APIs and create more extensible plugins and themes.</p>
                </div>
            </div>
            
            <div class="next-steps">
                <h3>Next Steps</h3>
                <p>Now that you understand interfaces, we'll continue exploring advanced OOP concepts with traits, which provide another way to reuse code across classes. Together, interfaces, abstract classes, and traits give you a powerful toolkit for building flexible, maintainable PHP applications and WordPress extensions.</p>
            </div>
        </section>

        <section class="resources">
            <h2>Additional Resources</h2>
            
            <ul>
                <li><a href="https://www.php.net/manual/en/language.oop5.interfaces.php" target="_blank">PHP Manual: Object Interfaces</a></li>
                <li><a href="https://phptherightway.com/#object-oriented-programming" target="_blank">PHP The Right Way: Object-Oriented Programming</a></li>
                <li><a href="https://developer.wordpress.org/plugins/intro/" target="_blank">WordPress Plugin Developer Handbook</a></li>
                <li><a href="https://refactoring.guru/design-patterns/php" target="_blank">Design Patterns in PHP</a></li>
                <li><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank">SOLID Principles of Object-Oriented Design</a></li>
                <li><a href="https://developer.wordpress.org/reference/interfaces/" target="_blank">WordPress Interface Reference</a></li>
            </ul>
        </section>
            
<div class="lesson-navigation">
<a class="lesson-nav-button prev" href="/module2.html">
<svg fill="currentColor" height="20" viewbox="0 0 20 20" width="20" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" viewBox="0 0 20 20">
<path d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"></path>
</svg>
<span>
<small>Back to</small><br/>
                                    Module 2 Overview
                                </span>
</a>
<button class="complete-lesson-btn">
                                Mark as Complete
                            </button>
<a class="lesson-nav-button next" href="/module3.html">
<span>
<small>Next Module</small><br/>
                                    Module 3: MySQL Database
                                </span>
<svg fill="currentColor" height="20" viewbox="0 0 20 20" width="20" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" viewBox="0 0 20 20">
<path d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"></path>
</svg>
</a>
</div>
</article>
</div>
</div>
</main>
<!-- Footer -->
<footer class="site-footer" role="contentinfo">
<div class="footer-container">
<div class="footer-content">
<div class="footer-section footer-about">
<h3>PHP WordPress Development</h3>
<p>Complete Web Development Course</p>
</div>
<div class="footer-section">
<h4>Quick Links</h4>
<ul class="footer-links">
<li><a href="/">Home</a></li>
<li><a href="/module2.html">Module 2</a></li>
<li><a href="/resources.html">Resources</a></li>
</ul>
</div>
<div class="footer-section">
<h4>Support</h4>
<ul class="footer-links">
<li><a href="/help.html">Help Center</a></li>
<li><a href="/faq.html">FAQ</a></li>
<li><a href="/contact.html">Contact</a></li>
</ul>
</div>
</div>
<div class="footer-bottom">
<div class="footer-bottom-content">
<p class="copyright">© 2025 PHP WordPress Development Course</p>
<nav class="footer-bottom-links">
<a href="/privacy.html">Privacy</a>
<span class="separator">|</span>
<a href="/terms.html">Terms</a>
</nav>
</div>
</div>
</div>
</footer>
</div>
<!-- Back to Top -->
<button aria-label="Back to top" class="back-to-top" id="back-to-top">
<svg fill="none" height="24" stroke="currentColor" stroke-width="2" viewbox="0 0 24 24" width="24" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" viewBox="0 0 2 24">
<path d="M12 19V5M12 5l-7 7M12 5l7 7"></path>
</svg>
</button>
<!-- JavaScript -->
<script src="/assets/js/navigation.js"></script>
<script src="/assets/js/site-config.js"></script>
<script src="/assets/js/sidebar-toggle.js"></script>
<script src="/assets/js/mermaid-universal-fix.js"></script>
</body>
</html>