<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Classes in PHP: Blueprint for Child Classes</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <header>
        <h1>Abstract Classes in PHP</h1>
        <p><a href="index.html">← Back to Syllabus</a></p>
    </header>
    
    <main>
        <section class="module-intro">
            <h2>Building a Foundation with Abstract Classes</h2>
            <p>Welcome to our exploration of abstract classes in PHP! Abstract classes are a fundamental concept in object-oriented programming that bridge the gap between interfaces and concrete classes. They provide a powerful way to establish common structures while enforcing implementation details in child classes.</p>
            
            <div class="note">
                <p><strong>Why Abstract Classes Matter:</strong> Abstract classes are essential for creating robust, maintainable PHP applications. In WordPress development, abstract classes form the backbone of many core components including widgets, admin pages, and REST API controllers. Understanding abstract classes will dramatically improve your ability to extend WordPress and create plugins that integrate seamlessly with core functionality.</p>
            </div>
        </section>

        <section id="abstract-class-basics">
            <h2>Understanding Abstract Classes</h2>
            
            <p>Abstract classes are like architectural blueprints for a building. The blueprint itself isn't a building (you can't live in it), but it defines the essential structure that all actual buildings based on that blueprint must follow. Similarly, an abstract class can't be instantiated directly, but it defines a structure that all extending classes must adhere to.</p>
            
            <div class="diagram">
                <h3>Abstract Class Structure</h3>
                <div class="mermaid">
                    classDiagram
                      class AbstractClass {
                        <<abstract>>
                        +regularMethod()
                        +abstractMethod()*
                      }
                      class ConcreteClass1 {
                        +regularMethod()
                        +abstractMethod()
                      }
                      class ConcreteClass2 {
                        +regularMethod()
                        +abstractMethod()
                      }
                      AbstractClass <|-- ConcreteClass1
                      AbstractClass <|-- ConcreteClass2
                      note for AbstractClass "Methods with * must be implemented by child classes"
                </div>
            </div>
            
            <h3>Key Characteristics of Abstract Classes</h3>
            
            <div class="feature-list">
                <div class="feature">
                    <h4>Cannot Be Instantiated</h4>
                    <p>Abstract classes cannot be directly instantiated with the <code>new</code> keyword. They are meant to be extended by child classes.</p>
                    <pre><code>
// This will cause a fatal error
$abstract = new AbstractClass(); // Error!
                    </code></pre>
                </div>
                
                <div class="feature">
                    <h4>Can Contain Abstract Methods</h4>
                    <p>Abstract classes can declare abstract methods—methods without an implementation that must be defined by any non-abstract child class.</p>
                    <pre><code>
abstract class Shape {
    // Abstract method - no implementation
    abstract public function calculateArea();
}
                    </code></pre>
                </div>
                
                <div class="feature">
                    <h4>Can Contain Concrete Methods</h4>
                    <p>Unlike interfaces, abstract classes can contain fully implemented (concrete) methods, providing common functionality to all child classes.</p>
                    <pre><code>
abstract class Shape {
    // Concrete method with implementation
    public function getDescription() {
        return "This is a " . $this->getName() . " shape.";
    }
    
    // Abstract method
    abstract public function getName();
}
                    </code></pre>
                </div>
                
                <div class="feature">
                    <h4>Can Contain Properties</h4>
                    <p>Abstract classes can define properties (member variables) that child classes will inherit.</p>
                    <pre><code>
abstract class Shape {
    protected $color;
    
    public function setColor($color) {
        $this->color = $color;
    }
    
    public function getColor() {
        return $this->color;
    }
}
                    </code></pre>
                </div>
                
                <div class="feature">
                    <h4>Can Declare Constructor Methods</h4>
                    <p>Abstract classes can have constructor methods that child classes can call with <code>parent::__construct()</code>.</p>
                    <pre><code>
abstract class Vehicle {
    protected $make;
    protected $model;
    
    public function __construct($make, $model) {
        $this->make = $make;
        $this->model = $model;
    }
}
                    </code></pre>
                </div>
            </div>
            
            <div class="analogy">
                <h3>The Restaurant Menu Analogy</h3>
                <p>Think of an abstract class as a restaurant franchise template:</p>
                <ul>
                    <li>The franchise headquarters creates a menu template (abstract class) with certain required dishes (abstract methods) that every franchise location must serve.</li>
                    <li>The template also includes standard recipes (concrete methods) that all locations will use exactly as specified.</li>
                    <li>You can't open a "template restaurant" (instantiate the abstract class), but you can open franchise locations (concrete child classes) that implement the required dishes while using the standard recipes.</li>
                    <li>Each location (child class) must provide its own implementation of the required dishes (abstract methods) based on local tastes and ingredients, but all locations share the same core identity and standards.</li>
                </ul>
            </div>
        </section>

        <section id="abstract-classes-syntax">
            <h2>Abstract Class Syntax and Structure</h2>
            
            <p>Creating and working with abstract classes in PHP follows a specific syntax. Let's explore the structure of abstract classes and how to use them effectively.</p>
            
            <div class="code-example">
                <h3>Basic Abstract Class Syntax</h3>
                <pre><code>
abstract class AbstractClassName {
    // Properties
    protected $property1;
    private $property2;
    public $property3;
    
    // Constructor
    public function __construct($param1, $param2) {
        $this->property1 = $param1;
        $this->property2 = $param2;
    }
    
    // Concrete method with implementation
    public function concreteMethod() {
        return "This method is already implemented.";
    }
    
    // Abstract method without implementation
    abstract public function abstractMethod($parameter);
    
    // Another abstract method
    abstract protected function anotherAbstractMethod();
}
                </code></pre>
            </div>
            
            <h3>Abstract Method Rules</h3>
            
            <ul>
                <li>Abstract methods can only exist within abstract classes or interfaces</li>
                <li>Abstract methods cannot have an implementation (no method body)</li>
                <li>Abstract methods end with a semicolon instead of curly braces</li>
                <li>Abstract methods must specify access modifier (public, protected, or private)</li>
                <li>When a child class implements an abstract method, it must maintain the same or a less restrictive visibility</li>
                <li>The child implementation must match or have compatible parameter types and count</li>
            </ul>
            
            <div class="code-example">
                <h3>Extending an Abstract Class</h3>
                <pre><code>
// Abstract parent class
abstract class Animal {
    protected $name;
    
    public function __construct($name) {
        $this->name = $name;
    }
    
    // Concrete method
    public function getName() {
        return $this->name;
    }
    
    // Abstract methods - must be implemented by child classes
    abstract public function makeSound();
    abstract protected function move();
}

// Concrete child class
class Dog extends Animal {
    private $breed;
    
    public function __construct($name, $breed) {
        parent::__construct($name);
        $this->breed = $breed;
    }
    
    // Implementing required abstract methods
    public function makeSound() {
        return "Woof! Woof!";
    }
    
    // Note: We can change from protected to public (less restrictive)
    public function move() {
        return "{$this->name} runs on four legs.";
    }
    
    // Additional method specific to Dog
    public function getBreed() {
        return $this->breed;
    }
}

// Usage
$dog = new Dog("Rex", "German Shepherd");
echo $dog->getName(); // "Rex"
echo $dog->makeSound(); // "Woof! Woof!"
echo $dog->move(); // "Rex runs on four legs."
echo $dog->getBreed(); // "German Shepherd"

// This would cause an error
// $animal = new Animal("Generic Animal"); // Error: Cannot instantiate abstract class
                </code></pre>
            </div>
            
            <h3>Multiple Levels of Inheritance with Abstract Classes</h3>
            
            <p>Abstract classes can extend other abstract classes, creating a chain of inheritance where each level can add its own abstract and concrete methods.</p>
            
            <div class="diagram">
                <h3>Multi-level Abstract Inheritance</h3>
                <div class="mermaid">
                    classDiagram
                      class BaseAbstract {
                        <<abstract>>
                        +baseMethod()
                        +abstractBase()*
                      }
                      class MiddleAbstract {
                        <<abstract>>
                        +middleMethod()
                        +abstractBase()
                        +abstractMiddle()*
                      }
                      class ConcreteClass {
                        +baseMethod()
                        +middleMethod()
                        +abstractBase()
                        +abstractMiddle()
                        +concreteMethod()
                      }
                      BaseAbstract <|-- MiddleAbstract
                      MiddleAbstract <|-- ConcreteClass
                </div>
            </div>
            
            <div class="code-example">
                <h3>Multi-level Abstract Class Example</h3>
                <pre><code>
// Base abstract class
abstract class DatabaseConnection {
    protected $host;
    protected $username;
    protected $password;
    protected $connection;
    
    public function __construct($host, $username, $password) {
        $this->host = $host;
        $this->username = $username;
        $this->password = $password;
    }
    
    // Some shared functionality
    public function disconnect() {
        $this->connection = null;
        return "Disconnected from database.";
    }
    
    // Abstract methods
    abstract public function connect();
    abstract public function query($sql);
}

// Middle abstract class
abstract class RelationalDatabaseConnection extends DatabaseConnection {
    protected $database;
    
    public function __construct($host, $username, $password, $database) {
        parent::__construct($host, $username, $password);
        $this->database = $database;
    }
    
    // Implement some of the parent abstract methods
    public function connect() {
        return "Connecting to relational database at {$this->host}...";
    }
    
    // Add new abstract methods
    abstract public function prepareStatement($sql);
    abstract public function transaction($callback);
}

// Concrete implementation
class MySQLConnection extends RelationalDatabaseConnection {
    private $port;
    
    public function __construct($host, $username, $password, $database, $port = 3306) {
        parent::__construct($host, $username, $password, $database);
        $this->port = $port;
    }
    
    // Implement remaining abstract methods
    public function query($sql) {
        return "Executing MySQL query: {$sql}";
    }
    
    public function prepareStatement($sql) {
        return "Preparing MySQL statement: {$sql}";
    }
    
    public function transaction($callback) {
        echo "Starting MySQL transaction...<br>";
        $callback($this);
        echo "Committing MySQL transaction...<br>";
    }
    
    // Additional MySQL-specific method
    public function mysqlSpecificFunction() {
        return "This is a MySQL-specific function.";
    }
}

// Usage
$mysql = new MySQLConnection("localhost", "root", "password", "mydatabase");
echo $mysql->connect(); // "Connecting to relational database at localhost..."
echo $mysql->query("SELECT * FROM users"); // "Executing MySQL query: SELECT * FROM users"
                </code></pre>
            </div>
        </section>

        <section id="abstract-class-vs-interface">
            <h2>Abstract Classes vs. Interfaces</h2>
            
            <p>One of the most common questions in OOP is when to use an abstract class versus an interface. Both provide a way to define a contract that implementers must follow, but they have important differences.</p>
            
            <div class="comparison-table">
                <h3>Comparing Abstract Classes and Interfaces</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Abstract Class</th>
                            <th>Interface</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Instantiation</td>
                            <td>Cannot be instantiated</td>
                            <td>Cannot be instantiated</td>
                        </tr>
                        <tr>
                            <td>Method implementation</td>
                            <td>Can contain both concrete and abstract methods</td>
                            <td>Can only contain method signatures (PHP 8.0+ allows default method implementations)</td>
                        </tr>
                        <tr>
                            <td>Properties</td>
                            <td>Can contain properties with any visibility</td>
                            <td>Can only contain public constants (no variables)</td>
                        </tr>
                        <tr>
                            <td>Constructor</td>
                            <td>Can have a constructor</td>
                            <td>Cannot have a constructor</td>
                        </tr>
                        <tr>
                            <td>Inheritance</td>
                            <td>Single inheritance only (can extend one class)</td>
                            <td>Multiple inheritance (can implement many interfaces)</td>
                        </tr>
                        <tr>
                            <td>Access modifiers</td>
                            <td>Can use public, protected, and private</td>
                            <td>All methods are implicitly public</td>
                        </tr>
                        <tr>
                            <td>Use case</td>
                            <td>"Is-a" relationship with shared implementation</td>
                            <td>"Can-do" relationship (capability contract)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="code-example">
                <h3>Abstract Class vs. Interface Example</h3>
                <pre><code>
// Abstract class approach
abstract class PaymentProcessor {
    protected $merchantId;
    protected $apiKey;
    
    public function __construct($merchantId, $apiKey) {
        $this->merchantId = $merchantId;
        $this->apiKey = $apiKey;
    }
    
    // Shared implementation
    public function validateAmount($amount) {
        if ($amount <= 0) {
            throw new Exception("Payment amount must be positive");
        }
    }
    
    // Abstract methods
    abstract public function processPayment($amount, $currency, $description);
    abstract public function refundPayment($transactionId, $amount);
}

// Interface approach
interface PaymentGateway {
    // Only method signatures, no implementation
    public function processPayment($amount, $currency, $description);
    public function refundPayment($transactionId, $amount);
    public function validateTransaction($transactionData);
}

// Using abstract class
class StripeProcessor extends PaymentProcessor {
    private $stripeClient;
    
    public function __construct($merchantId, $apiKey) {
        parent::__construct($merchantId, $apiKey);
        $this->stripeClient = "Initialized Stripe client with {$apiKey}";
    }
    
    public function processPayment($amount, $currency, $description) {
        $this->validateAmount($amount); // Using parent method
        return "Processing {$currency} {$amount} payment via Stripe for: {$description}";
    }
    
    public function refundPayment($transactionId, $amount) {
        return "Refunding {$amount} for transaction {$transactionId} via Stripe";
    }
}

// Using interface
class PayPalGateway implements PaymentGateway {
    private $clientId;
    private $secret;
    
    public function __construct($clientId, $secret) {
        $this->clientId = $clientId;
        $this->secret = $secret;
    }
    
    public function processPayment($amount, $currency, $description) {
        return "Processing {$currency} {$amount} payment via PayPal for: {$description}";
    }
    
    public function refundPayment($transactionId, $amount) {
        return "Refunding {$amount} for transaction {$transactionId} via PayPal";
    }
    
    public function validateTransaction($transactionData) {
        return "Validating PayPal transaction: " . json_encode($transactionData);
    }
}
                </code></pre>
            </div>
            
            <h3>When to Use Abstract Classes vs. Interfaces</h3>
            
            <div class="decision-guide">
                <h4>Use Abstract Classes When:</h4>
                <ul>
                    <li>You want to share code among related classes (common implementation)</li>
                    <li>The classes that extend your abstract class have many common methods or fields</li>
                    <li>You need to declare non-public members (protected/private methods or properties)</li>
                    <li>You need constructor logic in the base type</li>
                    <li>You're building a framework with base functionality that will be customized</li>
                    <li>You have an "is-a" relationship that shares behavior</li>
                </ul>
                
                <h4>Use Interfaces When:</h4>
                <ul>
                    <li>You expect unrelated classes to implement your interface</li>
                    <li>You want to specify a behavior but not its implementation</li>
                    <li>You need multiple inheritance (a class can implement multiple interfaces)</li>
                    <li>You're defining a contract for a plugin system or API</li>
                    <li>You have a "can-do" relationship (capability) rather than an "is-a" relationship</li>
                </ul>
            </div>
            
            <div class="pro-tip">
                <h4>Best of Both Worlds: Using Interfaces and Abstract Classes Together</h4>
                <p>Many robust designs use both abstract classes and interfaces together. An abstract class can implement interfaces, providing a partial implementation for its child classes.</p>
                <div class="code-example">
                    <pre><code>
// Define a capability interface
interface Loggable {
    public function log($message);
    public function getLogHistory();
}

// Abstract class that implements an interface
abstract class AbstractLogger implements Loggable {
    protected $logHistory = [];
    
    // Implement one interface method
    public function getLogHistory() {
        return $this->logHistory;
    }
    
    // Leave the other interface method abstract
    abstract public function log($message);
    
    // Add helper method for child classes
    protected function formatLogMessage($message) {
        return date('Y-m-d H:i:s') . ": " . $message;
    }
}

// Concrete implementation
class FileLogger extends AbstractLogger {
    private $logFile;
    
    public function __construct($logFile) {
        $this->logFile = $logFile;
    }
    
    // Implement the remaining abstract method
    public function log($message) {
        $formattedMessage = $this->formatLogMessage($message);
        $this->logHistory[] = $formattedMessage;
        
        // Log to file (simulated)
        echo "Writing to log file: {$formattedMessage}<br>";
    }
}
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="real-world-examples">
            <h2>Abstract Classes in the Real World</h2>
            
            <h3>Example 1: WordPress Widget Framework</h3>
            
            <p>WordPress uses an abstract class for its widget framework. The <code>WP_Widget</code> abstract class provides base functionality for all widget types while requiring specific implementations for widget rendering and form handling.</p>
            
            <div class="code-example">
                <h4>WordPress Widget Abstract Class (Simplified)</h4>
                <pre><code>
// Simplified version of WordPress's WP_Widget abstract class
abstract class WP_Widget {
    public $id_base;
    public $name;
    public $widget_options;
    public $control_options;
    
    public function __construct($id_base, $name, $widget_options = [], $control_options = []) {
        $this->id_base = $id_base;
        $this->name = $name;
        $this->widget_options = $widget_options;
        $this->control_options = $control_options;
        
        // Registration would happen here in the real implementation
    }
    
    // Concrete method shared by all widgets
    public function get_field_id($field_name) {
        return 'widget-' . $this->id_base . '-' . $field_name;
    }
    
    public function get_field_name($field_name) {
        return 'widget-' . $this->id_base . '[' . $field_name . ']';
    }
    
    // Abstract methods that must be implemented by widget classes
    abstract public function widget($args, $instance);
    abstract public function form($instance);
    
    // Method with default implementation that can be overridden
    public function update($new_instance, $old_instance) {
        return $new_instance;
    }
}

// Custom widget implementation
class Latest_Posts_Widget extends WP_Widget {
    public function __construct() {
        parent::__construct(
            'latest_posts',                          // Base ID
            'Latest Posts Widget',                   // Name
            ['description' => 'Shows recent posts']  // Args
        );
    }
    
    // Implement required widget display method
    public function widget($args, $instance) {
        $title = !empty($instance['title']) ? $instance['title'] : 'Latest Posts';
        $number = !empty($instance['number']) ? (int) $instance['number'] : 5;
        
        echo $args['before_widget'];
        echo $args['before_title'] . $title . $args['after_title'];
        
        // Widget content output
        echo "&lt;ul&gt;";
        for ($i = 1; $i <= $number; $i++) {
            echo "&lt;li&gt;Post {$i} Title&lt;/li&gt;";
        }
        echo "&lt;/ul&gt;";
        
        echo $args['after_widget'];
    }
    
    // Implement required settings form method
    public function form($instance) {
        $title = !empty($instance['title']) ? $instance['title'] : 'Latest Posts';
        $number = !empty($instance['number']) ? (int) $instance['number'] : 5;
        
        // Output form fields
        echo '&lt;p&gt;';
        echo '&lt;label for="' . $this->get_field_id('title') . '"&gt;Title:&lt;/label&gt;';
        echo '&lt;input class="widefat" id="' . $this->get_field_id('title') . '" name="' . $this->get_field_name('title') . '" type="text" value="' . esc_attr($title) . '"&gt;';
        echo '&lt;/p&gt;';
        
        echo '&lt;p&gt;';
        echo '&lt;label for="' . $this->get_field_id('number') . '"&gt;Number of posts:&lt;/label&gt;';
        echo '&lt;input class="tiny-text" id="' . $this->get_field_id('number') . '" name="' . $this->get_field_name('number') . '" type="number" step="1" min="1" value="' . esc_attr($number) . '" size="3"&gt;';
        echo '&lt;/p&gt;';
    }
    
    // Override update method with custom sanitization
    public function update($new_instance, $old_instance) {
        $instance = [];
        $instance['title'] = (!empty($new_instance['title'])) ? sanitize_text_field($new_instance['title']) : '';
        $instance['number'] = (!empty($new_instance['number'])) ? (int) $new_instance['number'] : 5;
        
        return $instance;
    }
}
                </code></pre>
            </div>
            
            <h3>Example 2: Database Abstraction Layer</h3>
            
            <p>Database abstraction layers often use abstract classes to provide a common interface for different database systems while allowing system-specific implementations.</p>
            
            <div class="code-example">
                <h4>Database Abstraction Layer Example</h4>
                <pre><code>
abstract class Database {
    protected $connection;
    protected $config;
    protected $lastQuery;
    
    public function __construct(array $config) {
        $this->config = $config;
    }
    
    // Concrete methods shared by all database adapters
    public function getLastQuery() {
        return $this->lastQuery;
    }
    
    public function escape($value) {
        if (is_string($value)) {
            return "'" . addslashes($value) . "'";
        } elseif (is_bool($value)) {
            return $value ? 1 : 0;
        } elseif (is_null($value)) {
            return 'NULL';
        }
        
        return $value;
    }
    
    // Template method that uses abstract methods
    public function select($table, $columns = '*', $where = null, $orderBy = null, $limit = null) {
        $query = "SELECT {$columns} FROM {$table}";
        
        if ($where) {
            $query .= " WHERE {$where}";
        }
        
        if ($orderBy) {
            $query .= " ORDER BY {$orderBy}";
        }
        
        if ($limit) {
            $query .= " LIMIT {$limit}";
        }
        
        return $this->query($query);
    }
    
    // Abstract methods that must be implemented by specific database adapters
    abstract public function connect();
    abstract public function disconnect();
    abstract public function query($sql);
    abstract public function fetchArray($result);
    abstract public function numRows($result);
    abstract public function getError();
}

// MySQL implementation
class MySQLDatabase extends Database {
    public function connect() {
        $host = $this->config['host'] ?? 'localhost';
        $user = $this->config['user'] ?? 'root';
        $pass = $this->config['pass'] ?? '';
        $name = $this->config['name'] ?? '';
        
        // This would use real mysqli functions in a real implementation
        echo "Connecting to MySQL database {$name} on {$host}&lt;br&gt;";
        $this->connection = "MySQL connection";
        
        return true;
    }
    
    public function disconnect() {
        echo "Disconnecting from MySQL database&lt;br&gt;";
        $this->connection = null;
        
        return true;
    }
    
    public function query($sql) {
        $this->lastQuery = $sql;
        echo "Executing MySQL query: {$sql}&lt;br&gt;";
        
        return "MySQL result";
    }
    
    public function fetchArray($result) {
        return ["id" => 1, "name" => "Example"];
    }
    
    public function numRows($result) {
        return 1;
    }
    
    public function getError() {
        return "MySQL error message";
    }
}

// PostgreSQL implementation
class PostgreSQLDatabase extends Database {
    public function connect() {
        $host = $this->config['host'] ?? 'localhost';
        $user = $this->config['user'] ?? 'postgres';
        $pass = $this->config['pass'] ?? '';
        $name = $this->config['name'] ?? '';
        
        echo "Connecting to PostgreSQL database {$name} on {$host}&lt;br&gt;";
        $this->connection = "PostgreSQL connection";
        
        return true;
    }
    
    public function disconnect() {
        echo "Disconnecting from PostgreSQL database&lt;br&gt;";
        $this->connection = null;
        
        return true;
    }
    
    public function query($sql) {
        $this->lastQuery = $sql;
        echo "Executing PostgreSQL query: {$sql}&lt;br&gt;";
        
        return "PostgreSQL result";
    }
    
    public function fetchArray($result) {
        return ["id" => 1, "name" => "Example"];
    }
    
    public function numRows($result) {
        return 1;
    }
    
    public function getError() {
        return "PostgreSQL error message";
    }
}

// Usage
$mysqlConfig = [
    'host' => 'localhost',
    'user' => 'root',
    'pass' => 'password',
    'name' => 'my_database'
];

$mysql = new MySQLDatabase($mysqlConfig);
$mysql->connect();
$result = $mysql->select('users', '*', 'age > 21', 'lastname ASC', 10);
                </code></pre>
            </div>
            
            <h3>Example 3: Template Method Design Pattern</h3>
            
            <p>The Template Method pattern is a common use case for abstract classes. It defines the skeleton of an algorithm but allows subclasses to override specific steps.</p>
            
            <div class="code-example">
                <h4>Report Generator Example</h4>
                <pre><code>
abstract class ReportGenerator {
    // Template method that defines the report generation algorithm
    public function generateReport($data) {
        // Step 1: Validate the data
        $this->validateData($data);
        
        // Step 2: Process the data (abstract - must be implemented by children)
        $processedData = $this->processData($data);
        
        // Step 3: Format the report (abstract - must be implemented by children)
        $report = $this->formatReport($processedData);
        
        // Step 4: Add headers and footers
        $report = $this->addHeadersAndFooters($report);
        
        // Step 5: Deliver the report
        $this->deliverReport($report);
        
        return $report;
    }
    
    // Concrete method - shared implementation
    protected function validateData($data) {
        if (empty($data)) {
            throw new Exception("Report data cannot be empty");
        }
    }
    
    // Concrete method with default implementation
    protected function addHeadersAndFooters($report) {
        $date = date('Y-m-d');
        $header = "=== REPORT GENERATED ON {$date} ===\n\n";
        $footer = "\n\n=== END OF REPORT ===";
        
        return $header . $report . $footer;
    }
    
    // Hook method with default implementation that can be overridden
    protected function deliverReport($report) {
        echo "Report generated successfully.&lt;br&gt;";
    }
    
    // Abstract methods - must be implemented by child classes
    abstract protected function processData($data);
    abstract protected function formatReport($processedData);
}

// PDF Report implementation
class PDFReportGenerator extends ReportGenerator {
    protected function processData($data) {
        echo "Processing data for PDF report...&lt;br&gt;";
        
        // Convert to uppercase for demonstration
        $result = [];
        foreach ($data as $key => $value) {
            if (is_string($value)) {
                $result[$key] = strtoupper($value);
            } else {
                $result[$key] = $value;
            }
        }
        
        return $result;
    }
    
    protected function formatReport($processedData) {
        echo "Formatting data as PDF...&lt;br&gt;";
        
        // In a real implementation, this would create a PDF
        $report = "PDF REPORT\n\n";
        foreach ($processedData as $key => $value) {
            $report .= "{$key}: {$value}\n";
        }
        
        return $report;
    }
    
    // Override the hook method
    protected function deliverReport($report) {
        parent::deliverReport($report);
        echo "PDF report saved to disk.&lt;br&gt;";
    }
}

// CSV Report implementation
class CSVReportGenerator extends ReportGenerator {
    protected function processData($data) {
        echo "Processing data for CSV report...&lt;br&gt;";
        return $data; // No special processing needed
    }
    
    protected function formatReport($processedData) {
        echo "Formatting data as CSV...&lt;br&gt;";
        
        // Create CSV format
        $headers = array_keys($processedData);
        $values = array_values($processedData);
        
        $report = implode(",", $headers) . "\n";
        $report .= implode(",", $values);
        
        return $report;
    }
    
    // Override the hook method
    protected function deliverReport($report) {
        parent::deliverReport($report);
        echo "CSV report emailed to recipients.&lt;br&gt;";
    }
    
    // Override the headers and footers for CSV format
    protected function addHeadersAndFooters($report) {
        // CSV doesn't need headers and footers
        return $report;
    }
}

// Usage
$data = [
    'title' => 'Monthly Sales',
    'period' => 'January 2025',
    'total_sales' => 125000,
    'top_product' => 'Widget Pro'
];

echo "&lt;h4&gt;Generating PDF Report:&lt;/h4&gt;";
$pdfGenerator = new PDFReportGenerator();
$pdfReport = $pdfGenerator->generateReport($data);
echo "&lt;pre&gt;{$pdfReport}&lt;/pre&gt;";

echo "&lt;h4&gt;Generating CSV Report:&lt;/h4&gt;";
$csvGenerator = new CSVReportGenerator();
$csvReport = $csvGenerator->generateReport($data);
echo "&lt;pre&gt;{$csvReport}&lt;/pre&gt;";
                </code></pre>
            </div>
        </section>

        <section id="wordpress-examples">
            <h2>Abstract Classes in WordPress Development</h2>
            
            <p>WordPress core and many popular plugins make extensive use of abstract classes. Understanding these patterns will help you create more professional WordPress extensions.</p>
            
            <h3>WordPress REST API Controllers</h3>
            
            <p>The WordPress REST API uses abstract classes to define the structure of controller classes for different resources.</p>
            
            <div class="code-example">
                <h4>WordPress REST Controller Example</h4>
                <pre><code>
// Simplified version of WP_REST_Controller abstract class
abstract class WP_REST_Controller {
    // The namespace of this controller's route
    protected $namespace;
    
    // The base of this controller's route
    protected $rest_base;
    
    // Register the routes for the objects of the controller
    public function register_routes() {
        // To be implemented by child classes
    }
    
    // Prepare the item for the REST response
    public function prepare_item_for_response($item, $request) {
        // To be implemented by child classes
    }
    
    // Get a collection of items
    public function get_items($request) {
        // Default implementation - can be overridden
        return new WP_Error(
            'invalid-method',
            'Method not implemented',
            ['status' => 405]
        );
    }
    
    // Get one item from the collection
    public function get_item($request) {
        // Default implementation - can be overridden
        return new WP_Error(
            'invalid-method',
            'Method not implemented',
            ['status' => 405]
        );
    }
    
    // Create one item from the collection
    public function create_item($request) {
        // Default implementation - can be overridden
        return new WP_Error(
            'invalid-method',
            'Method not implemented',
            ['status' => 405]
        );
    }
    
    // Delete one item from the collection
    public function delete_item($request) {
        // Default implementation - can be overridden
        return new WP_Error(
            'invalid-method',
            'Method not implemented',
            ['status' => 405]
        );
    }
}

// Custom implementation for Product REST API
class WC_REST_Products_Controller extends WP_REST_Controller {
    public function __construct() {
        $this->namespace = 'wc/v3';
        $this->rest_base = 'products';
    }
    
    // Register our routes
    public function register_routes() {
        register_rest_route($this->namespace, '/' . $this->rest_base, [
            [
                'methods'             => 'GET',
                'callback'            => [$this, 'get_items'],
                'permission_callback' => [$this, 'get_items_permissions_check'],
            ],
            [
                'methods'             => 'POST',
                'callback'            => [$this, 'create_item'],
                'permission_callback' => [$this, 'create_item_permissions_check'],
            ],
        ]);
        
        register_rest_route($this->namespace, '/' . $this->rest_base . '/(?P<id>[\d]+)', [
            [
                'methods'             => 'GET',
                'callback'            => [$this, 'get_item'],
                'permission_callback' => [$this, 'get_item_permissions_check'],
            ],
            [
                'methods'             => 'DELETE',
                'callback'            => [$this, 'delete_item'],
                'permission_callback' => [$this, 'delete_item_permissions_check'],
            ],
        ]);
    }
    
    // Get a collection of items
    public function get_items($request) {
        // Actual implementation would fetch products
        return [
            'status' => 'success',
            'products' => [
                ['id' => 1, 'name' => 'Product 1', 'price' => 19.99],
                ['id' => 2, 'name' => 'Product 2', 'price' => 29.99],
            ]
        ];
    }
    
    // Check if a given request has access to get items
    public function get_items_permissions_check($request) {
        return true; // Public access in this example
    }
    
    // Get one item from the collection
    public function get_item($request) {
        $id = (int) $request['id'];
        
        // Actual implementation would fetch a specific product
        return [
            'status' => 'success',
            'product' => ['id' => $id, 'name' => "Product {$id}", 'price' => 19.99],
        ];
    }
    
    // Prepare the item for the REST response
    public function prepare_item_for_response($product, $request) {
        $data = [
            'id'          => $product->id,
            'name'        => $product->name,
            'price'       => $product->price,
            'description' => $product->description,
            'status'      => $product->status,
        ];
        
        return $data;
    }
}
                </code></pre>
            </div>
            
            <h3>The WordPress Admin Settings API</h3>
            
            <p>Creating an abstract class for admin pages can help standardize your plugin's admin interface while allowing for customization.</p>
            
            <div class="code-example">
                <h4>Custom Admin Page Abstract Class</h4>
                <pre><code>
abstract class Abstract_Admin_Page {
    protected $page_title;
    protected $menu_title;
    protected $capability;
    protected $menu_slug;
    protected $icon;
    protected $position;
    
    public function __construct($page_title, $menu_title, $capability, $menu_slug, $icon = '', $position = null) {
        $this->page_title = $page_title;
        $this->menu_title = $menu_title;
        $this->capability = $capability;
        $this->menu_slug = $menu_slug;
        $this->icon = $icon;
        $this->position = $position;
        
        add_action('admin_menu', [$this, 'add_menu_page']);
        add_action('admin_init', [$this, 'register_settings']);
    }
    
    // Add the menu page to the WordPress admin
    public function add_menu_page() {
        add_menu_page(
            $this->page_title,
            $this->menu_title,
            $this->capability,
            $this->menu_slug,
            [$this, 'render_page'],
            $this->icon,
            $this->position
        );
    }
    
    // Concrete method with common page wrapper
    public function render_page() {
        echo '&lt;div class="wrap"&gt;';
        echo '&lt;h1&gt;' . esc_html($this->page_title) . '&lt;/h1&gt;';
        
        echo '&lt;form method="post" action="options.php"&gt;';
        settings_fields($this->menu_slug);
        do_settings_sections($this->menu_slug);
        submit_button();
        echo '&lt;/form&gt;';
        
        $this->render_additional_content();
        
        echo '&lt;/div&gt;';
    }
    
    // Hook method - can be overridden
    protected function render_additional_content() {
        // Default empty implementation
    }
    
    // Abstract methods - must be implemented by child classes
    abstract public function register_settings();
}

// Specific settings page implementation
class Plugin_Settings_Page extends Abstract_Admin_Page {
    public function __construct() {
        parent::__construct(
            'My Plugin Settings',          // Page title
            'My Plugin',                   // Menu title
            'manage_options',              // Capability
            'my-plugin-settings',          // Menu slug
            'dashicons-admin-plugins',     // Icon
            100                            // Position
        );
    }
    
    // Implement required abstract method
    public function register_settings() {
        // Register a setting
        register_setting(
            $this->menu_slug,             // Option group
            'my_plugin_options',          // Option name
            [$this, 'sanitize_options']   // Sanitize callback
        );
        
        // Add a section
        add_settings_section(
            'general_section',            // ID
            'General Settings',           // Title
            [$this, 'render_section'],    // Callback
            $this->menu_slug              // Page
        );
        
        // Add fields
        add_settings_field(
            'api_key',                    // ID
            'API Key',                    // Title
            [$this, 'render_api_field'],  // Callback
            $this->menu_slug,             // Page
            'general_section'             // Section
        );
        
        add_settings_field(
            'enable_feature',             // ID
            'Enable Feature',             // Title
            [$this, 'render_checkbox'],   // Callback
            $this->menu_slug,             // Page
            'general_section'             // Section
        );
    }
    
    // Section renderer
    public function render_section() {
        echo '&lt;p&gt;These settings control the general behavior of the plugin.&lt;/p&gt;';
    }
    
    // API field renderer
    public function render_api_field() {
        $options = get_option('my_plugin_options');
        $api_key = isset($options['api_key']) ? $options['api_key'] : '';
        
        echo '&lt;input type="text" name="my_plugin_options[api_key]" value="' . esc_attr($api_key) . '" class="regular-text"&gt;';
    }
    
    // Checkbox renderer
    public function render_checkbox() {
        $options = get_option('my_plugin_options');
        $enabled = isset($options['enable_feature']) ? $options['enable_feature'] : 0;
        
        echo '&lt;input type="checkbox" name="my_plugin_options[enable_feature]" value="1" ' . checked(1, $enabled, false) . '&gt;';
    }
    
    // Sanitize options
    public function sanitize_options($options) {
        $sanitized = [];
        
        if (isset($options['api_key'])) {
            $sanitized['api_key'] = sanitize_text_field($options['api_key']);
        }
        
        if (isset($options['enable_feature'])) {
            $sanitized['enable_feature'] = 1;
        } else {
            $sanitized['enable_feature'] = 0;
        }
        
        return $sanitized;
    }
    
    // Override to add custom content
    protected function render_additional_content() {
        echo '&lt;div class="card"&gt;';
        echo '&lt;h2&gt;Help Information&lt;/h2&gt;';
        echo '&lt;p&gt;Need help? Visit our &lt;a href="#"&gt;documentation&lt;/a&gt; or &lt;a href="#"&gt;contact support&lt;/a&gt;.&lt;/p&gt;';
        echo '&lt;/div&gt;';
    }
}

// Usage
function register_plugin_settings_page() {
    new Plugin_Settings_Page();
}
add_action('plugins_loaded', 'register_plugin_settings_page');
                </code></pre>
            </div>
        </section>

        <section id="abstract-class-best-practices">
            <h2>Best Practices for Abstract Classes</h2>
            
            <div class="best-practices">
                <div class="practice">
                    <h3>Keep the Abstract Interface Minimal</h3>
                    <p>Only make methods abstract when they absolutely must be implemented differently in child classes. If a method has a sensible default implementation, make it concrete with the option to override.</p>
                    <pre><code>
// Good: Only the essential methods are abstract
abstract class EmailSender {
    // Abstract - each provider needs different implementation
    abstract protected function sendEmail($to, $subject, $body);
    
    // Concrete with sensible defaults
    protected function validateEmail($email) {
        return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
    }
    
    // Public API that uses the abstract method
    public function send($to, $subject, $body) {
        if (!$this->validateEmail($to)) {
            throw new Exception("Invalid email address: {$to}");
        }
        
        return $this->sendEmail($to, $subject, $body);
    }
}
                    </code></pre>
                </div>
                
                <div class="practice">
                    <h3>Use Template Method Pattern</h3>
                    <p>The Template Method pattern is a natural fit for abstract classes. Define the skeleton of an algorithm in the parent class, deferring some steps to subclasses.</p>
                    <pre><code>
abstract class DataProcessor {
    // Template method
    public function processData($data) {
        // 1. Validate data (concrete)
        $this->validateData($data);
        
        // 2. Transform data (abstract - implemented by child)
        $transformedData = $this->transformData($data);
        
        // 3. Store data (abstract - implemented by child)
        $this->storeData($transformedData);
        
        // 4. Log completion (concrete)
        $this->logCompletion();
        
        return $transformedData;
    }
    
    // Concrete methods
    protected function validateData($data) {
        if (empty($data)) {
            throw new Exception("Data cannot be empty");
        }
    }
    
    protected function logCompletion() {
        echo "Data processing completed at " . date('Y-m-d H:i:s');
    }
    
    // Abstract methods
    abstract protected function transformData($data);
    abstract protected function storeData($data);
}
                    </code></pre>
                </div>
                
                <div class="practice">
                    <h3>Provide Constructors for Common Initialization</h3>
                    <p>Use constructors in abstract classes to handle common initialization code that all child classes need.</p>
                    <pre><code>
abstract class ApiClient {
    protected $apiKey;
    protected $baseUrl;
    protected $timeout;
    
    public function __construct($apiKey, $baseUrl, $timeout = 30) {
        $this->apiKey = $apiKey;
        $this->baseUrl = $baseUrl;
        $this->timeout = $timeout;
        
        // Common initialization
        $this->validateCredentials();
    }
    
    protected function validateCredentials() {
        if (empty($this->apiKey)) {
            throw new Exception("API key is required");
        }
        
        if (empty($this->baseUrl)) {
            throw new Exception("Base URL is required");
        }
    }
    
    abstract public function request($endpoint, $method, $data = []);
}
                    </code></pre>
                </div>
                
                <div class="practice">
                    <h3>Use Class Constants for Configuration</h3>
                    <p>Abstract classes can define constants that child classes can use for configuration without overriding.</p>
                    <pre><code>
abstract class Logger {
    // Log levels
    const LEVEL_INFO = 'info';
    const LEVEL_WARNING = 'warning';
    const LEVEL_ERROR = 'error';
    const LEVEL_DEBUG = 'debug';
    
    // Date format
    const DATE_FORMAT = 'Y-m-d H:i:s';
    
    protected $minimumLevel;
    
    public function __construct($minimumLevel = self::LEVEL_INFO) {
        $this->minimumLevel = $minimumLevel;
    }
    
    // Abstract method for actual logging
    abstract protected function write($message, $level);
    
    // Level-specific logging methods
    public function info($message) {
        if ($this->shouldLog(self::LEVEL_INFO)) {
            $this->write($message, self::LEVEL_INFO);
        }
    }
    
    public function warning($message) {
        if ($this->shouldLog(self::LEVEL_WARNING)) {
            $this->write($message, self::LEVEL_WARNING);
        }
    }
    
    public function error($message) {
        if ($this->shouldLog(self::LEVEL_ERROR)) {
            $this->write($message, self::LEVEL_ERROR);
        }
    }
    
    public function debug($message) {
        if ($this->shouldLog(self::LEVEL_DEBUG)) {
            $this->write($message, self::LEVEL_DEBUG);
        }
    }
    
    // Helper method
    protected function shouldLog($level) {
        // Log levels hierarchy: debug < info < warning < error
        $levels = [
            self::LEVEL_DEBUG => 0,
            self::LEVEL_INFO => 1,
            self::LEVEL_WARNING => 2,
            self::LEVEL_ERROR => 3
        ];
        
        return $levels[$level] >= $levels[$this->minimumLevel];
    }
}
                    </code></pre>
                </div>
                
                <div class="practice">
                    <h3>Document Abstract Methods Thoroughly</h3>
                    <p>Abstract methods should have thorough PHPDoc comments to guide implementers on what the method should do and return.</p>
                    <pre><code>
abstract class PaymentProcessor {
    /**
     * Process a payment transaction.
     *
     * @param float $amount The payment amount
     * @param string $currency The currency code (e.g., 'USD', 'EUR')
     * @param array $customerData Customer information including:
     *    'name' => (string) Customer name
     *    'email' => (string) Customer email
     *    'address' => (array) Customer address fields
     * @param array $paymentData Payment method details
     * 
     * @return array Transaction result containing:
     *    'success' => (bool) Whether the transaction succeeded
     *    'transaction_id' => (string) Provider transaction ID if successful
     *    'error_code' => (string|null) Error code if failed
     *    'error_message' => (string|null) Error message if failed
     * 
     * @throws PaymentException If there's an error connecting to the payment provider
     */
    abstract public function processPayment($amount, $currency, array $customerData, array $paymentData);
}
                    </code></pre>
                </div>
                
                <div class="practice">
                    <h3>Use Protected Instead of Private for Extensibility</h3>
                    <p>Use protected visibility for properties and methods that child classes may need to access or override. Private members aren't available to child classes.</p>
                    <pre><code>
abstract class FormValidator {
    // Protected - available to child classes
    protected $errors = [];
    protected $data;
    
    // Private - only available to this class
    private $initialized = false;
    
    public function __construct($data) {
        $this->data = $data;
        $this->initialized = true;
    }
    
    public function validate() {
        $this->errors = [];
        $this->validateCommonRules();
        $this->validateSpecificRules();
        
        return empty($this->errors);
    }
    
    // Protected - can be accessed by child classes
    protected function validateCommonRules() {
        // Validate common fields
        if (empty($this->data['email'])) {
            $this->addError('email', 'Email is required');
        } elseif (!filter_var($this->data['email'], FILTER_VALIDATE_EMAIL)) {
            $this->addError('email', 'Invalid email format');
        }
    }
    
    // Protected - can be used by child classes
    protected function addError($field, $message) {
        $this->errors[$field] = $message;
    }
    
    // Abstract method for specific validation rules
    abstract protected function validateSpecificRules();
    
    // Public API to get errors
    public function getErrors() {
        return $this->errors;
    }
}
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="homework">
            <h2>Homework: Extend Your Previous Class with Abstract Classes</h2>
            
            <div class="assignment">
                <h3>Assignment: Building a Product Framework with Abstract Classes</h3>
                
                <p>For this assignment, you'll refactor the Product class hierarchy from the previous homework to use abstract classes. You'll create an abstract base class that defines the common structure and behavior for different types of products.</p>
                
                <h4>Requirements:</h4>
                <ol>
                    <li>Create an abstract <code>AbstractProduct</code> class with:
                        <ul>
                            <li>Protected properties for name, price, and SKU</li>
                            <li>A constructor that sets these properties</li>
                            <li>Getters and setters for each property</li>
                            <li>At least one concrete method that provides common functionality</li>
                            <li>At least one abstract method that child classes must implement</li>
                        </ul>
                    </li>
                    <li>Create at least two concrete product classes (e.g., <code>PhysicalProduct</code> and <code>DigitalProduct</code>) that extend the abstract class</li>
                    <li>Implement all required abstract methods in each child class</li>
                    <li>Add at least one unique method to each child class that makes sense for its type</li>
                    <li>Create a test script that demonstrates the functionality of your classes</li>
                </ol>
                
                <h4>Starter Code:</h4>
                <pre><code>
/**
 * AbstractProduct serves as the base class for all product types.
 */
abstract class AbstractProduct {
    // Protected properties
    protected $name;
    protected $price;
    protected $sku;
    
    /**
     * Constructor for the AbstractProduct.
     *
     * @param string $name The product name
     * @param float $price The product price
     * @param string $sku The stock keeping unit identifier
     */
    public function __construct($name, $price, $sku) {
        $this->name = $name;
        $this->price = $price;
        $this->sku = $sku;
    }
    
    /**
     * Get the product name.
     *
     * @return string
     */
    public function getName() {
        return $this->name;
    }
    
    /**
     * Set the product name.
     *
     * @param string $name The new product name
     * @return void
     */
    public function setName($name) {
        $this->name = $name;
    }
    
    /**
     * Get the product price.
     *
     * @return float
     */
    public function getPrice() {
        return $this->price;
    }
    
    /**
     * Set the product price.
     *
     * @param float $price The new product price
     * @return void
     */
    public function setPrice($price) {
        $this->price = $price;
    }
    
    /**
     * Get the product SKU.
     *
     * @return string
     */
    public function getSku() {
        return $this->sku;
    }
    
    /**
     * Set the product SKU.
     *
     * @param string $sku The new product SKU
     * @return void
     */
    public function setSku($sku) {
        $this->sku = $sku;
    }
    
    /**
     * Get basic product information as an array.
     *
     * @return array
     */
    public function getBasicInfo() {
        return [
            'name' => $this->name,
            'price' => $this->price,
            'sku' => $this->sku
        ];
    }
    
    /**
     * Format the price with currency symbol.
     *
     * @param string $currencySymbol The currency symbol to use
     * @return string
     */
    public function getFormattedPrice($currencySymbol = '$') {
        return $currencySymbol . number_format($this->price, 2);
    }
    
    /**
     * Calculate the price with tax.
     * This is an abstract method that must be implemented by all child classes,
     * as tax calculation may differ by product type.
     *
     * @param float $taxRate The tax rate to apply
     * @return float
     */
    abstract public function calculatePriceWithTax($taxRate);
    
    /**
     * Get detailed product information.
     * This is an abstract method because different product types will have
     * different types of detailed information.
     *
     * @return array
     */
    abstract public function getDetailedInfo();
}

// TODO: Create PhysicalProduct class extending AbstractProduct

// TODO: Create DigitalProduct class extending AbstractProduct

// Test script
function testProducts() {
    // Create product instances
    $physical = new PhysicalProduct("Coffee Mug", 12.99, "MUG-001", 0.5, ["width" => 10, "height" => 8, "depth" => 10]);
    $digital = new DigitalProduct("E-book: PHP Mastery", 24.99, "EB-001", "PDF", 15.4);
    
    // Test common methods
    echo "&lt;h3&gt;Product Names:&lt;/h3&gt;";
    echo "Physical: " . $physical->getName() . "&lt;br&gt;";
    echo "Digital: " . $digital->getName() . "&lt;br&gt;";
    
    echo "&lt;h3&gt;Formatted Prices:&lt;/h3&gt;";
    echo "Physical: " . $physical->getFormattedPrice() . "&lt;br&gt;";
    echo "Digital: " . $digital->getFormattedPrice('€') . "&lt;br&gt;";
    
    echo "&lt;h3&gt;Prices With Tax:&lt;/h3&gt;";
    echo "Physical with 10% tax: $" . number_format($physical->calculatePriceWithTax(0.1), 2) . "&lt;br&gt;";
    echo "Digital with 5% tax: $" . number_format($digital->calculatePriceWithTax(0.05), 2) . "&lt;br&gt;";
    
    echo "&lt;h3&gt;Basic Info:&lt;/h3&gt;";
    echo "&lt;pre&gt;";
    print_r($physical->getBasicInfo());
    print_r($digital->getBasicInfo());
    echo "&lt;/pre&gt;";
    
    echo "&lt;h3&gt;Detailed Info:&lt;/h3&gt;";
    echo "&lt;pre&gt;";
    print_r($physical->getDetailedInfo());
    print_r($digital->getDetailedInfo());
    echo "&lt;/pre&gt;";
    
    // Test product-specific methods
    echo "&lt;h3&gt;Product-Specific Methods:&lt;/h3&gt;";
    echo "Physical shipping cost: $" . number_format($physical->calculateShippingCost(500), 2) . "&lt;br&gt;";
    echo "Digital download link: " . $digital->getDownloadLink(12345) . "&lt;br&gt;";
}
                </code></pre>
                
                <h4>Bonus Challenges:</h4>
                <ul>
                    <li>Create a third product type (e.g., <code>SubscriptionProduct</code>) with unique properties and behavior</li>
                    <li>Add an abstract <code>save()</code> method that each product implements differently (e.g., saving to database, file, etc.)</li>
                    <li>Create a <code>ProductFactory</code> class that can create different product types based on input</li>
                    <li>Implement the Template Method pattern in the abstract class for a complex operation like "process order"</li>
                </ul>
            </div>
        </section>

        <section class="summary">
            <h2>Key Takeaways</h2>
            
            <div class="takeaways">
                <div class="takeaway">
                    <h3>Purpose of Abstract Classes</h3>
                    <p>Abstract classes provide a way to define a common structure and behavior for related classes while requiring specific implementations for certain methods.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Abstract vs. Concrete Methods</h3>
                    <p>Abstract classes can contain both abstract methods (without implementation) and concrete methods (with implementation), allowing for shared code and required customization.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Class Hierarchy</h3>
                    <p>Abstract classes are ideal for creating class hierarchies where child classes share common properties and methods but need to implement specific behaviors differently.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Abstract vs. Interface</h3>
                    <p>Use abstract classes when you have an "is-a" relationship with shared implementation. Use interfaces when you have a "can-do" relationship or need multiple inheritance.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Template Method Pattern</h3>
                    <p>Abstract classes are perfect for implementing the Template Method pattern, which defines the skeleton of an algorithm but allows subclasses to override specific steps.</p>
                </div>
            </div>
            
            <div class="next-steps">
                <h3>Next Steps</h3>
                <p>Now that you understand abstract classes, we'll continue exploring advanced OOP concepts with interfaces, which provide another way to define contracts between classes. Together, abstract classes and interfaces give you powerful tools for creating flexible, maintainable PHP applications and WordPress extensions.</p>
            </div>
        </section>

        <section class="footer">
            <h2>Feedback and Questions</h2>
            
            <p>If you have any questions or need clarification on abstract classes, feel free to reach out. Your feedback is valuable for improving this course!</p>  
            <p>Happy coding!</p>
        </section>
        
        <section class="resources">
            <h2>Additional Resources</h2>
            
            <ul>
                <li><a href="https://www.php.net/manual/en/language.oop5.abstract.php" target="_blank">PHP Manual: Class Abstraction</a></li>
                <li><a href="https://phptherightway.com/#object-oriented-programming" target="_blank">PHP The Right Way: Object-Oriented Programming</a></li>
                <li><a href="https://developer.wordpress.org/plugins/intro/" target="_blank">WordPress Plugin Developer Handbook</a></li>
                <li><a href="https://refactoring.guru/design-patterns/template-method" target="_blank">Template Method Design Pattern</a></li>
                <li><a href="https://developer.wordpress.org/rest-api/extending-the-rest-api/controller-classes/" target="_blank">WordPress REST API: Controller Classes</a></li>
                <li><a href="https://carlalexander.ca/polymorphism-wordpress-abstract-classes/" target="_blank">Polymorphism and WordPress: Abstract Classes</a></li>
                <li><a href="https://wordpress.stackexchange.com/questions/102752/common-abstract-class-for-plugins" target="_blank">Common Abstract Classes for WordPress Plugins</a></li>
            </ul>
        </section>
    </main>
    
    <footer>
        <p>&copy; 2025 PHP WordPress Development Course</p>

    </footer>
</body>
</html>
