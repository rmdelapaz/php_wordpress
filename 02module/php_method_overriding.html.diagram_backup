<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="ie=edge" http-equiv="X-UA-Compatible"/>
<!-- SEO Meta Tags -->
<title>Method Overriding in PHP: Customizing Inherited Behavior - PHP WordPress Course</title>
<meta content="Welcome to our deep dive into method overriding in PHP! Method overriding is a fundamental concept in object-oriented programming that allows child classes to p" name="description"/>
<meta content="PHP, WordPress, web development, method, overriding" name="keywords"/>
<meta content="PHP WordPress Course" name="author"/>
<!-- Favicon -->
<link href="/favicon.png" rel="icon" type="image/png"/>
<link href="/favicon.png" rel="apple-touch-icon"/>
<!-- CSS -->
<link href="/assets/css/main.css" rel="stylesheet"/><link href="/assets/css/sidebar-enhanced.css" rel="stylesheet"/><link href="/assets/css/sidebar-toggle.css" rel="stylesheet"/>
</head>
<body>
<!-- Skip to main content -->
<a class="sr-only" href="#main-content">Skip to main content</a>
<div class="page-wrapper">
<!-- Header -->
<header class="site-header" role="banner">
<div class="header-container">
<div class="site-branding">
<a class="site-logo" href="/">
<h1 class="site-title">PHP WordPress Development</h1>
</a>
</div>
<nav aria-label="Main navigation" class="main-navigation" role="navigation">
<button aria-expanded="false" aria-label="Toggle navigation" class="mobile-menu-btn">
<span></span>
<span></span>
<span></span>
</button>
<div class="nav-menu">
<ul class="nav-list">
<li class="nav-item"><a class="nav-link" href="/">Home</a></li>
<li class="nav-item dropdown">
<button aria-haspopup="true" class="nav-link dropdown-toggle active">Modules</button>
<div class="dropdown-menu">
<a class="dropdown-item" href="/module1.html">Module 1: Web Fundamentals</a>
<a class="dropdown-item active" href="/module2.html">Module 2: PHP Fundamentals</a>
<a class="dropdown-item" href="/module3.html">Module 3: MySQL Database</a>
<a class="dropdown-item" href="/module4.html">Module 4: WordPress &amp; Docker</a>
<a class="dropdown-item" href="/module5.html">Module 5: Theme Development</a>
<a class="dropdown-item" href="/module6.html">Module 6: Plugin Development</a>
<a class="dropdown-item" href="/module7.html">Module 7: Advanced WordPress</a>
<a class="dropdown-item" href="/module8.html">Module 8: Deployment</a>
<a class="dropdown-item" href="/module9.html">Module 9: Final Project</a>
</div>
</li>
<li class="nav-item"><a class="nav-link" href="/resources.html">Resources</a></li>
<li class="nav-item"><a class="nav-link" href="/about.html">About</a></li>
</ul>
</div>
</nav>
<div class="search-container">
<div class="search-input-wrapper">
<svg class="search-icon" fill="currentColor" height="20" viewbox="0 0 20 20" width="20">
<path clip-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" fill-rule="evenodd"></path>
</svg>
<input aria-label="Search" class="search-input" placeholder="Search lessons..." type="search"/>
</div>
<div class="search-results"></div>
</div>
</div>
</header>
<!-- Progress Bar -->
<div class="progress-container">
<div class="progress-header">
<h2 class="progress-title">Course Progress</h2>
<span class="progress-text">Loading...</span>
</div>
<div class="progress-bar">
<div class="progress-bar-fill">
<span class="progress-bar-text"></span>
</div>
</div>
</div>
<!-- Breadcrumb -->
<nav aria-label="Breadcrumb" class="breadcrumb container">
<ol class="breadcrumb-list">
<li class="breadcrumb-item">
<a href="/">Home</a>
<span class="breadcrumb-separator">/</span>
</li>
<li class="breadcrumb-item">
<a href="/module2.html">Module 2</a>
<span class="breadcrumb-separator">/</span>
</li>
<li class="breadcrumb-item">
<span aria-current="page">Method Overriding</span>
</li>
</ol>
</nav>
<!-- Main Content -->
<main class="main-content" id="main-content" role="main">
<div class="container">
<div class="content-with-sidebar">
<!-- Sidebar -->
<aside class="sidebar">

<div class="sidebar-nav">
<h3 class="sidebar-title">Module 2: PHP Fundamentals</h3>
<div class="sidebar-section">
<h4 class="sidebar-section-title">Session 9</h4>
<ul class="sidebar-menu">
<li><a class="sidebar-link" href="/02module/php_inheritance.html">Inheritance</a></li>
<li class="active"><a class="sidebar-link active" href="/02module/php_method_overriding.html">Method Overriding</a></li>
<li><a class="sidebar-link" href="/02module/php_abstract_classes.html">Abstract Classes</a></li>
<li><a class="sidebar-link" href="/02module/php_interfaces.html">Interfaces</a></li>
<li><a class="sidebar-link" href="/02module/php_namespaces.html">Namespaces</a></li>
<li><a class="sidebar-link" href="/02module/php_traits.html">Traits</a></li>
<li><a class="sidebar-link" href="/02module/homework_php_extend_with_inheritance.html">Homework: Inheritance</a></li>
</ul>
</div>
<div class="sidebar-section">
<h4 class="sidebar-section-title">Quick Links</h4>
<ul class="sidebar-menu">
<li><a class="sidebar-link" href="/module2.html">Module Overview</a></li>
<li><a class="sidebar-link prev-session" href="/02module/php_oop_concepts.html">← Prev: Session 8: OOP Intro</a></li>
<li><a class="sidebar-link next-session" href="/02module/php_planning_php_application.html">Next: Session 10: Project →</a></li>
<li><a class="sidebar-link" href="/module1.html">← Previous Module</a></li>
<li><a class="sidebar-link" href="/module3.html">Next Module →</a></li>
<li><a class="sidebar-link" href="/resources.html">Resources</a></li>
</ul>
</div>
</div></aside>
<!-- Main Lesson Content -->
<article class="lesson-content">
<header class="lesson-header">
<h1>Method Overriding in PHP: Customizing Inherited Behavior</h1>
<div class="lesson-meta">
<div class="lesson-meta-item">
<svg fill="currentColor" height="20" width="20">
<path d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<span>Duration: 30 minutes</span>
</div>
<div class="lesson-meta-item">
<svg fill="currentColor" height="20" width="20">
<path d="M12 14l9-5-9-5-9 5 9 5z"></path>
</svg>
<span>Module 2: Object-Oriented PHP</span>
</div>
</div>
</header>
<!-- Learning Objectives -->
<div class="lesson-objectives">
<h2>Learning Objectives</h2>
<ul>
<li>Master PHP programming concepts</li>
<li>Write clean, maintainable code</li>
<li>Apply best practices</li>
<li>Build dynamic applications</li>
</ul>
</div>
<!-- Lesson Body -->
<div class="lesson-body">
<section class="module-intro">
            <h2>Customizing Inherited Behavior</h2>
            <p>Welcome to our deep dive into method overriding in PHP! Method overriding is a fundamental concept in object-oriented programming that allows child classes to provide specialized implementations of methods that are already defined in their parent classes.</p>
            
            <div class="note">
                <p><strong>Why Method Overriding Matters:</strong> Method overriding is essential for creating flexible, extensible applications. In WordPress development, overriding methods allows you to customize themes and plugins without modifying core files, making your code more maintainable and update-resistant.</p>
            </div>
        </section>

        <section id="method-overriding-basics">
            <h2>The Art of Method Overriding</h2>
            
            <p>Method overriding is like inheriting a family recipe and then adding your own twist to it. The original recipe (parent method) provides a foundation, but your version (overridden method) tailors it to your specific taste while keeping the core essence intact.</p>
            
            <div class="diagram">
                <h3>Method Overriding Flow</h3>
                
<div class="mermaid-converted" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
    <div style="margin-bottom: 10px; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 1px;">Diagram</div>
    <svg viewBox="0 0 600 300" xmlns="http://www.w3.org/2000/svg" 
     style="max-width: 100%; height: auto; display: block; margin: 0 auto;">
    
    <!-- Background -->
    <rect x="0" y="0" width="600" height="300" rx="8" fill="#e3f2fd" 
          stroke="#1976d2" stroke-width="2"/>
    
    <!-- Icon -->
    <g transform="translate(300, 100)">
        <rect x="-40" y="-30" width="80" height="60" rx="5" 
              fill="white" stroke="#1976d2" stroke-width="2"/>
        <line x1="-20" y1="-10" x2="20" y2="-10" 
              stroke="#1976d2" stroke-width="2"/>
        <line x1="-20" y1="0" x2="20" y2="0" 
              stroke="#1976d2" stroke-width="2"/>
        <line x1="-20" y1="10" x2="20" y2="10" 
              stroke="#1976d2" stroke-width="2"/>
    </g>
    
    <!-- Text -->
    <text x="300" y="180" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="18" 
          fill="#0d47a1" font-weight="bold">
        Sequence Diagram
    </text>
    
    <text x="300" y="210" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="14" 
          fill="#0d47a1" opacity="0.8">
        (Diagram converted to static representation)
    </text>
    
    <!-- Original content hint -->
    <text x="300" y="240" text-anchor="middle" 
          font-family="monospace" font-size="10" 
          fill="#0d47a1" opacity="0.5">
        sequenceDiagram participant Client participant Chi...
    </text>
</svg>
</div>
            </div>
            
            <h3>Basic Mechanism of Method Overriding</h3>
            
            <p>When a child class inherits from a parent class, it can provide its own implementation of a method that already exists in the parent class. When the method is called on an instance of the child class, PHP uses the child's version instead of the parent's.</p>
            
            <div class="code-example">
                <h4>Simple Method Overriding Example</h4>
                <pre><code>
// Parent class
class Vehicle {
    protected $make;
    protected $model;
    
    public function __construct($make, $model) {
        $this->make = $make;
        $this->model = $model;
    }
    
    public function getInfo() {
        return "Vehicle: {$this->make} {$this->model}";
    }
    
    public function start() {
        return "The vehicle is starting the engine...";
    }
}

// Child class
class Car extends Vehicle {
    protected $doors;
    
    public function __construct($make, $model, $doors) {
        parent::__construct($make, $model);
        $this->doors = $doors;
    }
    
    // Override the getInfo method
    public function getInfo() {
        return "Car: {$this->make} {$this->model} with {$this->doors} doors";
    }
}

// Create instances
$vehicle = new Vehicle("Generic", "Transport");
$car = new Car("Toyota", "Corolla", 4);

// Output
echo $vehicle->getInfo(); // Output: "Vehicle: Generic Transport"
echo "<br>";
echo $car->getInfo(); // Output: "Car: Toyota Corolla with 4 doors"
echo "<br>";
echo $car->start(); // Output: "The vehicle is starting the engine..." (inherited, not overridden)
                </code></pre>
            </div>
            
            <p>In this example, the <code>Car</code> class overrides the <code>getInfo()</code> method to include information about doors, but inherits the <code>start()</code> method unchanged from the <code>Vehicle</code> class.</p>
            
            <div class="analogy">
                <h3>The Recipe Analogy</h3>
                <p>Think of method overriding like cooking:</p>
                <ul>
                    <li>The parent class (Grandmother) has a cookie recipe with specific ingredients and instructions.</li>
                    <li>The child class (You) inherits this recipe but wants to modify it slightly – perhaps adding chocolate chips or changing the baking time.</li>
                    <li>You keep the core essence of the recipe (method signature) but customize the implementation to suit your specific needs.</li>
                    <li>Anyone asking you for cookies gets your version of the recipe, not your grandmother's original.</li>
                </ul>
                <p>This analogy highlights how overriding preserves the method's contract while allowing customization of behavior.</p>
            </div>
        </section>

        <section id="method-overriding-rules">
            <h2>Rules and Requirements for Method Overriding</h2>
            
            <p>Method overriding in PHP must follow several important rules to maintain consistency and expected behavior:</p>
            
            <div class="rules-table">
                <h3>Method Overriding Rules</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Rule</th>
                            <th>Description</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Same Method Name</td>
                            <td>The method in the child class must have the exact same name as the method in the parent class.</td>
                            <td><code>getInfo()</code> in both parent and child</td>
                        </tr>
                        <tr>
                            <td>Compatible Parameter Count</td>
                            <td>The overriding method should accept at least the same number of parameters as the parent method.</td>
                            <td><code>parent: process($data)</code><br><code>child: process($data, $options = [])</code></td>
                        </tr>
                        <tr>
                            <td>Type Compatibility</td>
                            <td>Parameter types must be compatible (same or less specific) and return types must be compatible (same or more specific).</td>
                            <td>Parameter: parent accepts <code>Animal</code>, child accepts <code>Animal</code> or any parent type.<br>Return: parent returns <code>Animal</code>, child returns <code>Animal</code> or any child type.</td>
                        </tr>
                        <tr>
                            <td>Access Modifier</td>
                            <td>The overriding method can have the same or less restrictive access modifier than the parent method.</td>
                            <td>If parent is <code>protected</code>, child can be <code>protected</code> or <code>public</code>, but not <code>private</code>.</td>
                        </tr>
                        <tr>
                            <td>Static Consistency</td>
                            <td>If the parent method is static, the child method must also be static, and vice versa.</td>
                            <td>Cannot override a non-static method with a static method.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <h3>Visibility Rules in Detail</h3>
            
            <p>One of the most important rules involves visibility (access modifiers). The overriding method can have the same or a less restrictive visibility than the parent method, but it cannot be more restrictive:</p>
            
            
<div class="mermaid-converted" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
    <div style="margin-bottom: 10px; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 1px;">Diagram</div>
    <svg viewBox="0 0 800 800" xmlns="http://www.w3.org/2000/svg" 
     style="max-width: 100%; height: auto; display: block; margin: 0 auto; background: white; border-radius: 8px;">
    
    <!-- Embedded styles for this diagram only -->
    <defs>
        <style type="text/css">
            .node-rect { fill: #e1f5fe; stroke: #01579b; stroke-width: 2px; }
            .node-rect:hover { fill: #b3e5fc; }
            .node-text { fill: #01579b; font-family: 'Segoe UI', Arial, sans-serif; font-size: 14px; font-weight: 500; }
            .connection-line { stroke: #546e7a; stroke-width: 2px; fill: none; }
            .arrow-marker { fill: #546e7a; }
            .diagram-title { fill: #263238; font-size: 18px; font-weight: bold; }
            .subgraph-rect { fill: #fff3e0; stroke: #e65100; stroke-width: 1px; stroke-dasharray: 5,5; opacity: 0.3; }
        </style>
        
        <!-- Arrow marker -->
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,6 L9,3 z" class="arrow-marker"/>
        </marker>
    </defs>
    
    <!-- Background -->
    <rect x="0" y="0" width="800" height="800" fill="#fafafa" rx="8"/>
    
    <line x1="312.5" y1="80" x2="400.0" y2="200" 
          class="connection-line" marker-end="url(#arrow)"/>
    <text x="356.25" y="135.0" text-anchor="middle" 
          class="node-text" font-size="12">can be overridden as</text>
    <rect x="77.5" y="55" width="120" height="50" 
          rx="5" class="node-rect"/>
    <text x="137.5" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">private</text>
    <rect x="165.0" y="55" width="120" height="50" 
          rx="5" class="node-rect"/>
    <text x="225.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">private</text>
    <rect x="252.5" y="55" width="120" height="50" 
          rx="5" class="node-rect"/>
    <text x="312.5" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">protected</text>
    <rect x="340.0" y="55" width="120" height="50" 
          rx="5" class="node-rect"/>
    <text x="400.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">protected</text>
    <rect x="340.0" y="175" width="120" height="50" 
          rx="5" class="node-rect"/>
    <text x="400.0" y="200" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">public</text>
    <rect x="427.5" y="55" width="120" height="50" 
          rx="5" class="node-rect"/>
    <text x="487.5" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">public</text>
    <rect x="515.0" y="55" width="120" height="50" 
          rx="5" class="node-rect"/>
    <text x="575.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">public</text>
    <rect x="440.5" y="55" width="444" height="50" 
          rx="5" class="node-rect"/>
    <text x="662.5" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">Warning: Cannot override with more restrictive access</text>
</svg>
</div>
            
            <div class="code-example">
                <h4>Visibility Override Example</h4>
                <pre><code>
class ParentClass {
    // Private method - only accessible within this class
    private function privateMethod() {
        return "This is private";
    }
    
    // Protected method - accessible within this class and child classes
    protected function protectedMethod() {
        return "This is protected";
    }
    
    // Public method - accessible from anywhere
    public function publicMethod() {
        return "This is public";
    }
    
    // Public method that uses the private method
    public function usePrivateMethod() {
        return $this->privateMethod();
    }
}

class ChildClass extends ParentClass {
    // Cannot override private methods (they're not inherited)
    // This is a new method, not an override
    private function privateMethod() {
        return "Child private method";
    }
    
    // Override protected with protected (same visibility)
    protected function protectedMethod() {
        return "Child protected method";
    }
    
    // Override public with public (same visibility)
    public function publicMethod() {
        return "Child public method";
    }
    
    // This would cause an error - cannot make visibility more restrictive
    // protected function publicMethod() {
    //     return "This will cause an error";
    // }
    
    // This is valid - making visibility less restrictive
    public function protectedMethod2() {
        // Call the parent's protected method
        return "Public wrapper: " . parent::protectedMethod();
    }
}

$child = new ChildClass();
echo $child->publicMethod(); // "Child public method"
echo $child->usePrivateMethod(); // "This is private" (uses parent's privateMethod)
echo $child->protectedMethod2(); // "Public wrapper: Child protected method"
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h4>Type Declarations and Covariance/Contravariance</h4>
                <p>Since PHP 7.4, method overriding supports return type covariance and parameter type contravariance. These concepts allow more flexibility when overriding methods:</p>
                <ul>
                    <li><strong>Return Type Covariance</strong>: The overriding method can return a more specific type than the parent method.</li>
                    <li><strong>Parameter Type Contravariance</strong>: The overriding method can accept a less specific type than the parent method.</li>
                </ul>
                <div class="code-example">
                    <pre><code>
// Example of return type covariance
class Animal {}
class Dog extends Animal {}

class AnimalShelter {
    public function getAnimal(): Animal {
        return new Animal();
    }
}

class DogShelter extends AnimalShelter {
    // Return type is more specific (covariance)
    public function getAnimal(): Dog {
        return new Dog();
    }
}

// Example of parameter type contravariance
class Feed {
    public function feedAnimal(Dog $animal) {
        // Feed only dogs
    }
}

class SuperFeed extends Feed {
    // Parameter type is less specific (contravariance)
    public function feedAnimal(Animal $animal) {
        // Can feed any animal
    }
}
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="calling-parent-methods">
            <h2>Extending Parent Methods with parent::</h2>
            
            <p>Often, you don't want to completely replace the parent method's behavior, but rather extend it. The <code>parent::</code> keyword lets you call the parent's version of a method from within the overriding method.</p>
            
            <div class="diagram">
                <h3>Extending vs. Replacing Parent Methods</h3>
                
<div class="mermaid-converted" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
    <div style="margin-bottom: 10px; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 1px;">Diagram</div>
    <svg viewBox="0 0 800 500" xmlns="http://www.w3.org/2000/svg" 
     style="max-width: 100%; height: auto; display: block; margin: 0 auto; background: white; border-radius: 8px;">
    
    <!-- Embedded styles for this diagram only -->
    <defs>
        <style type="text/css">
            .node-rect { fill: #e1f5fe; stroke: #01579b; stroke-width: 2px; }
            .node-rect:hover { fill: #b3e5fc; }
            .node-text { fill: #01579b; font-family: 'Segoe UI', Arial, sans-serif; font-size: 14px; font-weight: 500; }
            .connection-line { stroke: #546e7a; stroke-width: 2px; fill: none; }
            .arrow-marker { fill: #546e7a; }
            .diagram-title { fill: #263238; font-size: 18px; font-weight: bold; }
            .subgraph-rect { fill: #fff3e0; stroke: #e65100; stroke-width: 1px; stroke-dasharray: 5,5; opacity: 0.3; }
        </style>
        
        <!-- Arrow marker -->
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L0,6 L9,3 z" class="arrow-marker"/>
        </marker>
    </defs>
    
    <!-- Background -->
    <rect x="0" y="0" width="800" height="500" fill="#fafafa" rx="8"/>
    
    <line x1="610.0" y1="80" x2="400.0" y2="200" 
          class="connection-line" marker-end="url(#arrow)"/>
    <text x="505.0" y="135.0" text-anchor="middle" 
          class="node-text" font-size="12">Then adds its own behavior</text>
    <rect x="100.0" y="55" width="180" height="50" 
          rx="5" class="node-rect"/>
    <text x="190.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">Complete Replacement</text>
    <rect x="248.0" y="55" width="164" height="50" 
          rx="5" class="node-rect"/>
    <text x="330.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">New Implementation</text>
    <rect x="410.0" y="55" width="120" height="50" 
          rx="5" class="node-rect"/>
    <text x="470.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">Extension</text>
    <rect x="516.0" y="55" width="188" height="50" 
          rx="5" class="node-rect"/>
    <text x="610.0" y="80" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">Parent Implementation</text>
    <rect x="282.0" y="175" width="236" height="50" 
          rx="5" class="node-rect"/>
    <text x="400.0" y="200" text-anchor="middle" dominant-baseline="middle" 
          class="node-text">Child&#39;s Additional Behavior</text>
</svg>
</div>
            </div>
            
            <div class="code-example">
                <h4>Using parent:: to Extend Functionality</h4>
                <pre><code>
class Logger {
    public function log($message) {
        $timestamp = date('Y-m-d H:i:s');
        return "[{$timestamp}] {$message}";
    }
}

class DetailedLogger extends Logger {
    protected $logLevel;
    
    public function __construct($logLevel = 'INFO') {
        $this->logLevel = $logLevel;
    }
    
    // Override with extension, not replacement
    public function log($message) {
        // First, get the parent's log format
        $parentLog = parent::log($message);
        
        // Then enhance it with additional information
        return "{$parentLog} [Level: {$this->logLevel}]";
    }
}

// Usage
$logger = new Logger();
$detailedLogger = new DetailedLogger('WARNING');

echo $logger->log("System started"); 
// Output: "[2025-04-28 10:15:22] System started"

echo "<br>";

echo $detailedLogger->log("Low memory detected"); 
// Output: "[2025-04-28 10:15:22] Low memory detected [Level: WARNING]"
                </code></pre>
            </div>
            
            <h3>Common Use Cases for parent::</h3>
            
            <ul>
                <li><strong>Constructors</strong>: Calling the parent constructor before adding child-specific initialization</li>
                <li><strong>Adding functionality</strong>: Extending the parent's method with additional behaviors</li>
                <li><strong>Pre/post processing</strong>: Running code before or after the parent's implementation</li>
                <li><strong>Filtering results</strong>: Modifying the return value of the parent's method</li>
                <li><strong>Validation</strong>: Adding additional validation before calling the parent method</li>
            </ul>
            
            <div class="code-example">
                <h4>Constructor Overriding Example</h4>
                <pre><code>
class Product {
    protected $name;
    protected $price;
    
    public function __construct($name, $price) {
        $this->name = $name;
        $this->price = $price;
    }
    
    public function getDetails() {
        return [
            'name' => $this->name,
            'price' => $this->price
        ];
    }
}

class DigitalProduct extends Product {
    protected $downloadUrl;
    protected $fileSize;
    
    public function __construct($name, $price, $downloadUrl, $fileSize) {
        // Call parent constructor first
        parent::__construct($name, $price);
        
        // Then add child-specific properties
        $this->downloadUrl = $downloadUrl;
        $this->fileSize = $fileSize;
    }
    
    public function getDetails() {
        // Get the parent's details
        $details = parent::getDetails();
        
        // Add child-specific details
        $details['download_url'] = $this->downloadUrl;
        $details['file_size'] = $this->fileSize;
        $details['type'] = 'digital';
        
        return $details;
    }
}

$ebook = new DigitalProduct(
    'PHP Mastery', 
    29.99, 
    'https://example.com/downloads/php-mastery.pdf', 
    '15MB'
);

print_r($ebook->getDetails());
/* Output:
Array
(
    [name] => PHP Mastery
    [price] => 29.99
    [download_url] => https://example.com/downloads/php-mastery.pdf
    [file_size] => 15MB
    [type] => digital
)
*/
                </code></pre>
            </div>
            
            <div class="pro-tip">
                <h4>Best Practices for Calling parent::</h4>
                <ul>
                    <li>Always call <code>parent::__construct()</code> when overriding constructors</li>
                    <li>Call <code>parent::</code> at the beginning of the method for pre-processing (validation)</li>
                    <li>Call <code>parent::</code> at the end of the method for post-processing (augmenting results)</li>
                    <li>Be careful with conditional calls to <code>parent::</code> as it can make code harder to follow</li>
                    <li>Document why you're overriding and what parent functionality you're preserving</li>
                </ul>
            </div>
        </section>

        <section id="real-world-examples">
            <h2>Method Overriding in the Real World</h2>
            
            <h3>Example 1: WordPress Widgets</h3>
            
            <p>WordPress widgets use method overriding extensively. Each widget type extends the <code>WP_Widget</code> base class and overrides specific methods to customize behavior.</p>
            
            <div class="code-example">
                <h4>Custom WordPress Widget Example</h4>
                <pre><code>
class WP_Widget {
    protected $id_base;
    protected $name;
    protected $options;
    
    public function __construct($id_base, $name, $options = []) {
        $this->id_base = $id_base;
        $this->name = $name;
        $this->options = $options;
    }
    
    // Default widget output method
    public function widget($args, $instance) {
        echo "Default widget output";
    }
    
    // Default form for widget settings
    public function form($instance) {
        echo "Default form";
    }
    
    // Default method to save widget settings
    public function update($new_instance, $old_instance) {
        return $new_instance;
    }
}

class Latest_Posts_Widget extends WP_Widget {
    public function __construct() {
        // Call parent constructor with specific widget details
        parent::__construct(
            'latest_posts',
            'Latest Posts Widget',
            ['description' => 'Display the most recent posts']
        );
    }
    
    // Override widget output
    public function widget($args, $instance) {
        // Extract arguments provided by WordPress
        extract($args);
        
        // Get the widget settings
        $title = !empty($instance['title']) ? $instance['title'] : 'Latest Posts';
        $count = !empty($instance['count']) ? (int) $instance['count'] : 5;
        
        // Widget start (from theme)
        echo $before_widget;
        echo $before_title . $title . $after_title;
        
        // Widget custom content
        echo "<ul class='latest-posts-widget'>";
        for ($i = 1; $i <= $count; $i++) {
            echo "<li>Example Post {$i}</li>";
        }
        echo "</ul>";
        
        // Widget end (from theme)
        echo $after_widget;
    }
    
    // Override settings form
    public function form($instance) {
        // Get saved settings or defaults
        $title = !empty($instance['title']) ? $instance['title'] : 'Latest Posts';
        $count = !empty($instance['count']) ? (int) $instance['count'] : 5;
        
        // Output form fields
        echo "<p>";
        echo "<label for='{$this->get_field_id('title')}'>Title:</label>";
        echo "<input class='widefat' id='{$this->get_field_id('title')}' name='{$this->get_field_name('title')}' type='text' value='{$title}'>";
        echo "</p>";
        
        echo "<p>";
        echo "<label for='{$this->get_field_id('count')}'>Number of posts:</label>";
        echo "<input class='small-text' id='{$this->get_field_id('count')}' name='{$this->get_field_name('count')}' type='number' min='1' max='10' value='{$count}'>";
        echo "</p>";
    }
    
    // Override update method
    public function update($new_instance, $old_instance) {
        // Start with parent's update method
        $instance = parent::update($new_instance, $old_instance);
        
        // Add our custom sanitization
        $instance['title'] = sanitize_text_field($new_instance['title']);
        $instance['count'] = max(1, min(10, (int) $new_instance['count']));
        
        return $instance;
    }
}
                </code></pre>
            </div>
            
            <h3>Example 2: WooCommerce Product Types</h3>
            
            <p>WooCommerce, the popular e-commerce plugin for WordPress, uses method overriding to handle different product types with varying pricing, shipping, and tax calculations.</p>
            
            <div class="code-example">
                <h4>Simplified WooCommerce Product Classes</h4>
                <pre><code>
abstract class WC_Product {
    protected $id;
    protected $name;
    protected $price;
    protected $stock_quantity;
    
    public function __construct($id, $name, $price, $stock_quantity) {
        $this->id = $id;
        $this->name = $name;
        $this->price = $price;
        $this->stock_quantity = $stock_quantity;
    }
    
    // Base methods
    public function get_price() {
        return $this->price;
    }
    
    public function is_in_stock() {
        return $this->stock_quantity > 0;
    }
    
    // Abstract method all product types must implement
    abstract public function calculate_tax($tax_rate);
}

// Simple physical product
class WC_Product_Simple extends WC_Product {
    protected $weight;
    protected $dimensions;
    
    public function __construct($id, $name, $price, $stock_quantity, $weight, $dimensions) {
        parent::__construct($id, $name, $price, $stock_quantity);
        $this->weight = $weight;
        $this->dimensions = $dimensions;
    }
    
    // Override to include tax
    public function get_price() {
        $base_price = parent::get_price();
        return $base_price + $this->calculate_tax(0.1); // 10% tax rate
    }
    
    public function calculate_tax($tax_rate) {
        return $this->price * $tax_rate;
    }
    
    // Shipping-specific method
    public function get_shipping_cost($zone) {
        return $this->weight * $zone->rate_per_kg;
    }
}

// Digital product (no shipping)
class WC_Product_Digital extends WC_Product {
    protected $download_url;
    protected $file_size;
    
    public function __construct($id, $name, $price, $stock_quantity, $download_url, $file_size) {
        parent::__construct($id, $name, $price, $stock_quantity);
        $this->download_url = $download_url;
        $this->file_size = $file_size;
    }
    
    // Digital products are always in stock
    public function is_in_stock() {
        return true;
    }
    
    // Different tax calculation for digital goods
    public function calculate_tax($tax_rate) {
        return $this->price * ($tax_rate * 0.5); // Half tax rate for digital goods
    }
    
    // Digital-specific method
    public function get_download_link($order_id) {
        return $this->download_url . "?order={$order_id}&time=" . time();
    }
}

// Usage
$physical = new WC_Product_Simple(1, 'Coffee Mug', 14.99, 10, 0.5, ['height' => 10, 'width' => 8, 'depth' => 8]);
$digital = new WC_Product_Digital(2, 'E-book', 9.99, 0, 'https://example.com/downloads/ebook.pdf', '2.5MB');

echo "Physical product price: $" . $physical->get_price() . "<br>"; // Includes tax
echo "Digital product price: $" . $digital->get_price() . "<br>";

echo "Physical product in stock: " . ($physical->is_in_stock() ? 'Yes' : 'No') . "<br>";
echo "Digital product in stock: " . ($digital->is_in_stock() ? 'Yes' : 'No') . "<br>"; // Always Yes
                </code></pre>
            </div>
            
            <h3>Example 3: WordPress Theme Customizer</h3>
            
            <p>WordPress theme customization relies heavily on method overriding to customize how different control types are rendered.</p>
            
            <div class="code-example">
                <h4>WordPress Customizer Control Classes</h4>
                <pre><code>
class WP_Customize_Control {
    protected $id;
    protected $label;
    protected $type;
    protected $settings;
    
    public function __construct($id, $label, $settings, $args = []) {
        $this->id = $id;
        $this->label = $label;
        $this->settings = $settings;
        $this->type = isset($args['type']) ? $args['type'] : 'text';
    }
    
    // Render the control's content
    public function render_content() {
        echo "<span class='customize-control-title'>{$this->label}</span>";
        echo "<input type='text' value='' data-customize-setting-link='{$this->settings}'>";
    }
}

// Color picker control
class WP_Customize_Color_Control extends WP_Customize_Control {
    // Override to render a color picker instead of a text input
    public function render_content() {
        // Call parent for the label
        parent::render_content();
        
        // Replace input with color picker
        echo "<input type='color' value='' data-customize-setting-link='{$this->settings}'>";
        echo "<span class='description'>Select a color</span>";
    }
}

// Image upload control
class WP_Customize_Image_Control extends WP_Customize_Control {
    // Completely override the render method
    public function render_content() {
        echo "<span class='customize-control-title'>{$this->label}</span>";
        echo "<div class='current-image'>";
        echo "<img src='' alt='Current image'>";
        echo "</div>";
        echo "<button class='upload-button button'>Select Image</button>";
        echo "<button class='remove-button button'>Remove</button>";
        echo "<input type='hidden' value='' data-customize-setting-link='{$this->settings}'>";
    }
}

// Usage in a theme
function theme_customizer_setup($wp_customize) {
    // Add a text setting
    $wp_customize->add_setting('site_title_color', [
        'default' => '#000000',
        'transport' => 'refresh',
    ]);
    
    // Add a color control
    $wp_customize->add_control(new WP_Customize_Color_Control(
        'site_title_color',
        'Site Title Color',
        'site_title_color',
        ['section' => 'title_tagline']
    ));
    
    // Add an image setting
    $wp_customize->add_setting('header_image', [
        'default' => '',
        'transport' => 'refresh',
    ]);
    
    // Add an image control
    $wp_customize->add_control(new WP_Customize_Image_Control(
        'header_image',
        'Header Image',
        'header_image',
        ['section' => 'header_settings']
    ));
}
                </code></pre>
            </div>
        </section>

        <section id="final-vs-parent-private">
            <h2>Advanced Topics in Method Overriding</h2>
            
            <h3>Final Methods: Preventing Overrides</h3>
            
            <p>Sometimes, you want to prevent a method from being overridden in child classes. PHP provides the <code>final</code> keyword for this purpose.</p>
            
            <div class="code-example">
                <h4>Final Method Example</h4>
                <pre><code>
class PaymentProcessor {
    public function processPayment($amount) {
        $this->validateAmount($amount);
        $this->logTransaction($amount);
        return $this->sendPaymentRequest($amount);
    }
    
    // This method can be overridden
    protected function validateAmount($amount) {
        if ($amount <= 0) {
            throw new Exception("Amount must be positive");
        }
    }
    
    // Critical security method - cannot be overridden
    final protected function logTransaction($amount) {
        // Secure logging implementation
        $timestamp = date('Y-m-d H:i:s');
        $transaction_id = uniqid('txn_');
        echo "LOGGED: [{$timestamp}] Transaction {$transaction_id} for \${$amount} initiated.<br>";
    }
    
    // This method should be overridden by specific payment providers
    protected function sendPaymentRequest($amount) {
        throw new Exception("Payment method not implemented");
    }
}

class StripePaymentProcessor extends PaymentProcessor {
    // Override validation to add Stripe-specific rules
    protected function validateAmount($amount) {
        // Call parent validation first
        parent::validateAmount($amount);
        
        // Add Stripe-specific validation
        if ($amount < 0.50) {
            throw new Exception("Stripe requires a minimum charge of $0.50");
        }
    }
    
    // Cannot override final method
    // This would cause a fatal error
    // protected function logTransaction($amount) {
    //     // Custom implementation
    // }
    
    // Implement required method
    protected function sendPaymentRequest($amount) {
        // Stripe-specific implementation
        echo "Processing \${$amount} payment through Stripe.<br>";
        return "stripe_" . uniqid();
    }
}

// Usage
$processor = new StripePaymentProcessor();
$processor->processPayment(25.99);
                </code></pre>
            </div>
            
            <h3>Private Methods and Overriding</h3>
            
            <p>It's important to understand that private methods are not inherited by child classes, so they cannot be overridden in the traditional sense. If a child class defines a method with the same name as a private method in the parent, it's creating a new method, not overriding the parent's method.</p>
            
            <div class="code-example">
                <h4>Private Methods vs. Overriding</h4>
                <pre><code>
class ParentClass {
    public function publicMethod() {
        echo "Public method in parent<br>";
        $this->privateMethod();
    }
    
    private function privateMethod() {
        echo "Private method in parent<br>";
    }
}

class ChildClass extends ParentClass {
    // This is NOT overriding - it's a completely separate method
    private function privateMethod() {
        echo "Private method in child<br>";
    }
}

$parent = new ParentClass();
$child = new ChildClass();

$parent->publicMethod();
// Output:
// Public method in parent
// Private method in parent

$child->publicMethod();
// Output:
// Public method in parent
// Private method in parent (not child!)
                </code></pre>
            </div>
            
            <p>Notice that when <code>$child->publicMethod()</code> is called, it still uses the parent's private method, not the child's. This is because the child's method with the same name is a completely different method that is not accessible to the inherited public method.</p>
            
            <div class="pro-tip">
                <h4>Design Considerations</h4>
                <ul>
                    <li>Use <code>final</code> methods when:
                        <ul>
                            <li>A method implements critical security functionality</li>
                            <li>Overriding would break the class's internal logic</li>
                            <li>You want to enforce a specific algorithm</li>
                        </ul>
                    </li>
                    <li>Use <code>private</code> methods when:
                        <ul>
                            <li>The functionality is purely internal to the class</li>
                            <li>The method should not be part of the class's API</li>
                            <li>You want to prevent any form of external access or modification</li>
                        </ul>
                    </li>
                    <li>Use <code>protected</code> methods when:
                        <ul>
                            <li>You want child classes to be able to override behavior</li>
                            <li>The method is part of the inheritance API but not the public API</li>
                            <li>You're designing extension points for child classes</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </section>

        <section id="method-overriding-patterns">
            <h2>Common Method Overriding Patterns</h2>
            
            <p>Method overriding is used in several common design patterns. Understanding these patterns can help you structure your code more effectively.</p>
            
            <h3>The Template Method Pattern</h3>
            
            <p>The Template Method pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses. It lets subclasses redefine certain steps without changing the algorithm's structure.</p>
            
            <div class="diagram">
                <h3>Template Method Pattern</h3>
                
<div class="mermaid-converted" style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
    <div style="margin-bottom: 10px; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 1px;">Diagram</div>
    <svg viewBox="0 0 600 300" xmlns="http://www.w3.org/2000/svg" 
     style="max-width: 100%; height: auto; display: block; margin: 0 auto;">
    
    <!-- Background -->
    <rect x="0" y="0" width="600" height="300" rx="8" fill="#f3e5f5" 
          stroke="#7b1fa2" stroke-width="2"/>
    
    <!-- Icon -->
    <g transform="translate(300, 100)">
        <rect x="-40" y="-30" width="80" height="60" rx="5" 
              fill="white" stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="-10" x2="20" y2="-10" 
              stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="0" x2="20" y2="0" 
              stroke="#7b1fa2" stroke-width="2"/>
        <line x1="-20" y1="10" x2="20" y2="10" 
              stroke="#7b1fa2" stroke-width="2"/>
    </g>
    
    <!-- Text -->
    <text x="300" y="180" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="18" 
          fill="#4a148c" font-weight="bold">
        Class Diagram
    </text>
    
    <text x="300" y="210" text-anchor="middle" 
          font-family="'Segoe UI', Arial, sans-serif" font-size="14" 
          fill="#4a148c" opacity="0.8">
        (Diagram converted to static representation)
    </text>
    
    <!-- Original content hint -->
    <text x="300" y="240" text-anchor="middle" 
          font-family="monospace" font-size="10" 
          fill="#4a148c" opacity="0.5">
        classDiagram class AbstractClass { +templateMethod...
    </text>
</svg>
</div>
            </div>
            
            <div class="code-example">
                <h4>Template Method Pattern Example</h4>
                <pre><code>
abstract class ReportGenerator {
    // The template method defines the algorithm structure
    public function generateReport($data) {
        $this->validateData($data);
        $processedData = $this->processData($data);
        $formattedReport = $this->formatReport($processedData);
        $this->deliverReport($formattedReport);
        
        return $formattedReport;
    }
    
    // Common validation logic
    protected function validateData($data) {
        if (empty($data)) {
            throw new Exception("Data cannot be empty");
        }
    }
    
    // Abstract methods that must be implemented by subclasses
    abstract protected function processData($data);
    abstract protected function formatReport($data);
    
    // Hook method with default implementation
    protected function deliverReport($report) {
        echo "Report generated and ready for delivery.<br>";
    }
}

class PDFReportGenerator extends ReportGenerator {
    protected function processData($data) {
        echo "Processing data for PDF report...<br>";
        // PDF-specific data processing
        return array_map(function($item) {
            return strtoupper($item); // Convert to uppercase for PDF
        }, $data);
    }
    
    protected function formatReport($data) {
        echo "Formatting as PDF...<br>";
        // PDF-specific formatting
        return "PDF_REPORT: " . implode(", ", $data);
    }
    
    // Override hook method
    protected function deliverReport($report) {
        parent::deliverReport($report);
        echo "Saving PDF to disk...<br>";
    }
}

class CSVReportGenerator extends ReportGenerator {
    protected function processData($data) {
        echo "Processing data for CSV report...<br>";
        // CSV-specific data processing
        return $data; // No special processing for CSV
    }
    
    protected function formatReport($data) {
        echo "Formatting as CSV...<br>";
        // CSV-specific formatting
        return "CSV_REPORT: " . implode(",", $data);
    }
    
    // Override hook method
    protected function deliverReport($report) {
        parent::deliverReport($report);
        echo "Emailing CSV report...<br>";
    }
}

// Usage
$data = ['sales' => 1000, 'expenses' => 700, 'profit' => 300];

$pdfGenerator = new PDFReportGenerator();
$pdfReport = $pdfGenerator->generateReport($data);
echo "Result: {$pdfReport}<br><br>";

$csvGenerator = new CSVReportGenerator();
$csvReport = $csvGenerator->generateReport($data);
echo "Result: {$csvReport}<br>";
                </code></pre>
            </div>
            
            <h3>The Strategy Pattern</h3>
            
            <p>The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. It lets the algorithm vary independently from clients that use it.</p>
            
            <div class="code-example">
                <h4>Strategy Pattern Example</h4>
                <pre><code>
// Strategy interface
interface PaymentStrategy {
    public function pay($amount);
    public function getPaymentDetails();
}

// Concrete strategies
class CreditCardPayment implements PaymentStrategy {
    private $cardNumber;
    private $expiryDate;
    private $cvv;
    
    public function __construct($cardNumber, $expiryDate, $cvv) {
        $this->cardNumber = $cardNumber;
        $this->expiryDate = $expiryDate;
        $this->cvv = $cvv;
    }
    
    public function pay($amount) {
        // Credit card payment processing logic
        echo "Processing credit card payment of ${$amount}...<br>";
        return "cc_transaction_" . rand(10000, 99999);
    }
    
    public function getPaymentDetails() {
        return "Credit Card: " . substr($this->cardNumber, -4);
    }
}

class PayPalPayment implements PaymentStrategy {
    private $email;
    private $password;
    
    public function __construct($email, $password) {
        $this->email = $email;
        $this->password = $password;
    }
    
    public function pay($amount) {
        // PayPal payment processing logic
        echo "Processing PayPal payment of ${$amount}...<br>";
        return "pp_transaction_" . rand(10000, 99999);
    }
    
    public function getPaymentDetails() {
        return "PayPal: " . $this->email;
    }
}

// Context class
class ShoppingCart {
    private $paymentStrategy;
    private $items = [];
    
    public function setPaymentStrategy(PaymentStrategy $paymentStrategy) {
        $this->paymentStrategy = $paymentStrategy;
    }
    
    public function addItem($item, $price) {
        $this->items[$item] = $price;
    }
    
    public function calculateTotal() {
        return array_sum($this->items);
    }
    
    public function checkout() {
        $amount = $this->calculateTotal();
        
        if (!$this->paymentStrategy) {
            throw new Exception("Payment method not set");
        }
        
        echo "Checking out with " . $this->paymentStrategy->getPaymentDetails() . "<br>";
        echo "Cart total: ${$amount}<br>";
        
        $transactionId = $this->paymentStrategy->pay($amount);
        echo "Transaction complete: {$transactionId}<br>";
    }
}

// Usage
$cart = new ShoppingCart();
$cart->addItem("PHP Book", 29.99);
$cart->addItem("Hosting (1 month)", 9.99);

// Pay with credit card
$cart->setPaymentStrategy(new CreditCardPayment("1234567890123456", "12/26", "123"));
$cart->checkout();

echo "<br>";

// Pay with PayPal
$cart->setPaymentStrategy(new PayPalPayment("user@example.com", "password"));
$cart->checkout();
                </code></pre>
            </div>
            
            <h3>The Factory Method Pattern</h3>
            
            <p>The Factory Method pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate. It lets a class defer instantiation to subclasses.</p>
            
            <div class="code-example">
                <h4>Factory Method Pattern Example</h4>
                <pre><code>
// Product interface
interface Logger {
    public function log($message);
}

// Concrete products
class FileLogger implements Logger {
    private $filePath;
    
    public function __construct($filePath) {
        $this->filePath = $filePath;
        echo "Creating FileLogger to {$filePath}<br>";
    }
    
    public function log($message) {
        echo "FileLogger: Writing message to {$this->filePath}: {$message}<br>";
    }
}

class DatabaseLogger implements Logger {
    private $connection;
    
    public function __construct($connection) {
        $this->connection = $connection;
        echo "Creating DatabaseLogger with connection {$connection}<br>";
    }
    
    public function log($message) {
        echo "DatabaseLogger: Saving message to database ({$this->connection}): {$message}<br>";
    }
}

// Creator (abstract factory)
abstract class LoggerFactory {
    // The factory method
    abstract protected function createLogger();
    
    // Template method that uses the factory method
    public function logMessage($message) {
        $logger = $this->createLogger();
        $logger->log($message);
    }
}

// Concrete creators
class FileLoggerFactory extends LoggerFactory {
    protected function createLogger() {
        return new FileLogger("/var/log/app.log");
    }
}

class DatabaseLoggerFactory extends LoggerFactory {
    protected function createLogger() {
        return new DatabaseLogger("mysql://localhost/logs");
    }
}

// Client code
function clientCode(LoggerFactory $factory) {
    $factory->logMessage("System started");
    $factory->logMessage("User logged in");
}

// Usage
echo "Using FileLoggerFactory:<br>";
clientCode(new FileLoggerFactory());

echo "<br>Using DatabaseLoggerFactory:<br>";
clientCode(new DatabaseLoggerFactory());
                </code></pre>
            </div>
        </section>

        <section id="best-practices">
            <h2>Best Practices for Method Overriding</h2>
            
            <div class="best-practices">
                <div class="practice">
                    <h3>Follow the Liskov Substitution Principle</h3>
                    <p>The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program. When overriding methods, make sure your subclass behavior doesn't violate the expectations set by the parent class.</p>
                    <div class="code-example">
                        <h4>Bad Example</h4>
                        <pre><code>
class Rectangle {
    protected $width;
    protected $height;
    
    public function setWidth($width) {
        $this->width = $width;
    }
    
    public function setHeight($height) {
        $this->height = $height;
    }
    
    public function getArea() {
        return $this->width * $this->height;
    }
}

// Violates Liskov Substitution Principle
class Square extends Rectangle {
    // Override to maintain square properties
    public function setWidth($width) {
        $this->width = $width;
        $this->height = $width; // Side effect!
    }
    
    // Override to maintain square properties
    public function setHeight($height) {
        $this->width = $height; // Side effect!
        $this->height = $height;
    }
}

// This code breaks with Square
function resizeRectangle(Rectangle $rectangle) {
    $rectangle->setWidth(5);
    $rectangle->setHeight(4);
    
    // With Rectangle: 5 * 4 = 20
    // With Square: 4 * 4 = 16 (Unexpected!)
    return $rectangle->getArea();
}

$rectangle = new Rectangle();
$area1 = resizeRectangle($rectangle);
echo "Rectangle area: {$area1}<br>"; // 20

$square = new Square();
$area2 = resizeRectangle($square);
echo "Square area: {$area2}<br>"; // 16 (Unexpected!)
                        </code></pre>
                    </div>
                </div>
                
                <div class="practice">
                    <h3>Document Your Overrides</h3>
                    <p>Always use PHPDoc comments to document your method overrides. This helps other developers understand your intentions and any differences from the parent method.</p>
                    <div class="code-example">
                        <pre><code>
class ParentClass {
    /**
     * Process the given data.
     *
     * @param array $data The data to process
     * @return array Processed data
     */
    public function processData(array $data) {
        // Processing logic
        return $data;
    }
}

class ChildClass extends ParentClass {
    /**
     * {@inheritdoc}
     *
     * Overrides parent method to add additional validation
     * and format the output as JSON strings.
     *
     * @param array $data The data to process
     * @return array Processed data with JSON-encoded values
     */
    public function processData(array $data) {
        // Call parent implementation
        $processed = parent::processData($data);
        
        // Add additional processing
        foreach ($processed as &$value) {
            $value = json_encode($value);
        }
        
        return $processed;
    }
}
                        </code></pre>
                    </div>
                </div>
                
                <div class="practice">
                    <h3>Be Consistent with Method Signatures</h3>
                    <p>Keep method signatures consistent to avoid unexpected behavior. Use type declarations to enforce type compatibility.</p>
                    <div class="code-example">
                        <pre><code>
class ParentClass {
    /**
     * Find a user by ID.
     *
     * @param int $id User ID
     * @return array|null User data or null if not found
     */
    public function findUser(int $id): ?array {
        // Implementation
    }
}

class ChildClass extends ParentClass {
    /**
     * {@inheritdoc}
     */
    public function findUser(int $id): ?array {
        // Implementation with same signature
    }
}
                        </code></pre>
                    </div>
                </div>
                
                <div class="practice">
                    <h3>Consider Performance Implications</h3>
                    <p>Method overriding can have performance implications, especially when calling parent methods. Be mindful of performance-critical sections.</p>
                    <div class="code-example">
                        <h4>Performance-Aware Overriding</h4>
                        <pre><code>
class CacheableContent {
    protected $cache = [];
    
    public function getData($key) {
        if (isset($this->cache[$key])) {
            return $this->cache[$key];
        }
        
        $data = $this->fetchData($key);
        $this->cache[$key] = $data;
        
        return $data;
    }
    
    protected function fetchData($key) {
        // Expensive operation
        sleep(1); // Simulate slow operation
        return "Original data for {$key}";
    }
}

class EnhancedCacheableContent extends CacheableContent {
    private $enhancedCache = [];
    
    // Override with enhanced caching
    public function getData($key) {
        // Enhanced caching layer
        $cacheKey = "enhanced_{$key}";
        
        if (isset($this->enhancedCache[$cacheKey])) {
            return $this->enhancedCache[$cacheKey];
        }
        
        // Don't call parent::getData() which would use another cache layer
        // Instead, call fetchData directly if needed
        if (!isset($this->cache[$key])) {
            $this->cache[$key] = $this->fetchData($key);
        }
        
        // Enhance the data
        $enhancedData = $this->enhance($this->cache[$key]);
        $this->enhancedCache[$cacheKey] = $enhancedData;
        
        return $enhancedData;
    }
    
    protected function enhance($data) {
        return "Enhanced: " . $data;
    }
}
                        </code></pre>
                    </div>
                </div>
                
                <div class="practice">
                    <h3>Use Method Overriding for Extension, Not Modification</h3>
                    <p>Method overriding is best used to extend functionality, not to drastically change behavior. If you need to change behavior substantially, consider composition over inheritance.</p>
                    <div class="code-example">
                        <h4>Good Use of Overriding</h4>
                        <pre><code>
class BasicAuthenticator {
    public function authenticate($username, $password) {
        // Basic validation
        if (empty($username) || empty($password)) {
            return false;
        }
        
        // Check credentials
        $valid = $this->checkCredentials($username, $password);
        
        if ($valid) {
            $this->logSuccess($username);
        } else {
            $this->logFailure($username);
        }
        
        return $valid;
    }
    
    protected function checkCredentials($username, $password) {
        // Simple check (in a real app, this would check a database)
        return ($username === 'admin' && $password === 'password');
    }
    
    protected function logSuccess($username) {
        echo "User {$username} logged in successfully<br>";
    }
    
    protected function logFailure($username) {
        echo "Failed login attempt for user {$username}<br>";
    }
}

class EnhancedAuthenticator extends BasicAuthenticator {
    private $maxAttempts = 3;
    private $attemptCount = [];
    
    // Override to add rate limiting
    protected function logFailure($username) {
        parent::logFailure($username);
        
        // Add rate limiting logic
        if (!isset($this->attemptCount[$username])) {
            $this->attemptCount[$username] = 0;
        }
        
        $this->attemptCount[$username]++;
        
        if ($this->attemptCount[$username] >= $this->maxAttempts) {
            echo "Account {$username} locked due to too many failed attempts<br>";
        }
    }
    
    // Override to add secure credential checking
    protected function checkCredentials($username, $password) {
        // Check if account is locked
        if (isset($this->attemptCount[$username]) && 
            $this->attemptCount[$username] >= $this->maxAttempts) {
            return false;
        }
        
        // Use parent method for actual credential checking
        return parent::checkCredentials($username, $password);
    }
}

// Usage
$auth = new EnhancedAuthenticator();

// Test with wrong password
$auth->authenticate('admin', 'wrong1');
$auth->authenticate('admin', 'wrong2');
$auth->authenticate('admin', 'wrong3');

// This attempt fails because account is locked
$auth->authenticate('admin', 'password');
                        </code></pre>
                    </div>
                </div>
            </div>
        </section>

        <section id="homework">
            <h2>Homework: Extend Your Previous Class with Inheritance</h2>
            
            <div class="assignment">
                <h3>Assignment: Method Overriding Practice</h3>
                
                <p>For this assignment, you'll take the class you created in the previous session and extend it with proper method overriding. The goal is to practice creating child classes that override parent methods in various ways.</p>
                
                <h4>Requirements:</h4>
                <ol>
                    <li>Start with the simple class you created in the previous homework, or use the example class below.</li>
                    <li>Create at least two child classes that extend your original class.</li>
                    <li>In each child class, override at least two methods from the parent class.</li>
                    <li>Use different overriding approaches:
                        <ul>
                            <li>Complete replacement (new implementation)</li>
                            <li>Extension with parent:: call at the beginning</li>
                            <li>Extension with parent:: call at the end</li>
                            <li>Conditional parent:: call</li>
                        </ul>
                    </li>
                    <li>Include proper documentation (PHPDoc comments) for each overridden method.</li>
                    <li>Create a test script that demonstrates the different behaviors of the parent and child classes.</li>
                </ol>
                
                <h4>Example Starting Class:</h4>
                <pre><code>
/**
 * Product class representing a basic product in an e-commerce system.
 */
class Product {
    protected $name;
    protected $price;
    protected $sku;
    protected $description;
    
    /**
     * Create a new product instance.
     *
     * @param string $name Product name
     * @param float $price Product price
     * @param string $sku Stock keeping unit
     * @param string $description Product description
     */
    public function __construct($name, $price, $sku, $description = '') {
        $this->name = $name;
        $this->price = $price;
        $this->sku = $sku;
        $this->description = $description;
    }
    
    /**
     * Get the product details as an array.
     *
     * @return array
     */
    public function getDetails() {
        return [
            'name' => $this->name,
            'price' => $this->price,
            'sku' => $this->sku,
            'description' => $this->description
        ];
    }
    
    /**
     * Calculate the final price including tax.
     *
     * @param float $taxRate The tax rate (0.1 for 10%)
     * @return float
     */
    public function calculatePriceWithTax($taxRate = 0.1) {
        return $this->price * (1 + $taxRate);
    }
    
    /**
     * Get formatted product information.
     *
     * @return string
     */
    public function getFormattedInfo() {
        return "Product: {$this->name} (SKU: {$this->sku}) - \${$this->price}";
    }
    
    /**
     * Check if the product is in a specific price range.
     *
     * @param float $minPrice Minimum price
     * @param float $maxPrice Maximum price
     * @return bool
     */
    public function isInPriceRange($minPrice, $maxPrice) {
        return $this->price >= $minPrice && $this->price <= $maxPrice;
    }
}
                </code></pre>
                
                <h4>Starter Code for Child Classes:</h4>
                <pre><code>
/**
 * DigitalProduct extends the basic Product with digital-specific features.
 */
class DigitalProduct extends Product {
    protected $downloadUrl;
    protected $fileSizeInMB;
    
    /**
     * Create a new digital product instance.
     *
     * @param string $name Product name
     * @param float $price Product price
     * @param string $sku Stock keeping unit
     * @param string $description Product description
     * @param string $downloadUrl Download URL
     * @param float $fileSizeInMB File size in megabytes
     */
    public function __construct($name, $price, $sku, $description, $downloadUrl, $fileSizeInMB) {
        // Call parent constructor
        parent::__construct($name, $price, $sku, $description);
        
        // Set digital-specific properties
        $this->downloadUrl = $downloadUrl;
        $this->fileSizeInMB = $fileSizeInMB;
    }
    
    /**
     * {@inheritdoc}
     *
     * Override to include digital product specific details.
     */
    public function getDetails() {
        // TODO: Override this method to add digital-specific details
    }
    
    /**
     * {@inheritdoc}
     *
     * Override to use a different tax rate for digital products.
     */
    public function calculatePriceWithTax($taxRate = 0.05) {
        // TODO: Override this method to use digital-specific tax calculation
    }
}

/**
 * PhysicalProduct extends the basic Product with physical-specific features.
 */
class PhysicalProduct extends Product {
    protected $weight;
    protected $dimensions;
    protected $inStock;
    
    /**
     * Create a new physical product instance.
     *
     * @param string $name Product name
     * @param float $price Product price
     * @param string $sku Stock keeping unit
     * @param string $description Product description
     * @param float $weight Weight in kg
     * @param array $dimensions Array with width, height, depth
     * @param int $inStock Number of items in stock
     */
    public function __construct($name, $price, $sku, $description, $weight, $dimensions, $inStock) {
        // TODO: Call parent constructor
        
        // TODO: Set physical-specific properties
    }
    
    /**
     * {@inheritdoc}
     *
     * Override to include physical product specific details.
     */
    public function getFormattedInfo() {
        // TODO: Override this method to add physical-specific formatting
    }
    
    /**
     * {@inheritdoc}
     *
     * Override to also check stock availability.
     */
    public function isInPriceRange($minPrice, $maxPrice) {
        // TODO: Override this method to include stock check
    }
    
    /**
     * Calculate shipping cost based on weight and distance.
     *
     * @param float $distance Shipping distance in miles
     * @return float
     */
    public function calculateShippingCost($distance) {
        // Base rate + weight factor + distance factor
        return 5 + ($this->weight * 2) + ($distance * 0.1);
    }
}
                </code></pre>
                
                <h4>Test Script Template:</h4>
                <pre><code>
// Include your class files
// require_once 'Product.php';
// require_once 'DigitalProduct.php';
// require_once 'PhysicalProduct.php';

// Create instances
$basicProduct = new Product('Basic Widget', 19.99, 'BW-001', 'A simple widget');
$ebook = new DigitalProduct('PHP Mastery', 29.99, 'E-BOOK-123', 'Learn PHP from scratch', 
                          'https://example.com/downloads/php-mastery.pdf', 15.5);
$chair = new PhysicalProduct('Office Chair', 149.99, 'CHAIR-456', 'Ergonomic office chair',
                           12.5, ['width' => 60, 'height' => 120, 'depth' => 65], 5);

// Test method overriding
echo "<h3>Product Details Comparison:</h3>";
echo "<pre>";
print_r($basicProduct->getDetails());
echo "

";
print_r($ebook->getDetails());
echo "

";
print_r($chair->getDetails());
echo "</pre>";

echo "<h3>Price with Tax Comparison:</h3>";
echo "Basic product: $" . number_format($basicProduct->calculatePriceWithTax(), 2) . "<br>";
echo "Digital product: $" . number_format($ebook->calculatePriceWithTax(), 2) . "<br>";
echo "Physical product: $" . number_format($chair->calculatePriceWithTax(), 2) . "<br>";

echo "<h3>Formatted Info Comparison:</h3>";
echo $basicProduct->getFormattedInfo() . "<br>";
echo $ebook->getFormattedInfo() . "<br>";
echo $chair->getFormattedInfo() . "<br>";

echo "<h3>Price Range Check Comparison:</h3>";
$minPrice = 20;
$maxPrice = 100;
echo "Basic product in range {$minPrice}-{$maxPrice}: " . 
     ($basicProduct->isInPriceRange($minPrice, $maxPrice) ? 'Yes' : 'No') . "<br>";
echo "Digital product in range {$minPrice}-{$maxPrice}: " . 
     ($ebook->isInPriceRange($minPrice, $maxPrice) ? 'Yes' : 'No') . "<br>";
echo "Physical product in range {$minPrice}-{$maxPrice}: " . 
     ($chair->isInPriceRange($minPrice, $maxPrice) ? 'Yes' : 'No') . "<br>";

// Test product-specific methods
echo "<h3>Product-Specific Methods:</h3>";
echo "Physical product shipping cost (100 miles): $" . 
     number_format($chair->calculateShippingCost(100), 2) . "<br>";
                </code></pre>
                
                <h4>Bonus Challenges:</h4>
                <ul>
                    <li>Add a third child class <code>SubscriptionProduct</code> with a recurring billing feature</li>
                    <li>Add a method to the parent class that calculates a discount, then override it in each child class with different discount strategies</li>
                    <li>Add error checking and exception handling to the overridden methods</li>
                    <li>Implement a <code>final</code> method in the parent class and explain why it shouldn't be overridden</li>
                </ul>
            </div>
        </section>

        <section class="summary">
            <h2>Key Takeaways</h2>
            
            <div class="takeaways">
                <div class="takeaway">
                    <h3>Method Overriding Fundamentals</h3>
                    <p>Method overriding allows child classes to provide specific implementations of methods defined in parent classes, customizing inherited behavior while maintaining the same method signature.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Rules and Requirements</h3>
                    <p>Overriding methods must follow specific rules: same name, compatible parameters, compatible return types, and visibility that is the same or less restrictive than the parent method.</p>
                </div>
                
                <div class="takeaway">
                    <h3>parent:: Keyword</h3>
                    <p>The <code>parent::</code> keyword allows child classes to extend parent behavior rather than completely replace it, enabling you to call the parent method and then add additional functionality.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Design Patterns</h3>
                    <p>Method overriding is a key component in several design patterns like Template Method, Strategy, and Factory Method, enabling flexible and extensible code structures.</p>
                </div>
                
                <div class="takeaway">
                    <h3>Best Practices</h3>
                    <p>Follow the Liskov Substitution Principle, document your overrides with PHPDoc comments, maintain consistent method signatures, and use overriding for extension rather than drastic modification.</p>
                </div>
            </div>
            
            <div class="next-steps">
                <h3>Next Steps</h3>
                <p>Now that you understand method overriding, we'll build on this foundation by exploring abstract classes, interfaces, namespaces, and traits. These concepts, combined with method overriding, will give you the tools to build robust, maintainable PHP applications and effectively work with WordPress's object-oriented architecture.</p>
            </div>
        </section>

        <section class="resources">
            <h2>Additional Resources</h2>
            
            <ul>
                <li><a href="https://www.php.net/manual/en/language.oop5.inheritance.php" target="_blank">PHP Manual: Object Inheritance</a></li>
                <li><a href="https://phptherightway.com/#object-oriented-programming" target="_blank">PHP The Right Way: OOP Best Practices</a></li>
                <li><a href="https://developer.wordpress.org/plugins/intro/" target="_blank">WordPress Plugin Developer Handbook</a></li>
                <li><a href="https://refactoring.guru/design-patterns/php" target="_blank">Design Patterns in PHP</a></li>
            </ul>
        </section>
            
<div class="lesson-navigation">
<a class="lesson-nav-button prev" href="/module2.html">
<svg fill="currentColor" height="20" viewbox="0 0 20 20" width="20">
<path d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"></path>
</svg>
<span>
<small>Back to</small><br/>
                                    Module 2 Overview
                                </span>
</a>
<button class="complete-lesson-btn">
                                Mark as Complete
                            </button>
<a class="lesson-nav-button next" href="/module3.html">
<span>
<small>Next Module</small><br/>
                                    Module 3: MySQL Database
                                </span>
<svg fill="currentColor" height="20" viewbox="0 0 20 20" width="20">
<path d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"></path>
</svg>
</a>
</div>
</article>
</div>
</div>
</main>
<!-- Footer -->
<footer class="site-footer" role="contentinfo">
<div class="footer-container">
<div class="footer-content">
<div class="footer-section footer-about">
<h3>PHP WordPress Development</h3>
<p>Complete Web Development Course</p>
</div>
<div class="footer-section">
<h4>Quick Links</h4>
<ul class="footer-links">
<li><a href="/">Home</a></li>
<li><a href="/module2.html">Module 2</a></li>
<li><a href="/resources.html">Resources</a></li>
</ul>
</div>
<div class="footer-section">
<h4>Support</h4>
<ul class="footer-links">
<li><a href="/help.html">Help Center</a></li>
<li><a href="/faq.html">FAQ</a></li>
<li><a href="/contact.html">Contact</a></li>
</ul>
</div>
</div>
<div class="footer-bottom">
<div class="footer-bottom-content">
<p class="copyright">© 2025 PHP WordPress Development Course</p>
<nav class="footer-bottom-links">
<a href="/privacy.html">Privacy</a>
<span class="separator">|</span>
<a href="/terms.html">Terms</a>
</nav>
</div>
</div>
</div>
</footer>
</div>
<!-- Back to Top -->
<button aria-label="Back to top" class="back-to-top" id="back-to-top">
<svg fill="none" height="24" stroke="currentColor" stroke-width="2" viewbox="0 0 24 24" width="24">
<path d="M12 19V5M12 5l-7 7M12 5l7 7"></path>
</svg>
</button>
<!-- JavaScript -->
<script src="/assets/js/navigation.js"></script>
<script src="/assets/js/site-config.js"></script>
<script src="/assets/js/sidebar-toggle.js"></script>
<script src="/assets/js/mermaid-universal-fix.js"></script>
</body>
</html>