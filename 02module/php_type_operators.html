<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 2: PHP Type Operators</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <header>
        <h1>PHP Type Operators</h1>
        <p><a href="index.html">← Back to Syllabus</a> | <a href="module2.html">Back to Module 2</a></p>
    </header>
    
    <main>
        <section class="intro">
            <h2>Introduction to PHP Type Operators</h2>
            <p>Welcome to our session on PHP Type Operators! PHP is a dynamically typed language, which means that variables can change types throughout their lifetime. This flexibility is powerful but requires careful handling, especially when data from external sources is involved. PHP provides specialized operators to help you work with variable types, enabling you to write more robust and predictable code.</p>
            
            <p>Think of type operators as detectives that investigate the nature of your data. Just as a detective might determine whether an object is made of wood, metal, or plastic, type operators help your code identify and work with different data types. Today, we'll explore these operators, understand how they work, and see them in action through practical examples relevant to web development.</p>
        </section>

        <section class="operators_overview">
            <h2>Type Operators Overview</h2>
            <p>PHP provides two main type operators that help you work with variable types:</p>
            
            <div class="svg-container">
                <svg viewBox="0 0 600 150" xmlns="http://www.w3.org/2000/svg">
                    <!-- instanceof -->
                    <rect x="100" y="25" width="180" height="100" rx="10" fill="#4CAF50" />
                    <text x="190" y="75" text-anchor="middle" font-size="24" fill="white">instanceof</text>
                    <text x="190" y="105" text-anchor="middle" font-size="16" fill="white">Object Type Check</text>
                    
                    <!-- gettype() -->
                    <rect x="320" y="25" width="180" height="100" rx="10" fill="#2196F3" />
                    <text x="410" y="75" text-anchor="middle" font-size="24" fill="white">gettype()</text>
                    <text x="410" y="105" text-anchor="middle" font-size="16" fill="white">Type Determination</text>
                </svg>
            </div>
            
            <div class="operators_table">
                <table>
                    <thead>
                        <tr>
                            <th>Operator</th>
                            <th>Name</th>
                            <th>Example</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>instanceof</td>
                            <td>Type Operator</td>
                            <td>$obj instanceof MyClass</td>
                            <td>Returns true if $obj is an instance of MyClass</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <p>Additionally, PHP provides a variety of related type functions and casting operations that, while not operators in the strict sense, work alongside the instanceof operator to provide comprehensive type handling.</p>
        </section>

        <section class="instanceof_operator">
            <h2>The instanceof Operator</h2>
            <p>The instanceof operator is used to determine if a PHP object is an instance of a specific class, implements an interface, or is from a class that extends another class.</p>
            
            <div class="mermaid-diagram">
                <h3>How instanceof Works</h3>
                <div class="mermaid">
                    graph TD
                        A["$obj instanceof Class"] --> B{"Is $obj an object?"}
                        B -->|No| C["Return false"]
                        B -->|Yes| D{"Is $obj an instance of Class<br>or a child of Class?"}
                        D -->|Yes| E["Return true"]
                        D -->|No| F["Return false"]
                </div>
            </div>
            
            <div class="code_example">
                <h3>Basic instanceof Examples</h3>
                <pre><code>&lt;?php
// Define some classes for our examples
class Animal {
    // Base class
}

class Dog extends Animal {
    // Child class of Animal
}

class Cat extends Animal {
    // Another child class of Animal
}

// Define an interface
interface Swimmable {
    // Interface for animals that can swim
    public function swim();
}

// Implement interface in a class
class Fish extends Animal implements Swimmable {
    public function swim() {
        return "Fish swimming";
    }
}

// Create some objects
$dog = new Dog();
$cat = new Cat();
$fish = new Fish();

// Check instance types
echo "Is dog an instance of Dog? " . ($dog instanceof Dog ? 'Yes' : 'No') . "&lt;br&gt;"; // Yes
echo "Is dog an instance of Animal? " . ($dog instanceof Animal ? 'Yes' : 'No') . "&lt;br&gt;"; // Yes
echo "Is dog an instance of Cat? " . ($dog instanceof Cat ? 'Yes' : 'No') . "&lt;br&gt;"; // No

echo "&lt;br&gt;";

// Check interface implementation
echo "Does fish implement Swimmable? " . ($fish instanceof Swimmable ? 'Yes' : 'No') . "&lt;br&gt;"; // Yes
echo "Does dog implement Swimmable? " . ($dog instanceof Swimmable ? 'Yes' : 'No') . "&lt;br&gt;"; // No

echo "&lt;br&gt;";

// Non-objects always return false
$name = "Buddy";
echo "Is string an instance of Dog? " . ($name instanceof Dog ? 'Yes' : 'No') . "&lt;br&gt;"; // No

// Checking with class name in a variable
$class_name = "Animal";
echo "Is dog an instance of " . $class_name . "? " . ($dog instanceof $class_name ? 'Yes' : 'No') . "&lt;br&gt;"; // Yes
?&gt;</code></pre>
            </div>
            
            <div class="anonymous_classes">
                <h3>instanceof with Anonymous Classes</h3>
                <p>The instanceof operator also works with anonymous classes (available since PHP 7.0):</p>
                
                <pre><code>&lt;?php
// Create an anonymous class instance
$obj = new class extends Animal {
    public function speak() {
        return "Anonymous animal sound";
    }
};

// Check type
echo "Is anonymous object an instance of Animal? " . ($obj instanceof Animal ? 'Yes' : 'No') . "&lt;br&gt;"; // Yes

// More specific check with a variable holding the exact class
$exact_class = get_class($obj);
echo "Exact class: " . $exact_class . "&lt;br&gt;";
echo "Is object an instance of its exact class? " . ($obj instanceof $exact_class ? 'Yes' : 'No') . "&lt;br&gt;"; // Yes
?&gt;</code></pre>
            </div>
            
            <div class="real_world">
                <h3>Real-World Application: Plugin System</h3>
                <p>The instanceof operator is perfect for implementing plugin systems or extensible frameworks:</p>
                
                <pre><code>&lt;?php
// Plugin system example
interface Plugin {
    public function getName();
    public function initialize();
    public function execute();
}

class PluginManager {
    private $plugins = [];
    
    public function registerPlugin($plugin) {
        // Only register valid plugin objects
        if ($plugin instanceof Plugin) {
            $name = $plugin->getName();
            $this->plugins[$name] = $plugin;
            echo "Plugin '$name' registered successfully&lt;br&gt;";
            return true;
        } else {
            echo "Failed to register plugin: Object is not a valid Plugin implementation&lt;br&gt;";
            return false;
        }
    }
    
    public function initializePlugins() {
        foreach ($this->plugins as $name => $plugin) {
            echo "Initializing plugin: $name&lt;br&gt;";
            $plugin->initialize();
        }
    }
    
    public function executePlugin($name) {
        if (isset($this->plugins[$name])) {
            $plugin = $this->plugins[$name];
            echo "Executing plugin: $name&lt;br&gt;";
            $plugin->execute();
            return true;
        }
        echo "Plugin '$name' not found&lt;br&gt;";
        return false;
    }
    
    public function getPluginList() {
        return array_keys($this->plugins);
    }
}

// Example plugins
class LoggerPlugin implements Plugin {
    public function getName() {
        return "Logger";
    }
    
    public function initialize() {
        echo "- Logger plugin initialized&lt;br&gt;";
    }
    
    public function execute() {
        echo "- Logging information...&lt;br&gt;";
    }
}

class CachePlugin implements Plugin {
    public function getName() {
        return "Cache";
    }
    
    public function initialize() {
        echo "- Cache plugin initialized&lt;br&gt;";
    }
    
    public function execute() {
        echo "- Caching data...&lt;br&gt;";
    }
}

// Invalid plugin example
class InvalidPlugin {
    public function getName() {
        return "Invalid";
    }
}

// Using the plugin system
$manager = new PluginManager();

// Register plugins
$logger = new LoggerPlugin();
$cache = new CachePlugin();
$invalid = new InvalidPlugin();

$manager->registerPlugin($logger);
$manager->registerPlugin($cache);
$manager->registerPlugin($invalid); // This should fail

// Initialize all plugins
$manager->initializePlugins();

// Execute specific plugins
$manager->executePlugin("Logger");
$manager->executePlugin("Cache");
$manager->executePlugin("Invalid"); // This should fail

// Display registered plugins
echo "&lt;br&gt;Registered plugins: " . implode(", ", $manager->getPluginList()) . "&lt;br&gt;";
?&gt;</code></pre>
            </div>
            
            <div class="real_world">
                <h3>Real-World Application: Form Handling with Type Validation</h3>
                <p>Using instanceof for validating form handlers in a web application:</p>
                
                <pre><code>&lt;?php
// Form handling system
interface FormHandler {
    public function validate($data);
    public function process($data);
    public function getSuccessMessage();
    public function getErrorMessage();
}

// Specific form handlers
class ContactFormHandler implements FormHandler {
    private $errors = [];
    
    public function validate($data) {
        // Validate name
        if (empty($data['name'])) {
            $this->errors[] = "Name is required";
        }
        
        // Validate email
        if (empty($data['email'])) {
            $this->errors[] = "Email is required";
        } elseif (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            $this->errors[] = "Invalid email format";
        }
        
        // Validate message
        if (empty($data['message'])) {
            $this->errors[] = "Message is required";
        }
        
        return empty($this->errors);
    }
    
    public function process($data) {
        // In a real application, this would send an email or save to a database
        echo "Processing contact form data...&lt;br&gt;";
        echo "- From: " . htmlspecialchars($data['name']) . " (" . htmlspecialchars($data['email']) . ")&lt;br&gt;";
        echo "- Message: " . htmlspecialchars($data['message']) . "&lt;br&gt;";
        
        return true;
    }
    
    public function getSuccessMessage() {
        return "Thank you for your message! We'll get back to you soon.";
    }
    
    public function getErrorMessage() {
        if (empty($this->errors)) {
            return "";
        }
        
        return "Please correct the following errors: &lt;br&gt;- " . implode("&lt;br&gt;- ", $this->errors);
    }
}

class SubscriptionFormHandler implements FormHandler {
    private $errors = [];
    
    public function validate($data) {
        // Validate email
        if (empty($data['email'])) {
            $this->errors[] = "Email is required";
        } elseif (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            $this->errors[] = "Invalid email format";
        }
        
        // Validate subscription type
        if (empty($data['subscription_type'])) {
            $this->errors[] = "Subscription type is required";
        }
        
        return empty($this->errors);
    }
    
    public function process($data) {
        // In a real application, this would add to a newsletter database
        echo "Processing subscription data...&lt;br&gt;";
        echo "- Email: " . htmlspecialchars($data['email']) . "&lt;br&gt;";
        echo "- Subscription: " . htmlspecialchars($data['subscription_type']) . "&lt;br&gt;";
        
        return true;
    }
    
    public function getSuccessMessage() {
        return "Thank you for subscribing to our newsletter!";
    }
    
    public function getErrorMessage() {
        if (empty($this->errors)) {
            return "";
        }
        
        return "Please correct the following errors: &lt;br&gt;- " . implode("&lt;br&gt;- ", $this->errors);
    }
}

// Form processor class
class FormProcessor {
    public function processForm($handler, $data) {
        // Use instanceof to verify handler is valid
        if (!($handler instanceof FormHandler)) {
            echo "Error: Invalid form handler";
            return false;
        }
        
        // Validate form data
        if (!$handler->validate($data)) {
            echo "&lt;div class='error'&gt;" . $handler->getErrorMessage() . "&lt;/div&gt;";
            return false;
        }
        
        // Process form data
        if ($handler->process($data)) {
            echo "&lt;div class='success'&gt;" . $handler->getSuccessMessage() . "&lt;/div&gt;";
            return true;
        }
        
        return false;
    }
}

// Test the form processing system
$processor = new FormProcessor();

// Test contact form (success case)
echo "&lt;h4&gt;Processing Contact Form (Valid Data)&lt;/h4&gt;";
$contact_handler = new ContactFormHandler();
$contact_data = [
    'name' => 'John Doe',
    'email' => 'john@example.com',
    'message' => 'Hello, this is a test message.'
];
$processor->processForm($contact_handler, $contact_data);

echo "&lt;hr&gt;";

// Test contact form (error case)
echo "&lt;h4&gt;Processing Contact Form (Invalid Data)&lt;/h4&gt;";
$contact_data_invalid = [
    'name' => '',
    'email' => 'invalid-email',
    'message' => ''
];
$processor->processForm($contact_handler, $contact_data_invalid);

echo "&lt;hr&gt;";

// Test subscription form
echo "&lt;h4&gt;Processing Subscription Form&lt;/h4&gt;";
$subscription_handler = new SubscriptionFormHandler();
$subscription_data = [
    'email' => 'subscriber@example.com',
    'subscription_type' => 'weekly'
];
$processor->processForm($subscription_handler, $subscription_data);

echo "&lt;hr&gt;";

// Test with invalid handler
echo "&lt;h4&gt;Processing with Invalid Handler&lt;/h4&gt;";
class NotAFormHandler {
    // This class doesn't implement FormHandler
}
$invalid_handler = new NotAFormHandler();
$processor->processForm($invalid_handler, []);
?&gt;</code></pre>
            </div>
            
            <p><strong>Analogy:</strong> The instanceof operator is like a membership card checker at an exclusive club. It verifies whether an object is a member of a particular class (or class family) before granting it access to certain operations or privileges.</p>
        </section>

        <section class="type_checking_functions">
            <h2>Type Checking Functions in PHP</h2>
            <p>While not operators in the strict sense, PHP provides several functions for type checking that work alongside instanceof to provide comprehensive type handling:</p>
            
            <div class="code_example">
                <h3>Basic Type Checking Functions</h3>
                <pre><code>&lt;?php
// Sample variables of different types
$string_var = "Hello, World!";
$int_var = 42;
$float_var = 3.14159;
$bool_var = true;
$array_var = [1, 2, 3];
$null_var = null;
$object_var = new stdClass();
$resource_var = fopen('php://memory', 'r');
$callable_var = function() { return "I'm callable"; };

// gettype() - Returns the type of a variable
echo "&lt;h4&gt;gettype() Examples&lt;/h4&gt;";
echo "gettype(\$string_var): " . gettype($string_var) . "&lt;br&gt;"; // string
echo "gettype(\$int_var): " . gettype($int_var) . "&lt;br&gt;"; // integer
echo "gettype(\$float_var): " . gettype($float_var) . "&lt;br&gt;"; // double
echo "gettype(\$bool_var): " . gettype($bool_var) . "&lt;br&gt;"; // boolean
echo "gettype(\$array_var): " . gettype($array_var) . "&lt;br&gt;"; // array
echo "gettype(\$null_var): " . gettype($null_var) . "&lt;br&gt;"; // NULL
echo "gettype(\$object_var): " . gettype($object_var) . "&lt;br&gt;"; // object
echo "gettype(\$resource_var): " . gettype($resource_var) . "&lt;br&gt;"; // resource
echo "gettype(\$callable_var): " . gettype($callable_var) . "&lt;br&gt;"; // object (for closures)

// Specific type checking functions
echo "&lt;h4&gt;Type Checking Function Examples&lt;/h4&gt;";
echo "is_string(\$string_var): " . (is_string($string_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "is_int(\$int_var): " . (is_int($int_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "is_float(\$float_var): " . (is_float($float_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "is_bool(\$bool_var): " . (is_bool($bool_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "is_array(\$array_var): " . (is_array($array_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "is_null(\$null_var): " . (is_null($null_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "is_object(\$object_var): " . (is_object($object_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "is_resource(\$resource_var): " . (is_resource($resource_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "is_callable(\$callable_var): " . (is_callable($callable_var) ? 'true' : 'false') . "&lt;br&gt;"; // true

// Close the resource
fclose($resource_var);
?&gt;</code></pre>
            </div>
            
            <div class="type_testing_table">
                <h3>Type Checking Functions Reference</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Checks If</th>
                            <th>Returns</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>is_array()</td>
                            <td>Variable is an array</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_bool()</td>
                            <td>Variable is a boolean</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_callable()</td>
                            <td>Variable is callable</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_countable()</td>
                            <td>Variable can be counted</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_float(), is_double(), is_real()</td>
                            <td>Variable is a float</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_int(), is_integer(), is_long()</td>
                            <td>Variable is an integer</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_iterable()</td>
                            <td>Variable is iterable</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_null()</td>
                            <td>Variable is null</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_numeric()</td>
                            <td>Variable is a number or numeric string</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_object()</td>
                            <td>Variable is an object</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_resource()</td>
                            <td>Variable is a resource</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_scalar()</td>
                            <td>Variable is a scalar (int, float, string, or bool)</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>is_string()</td>
                            <td>Variable is a string</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>isset()</td>
                            <td>Variable is set and not null</td>
                            <td>Boolean</td>
                        </tr>
                        <tr>
                            <td>empty()</td>
                            <td>Variable is empty</td>
                            <td>Boolean</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="special_cases">
                <h3>Special Cases: isset() and empty()</h3>
                <p>The isset() and empty() language constructs are particularly useful for working with form data and potentially undefined variables:</p>
                
                <pre><code>&lt;?php
// isset() examples
$defined_var = "Hello";
$null_var = null;
// $undefined_var is not set at all

echo "&lt;h4&gt;isset() Examples&lt;/h4&gt;";
echo "isset(\$defined_var): " . (isset($defined_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "isset(\$null_var): " . (isset($null_var) ? 'true' : 'false') . "&lt;br&gt;"; // false (null is not considered "set")
echo "isset(\$undefined_var): " . (isset($undefined_var) ? 'true' : 'false') . "&lt;br&gt;"; // false

// Multiple variable check
echo "isset(\$defined_var, \$null_var): " . (isset($defined_var, $null_var) ? 'true' : 'false') . "&lt;br&gt;"; // false (all must be set)

// Array element check
$array = ['a' => 1, 'b' => 2];
echo "isset(\$array['a']): " . (isset($array['a']) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "isset(\$array['c']): " . (isset($array['c']) ? 'true' : 'false') . "&lt;br&gt;"; // false

// empty() examples
$zero = 0;
$empty_string = "";
$empty_array = [];
$false_var = false;
$non_empty = "Not empty";

echo "&lt;h4&gt;empty() Examples&lt;/h4&gt;";
echo "empty(\$zero): " . (empty($zero) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "empty(\$empty_string): " . (empty($empty_string) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "empty(\$empty_array): " . (empty($empty_array) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "empty(\$false_var): " . (empty($false_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "empty(\$null_var): " . (empty($null_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "empty(\$undefined_var): " . (empty($undefined_var) ? 'true' : 'false') . "&lt;br&gt;"; // true
echo "empty(\$non_empty): " . (empty($non_empty) ? 'true' : 'false') . "&lt;br&gt;"; // false

// The following values are considered empty:
// - "" (empty string)
// - 0 (as integer)
// - 0.0 (as float)
// - "0" (as string)
// - null
// - false
// - array() (empty array)
// - object with no properties (PHP 5)
// - SimpleXML objects created from empty tags
?&gt;</code></pre>
            </div>
            
            <div class="real_world">
                <h3>Real-World Application: Form Data Validation</h3>
                <p>Type checking functions are essential for validating form data:</p>
                
                <pre><code>&lt;?php
// Form data validation function
function validateFormData($data) {
    $errors = [];
    
    // Validate name (must be a non-empty string)
    if (!isset($data['name']) || !is_string($data['name']) || empty(trim($data['name']))) {
        $errors['name'] = "Name is required and must be text";
    }
    
    // Validate age (must be a positive integer)
    if (!isset($data['age']) || !is_numeric($data['age']) || (int)$data['age'] <= 0) {
        $errors['age'] = "Age must be a positive number";
    }
    
    // Validate email (must be a valid email format)
    if (!isset($data['email']) || !is_string($data['email']) || !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
        $errors['email'] = "A valid email address is required";
    }
    
    // Validate interests (must be an array with at least one item)
    if (!isset($data['interests']) || !is_array($data['interests']) || empty($data['interests'])) {
        $errors['interests'] = "Please select at least one interest";
    }
    
    // Return validation result
    return [
        'is_valid' => empty($errors),
        'errors' => $errors
    ];
}

// Example usage
echo "&lt;h4&gt;Form Validation Example&lt;/h4&gt;";

// Valid data
$valid_data = [
    'name' => 'John Doe',
    'age' => 25,
    'email' => 'john@example.com',
    'interests' => ['programming', 'photography']
];

$result1 = validateFormData($valid_data);
echo "Valid form data: " . ($result1['is_valid'] ? 'Valid' : 'Invalid') . "&lt;br&gt;";

// Invalid data
$invalid_data = [
    'name' => '',
    'age' => 'twenty',
    'email' => 'not-an-email',
    'interests' => []
];

$result2 = validateFormData($invalid_data);
echo "Invalid form data: " . ($result2['is_valid'] ? 'Valid' : 'Invalid') . "&lt;br&gt;";
if (!$result2['is_valid']) {
    echo "Errors:&lt;br&gt;";
    foreach ($result2['errors'] as $field => $message) {
        echo "- $field: $message&lt;br&gt;";
    }
}
?&gt;</code></pre>
            </div>
            
            <p><strong>Analogy:</strong> Type checking functions are like security guards examining ID cards at different checkpoints. Each guard has specific instructions about which types of ID to accept, and they'll only let variables pass if they have the right "identity."</p>
        </section>

        <section class="type_casting">
            <h2>Type Casting</h2>
            <p>PHP allows you to convert variables from one type to another through a process called type casting. Though not operators themselves, type casting operations are essential for proper type handling in PHP.</p>
            
            <div class="code_example">
                <h3>Basic Type Casting Examples</h3>
                <pre><code>&lt;?php
// Type casting examples
$string_value = "42";
$float_value = 3.14159;
$bool_value = true;
$array_value = [1, 2, 3];
$null_value = null;

echo "&lt;h4&gt;Type Casting Examples&lt;/h4&gt;";

// String to integer casting
$int_from_string = (int) $string_value;
echo "String to int: " . $string_value . " → " . $int_from_string . " (" . gettype($int_from_string) . ")&lt;br&gt;";

// Float to integer casting (truncates the decimal part)
$int_from_float = (int) $float_value;
echo "Float to int: " . $float_value . " → " . $int_from_float . " (" . gettype($int_from_float) . ")&lt;br&gt;";

// Boolean to integer casting
$int_from_bool = (int) $bool_value;
echo "Bool to int: " . ($bool_value ? 'true' : 'false') . " → " . $int_from_bool . " (" . gettype($int_from_bool) . ")&lt;br&gt;";

// Integer to boolean casting
$zero = 0;
$one = 1;
$bool_from_zero = (bool) $zero;
$bool_from_one = (bool) $one;
echo "Int 0 to bool: " . $zero . " → " . ($bool_from_zero ? 'true' : 'false') . " (" . gettype($bool_from_zero) . ")&lt;br&gt;";
echo "Int 1 to bool: " . $one . " → " . ($bool_from_one ? 'true' : 'false') . " (" . gettype($bool_from_one) . ")&lt;br&gt;";

// String to float
$float_string = "3.14";
$float_from_string = (float) $float_string;
echo "String to float: " . $float_string . " → " . $float_from_string . " (" . gettype($float_from_string) . ")&lt;br&gt;";

// Array to object
$obj_from_array = (object) $array_value;
echo "Array to object: Array → Object with properties: ";
foreach ($obj_from_array as $key => $value) {
    echo "$key=$value, ";
}
echo " (" . gettype($obj_from_array) . ")&lt;br&gt;";

// Null casting examples
$int_from_null = (int) $null_value;
$string_from_null = (string) $null_value;
$array_from_null = (array) $null_value;
$obj_from_null = (object) $null_value;

echo "Null to int: null → " . $int_from_null . " (" . gettype($int_from_null) . ")&lt;br&gt;";
echo "Null to string: null → '" . $string_from_null . "' (" . gettype($string_from_null) . ")&lt;br&gt;";
echo "Null to array: null → " . (empty($array_from_null) ? 'empty array' : 'non-empty array') . " (" . gettype($array_from_null) . ")&lt;br&gt;";
echo "Null to object: null → " . (count((array)$obj_from_null) ? 'object with properties' : 'empty object') . " (" . gettype($obj_from_null) . ")&lt;br&gt;";
?&gt;</code></pre>
            </div>
            
            <div class="casting_table">
                <h3>Type Casting Operators</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Cast Operator</th>
                            <th>Description</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>(int), (integer)</td>
                            <td>Cast to integer</td>
                            <td>(int) $var</td>
                        </tr>
                        <tr>
                            <td>(float), (double), (real)</td>
                            <td>Cast to float</td>
                            <td>(float) $var</td>
                        </tr>
                        <tr>
                            <td>(string)</td>
                            <td>Cast to string</td>
                            <td>(string) $var</td>
                        </tr>
                        <tr>
                            <td>(bool), (boolean)</td>
                            <td>Cast to boolean</td>
                            <td>(bool) $var</td>
                        </tr>
                        <tr>
                            <td>(array)</td>
                            <td>Cast to array</td>
                            <td>(array) $var</td>
                        </tr>
                        <tr>
                            <td>(object)</td>
                            <td>Cast to object</td>
                            <td>(object) $var</td>
                        </tr>
                        <tr>
                            <td>(unset)</td>
                            <td>Cast to NULL (deprecated)</td>
                            <td>(unset) $var</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="special_cases">
                <h3>Type Juggling and Implicit Casting</h3>
                <p>PHP will automatically convert (juggle) types in certain contexts. This is called implicit casting:</p>
                
                <pre><code>&lt;?php
// Type juggling examples
echo "&lt;h4&gt;Type Juggling Examples&lt;/h4&gt;";

// String and number in addition
$num = 5;
$str = "10";
$result = $num + $str; // $str is implicitly cast to int
echo "$num + '$str' = $result (" . gettype($result) . ")&lt;br&gt;";

// String and number in concatenation
$concat = $num . $str; // $num is implicitly cast to string
echo "$num . '$str' = '$concat' (" . gettype($concat) . ")&lt;br&gt;";

// Boolean in calculations
$calc = 10 * true; // true is implicitly cast to 1
echo "10 * true = $calc (" . gettype($calc) . ")&lt;br&gt;";

// null in calculations
$null_calc = 10 + null; // null is implicitly cast to 0
echo "10 + null = $null_calc (" . gettype($null_calc) . ")&lt;br&gt;";

// String with number vs. non-numeric string
$numeric_str = "42";
$text_str = "hello";
$numeric_result = $num + $numeric_str; // Works fine
$text_result = $num + $text_str; // Warning but $text_str is treated as 0

echo "$num + '$numeric_str' = $numeric_result&lt;br&gt;";
echo "$num + '$text_str' = $text_result (with warning)&lt;br&gt;";
?&gt;</code></pre>
            </div>
            
            <div class="real_world">
                <h3>Real-World Application: Data Sanitization for Database</h3>
                <p>Type casting is essential for properly sanitizing data before storing it in a database:</p>
                
                <pre><code>&lt;?php
// Data sanitization example for database insertion
class DataSanitizer {
    /**
     * Sanitize user input data based on expected types
     *
     * @param array $data The raw input data
     * @param array $schema The expected data types
     * @return array Sanitized data ready for database
     */
    public static function sanitize($data, $schema) {
        $sanitized = [];
        
        foreach ($schema as $field => $type) {
            // Skip if field not present in data
            if (!isset($data[$field])) {
                continue;
            }
            
            $value = $data[$field];
            
            // Sanitize based on expected type
            switch ($type) {
                case 'int':
                    $sanitized[$field] = (int) $value;
                    break;
                    
                case 'float':
                    $sanitized[$field] = (float) $value;
                    break;
                    
                case 'bool':
                    $sanitized[$field] = (bool) $value;
                    break;
                    
                case 'string':
                    // Trim and sanitize string
                    $sanitized[$field] = htmlspecialchars(trim((string) $value), ENT_QUOTES);
                    break;
                    
                case 'email':
                    // Validate and sanitize email
                    $email = filter_var($value, FILTER_SANITIZE_EMAIL);
                    if (filter_var($email, FILTER_VALIDATE_EMAIL)) {
                        $sanitized[$field] = $email;
                    }
                    break;
                    
                case 'date':
                    // Ensure date is in Y-m-d format
                    try {
                        $date = new DateTime($value);
                        $sanitized[$field] = $date->format('Y-m-d');
                    } catch (Exception $e) {
                        // Invalid date, skip
                    }
                    break;
                    
                case 'array':
                    // Ensure value is an array
                    $sanitized[$field] = is_array($value) ? $value : [$value];
                    break;
                    
                default:
                    // For unrecognized types, store as is
                    $sanitized[$field] = $value;
            }
        }
        
        return $sanitized;
    }
    
    /**
     * Generate SQL placeholders for prepared statements
     *
     * @param array $schema The expected data types
     * @return array SQL type placeholders
     */
    public static function getSqlPlaceholders($schema) {
        $placeholders = [];
        
        foreach ($schema as $field => $type) {
            switch ($type) {
                case 'int':
                    $placeholders[$field] = '%d'; // Integer placeholder
                    break;
                    
                case 'float':
                    $placeholders[$field] = '%f'; // Float placeholder
                    break;
                    
                case 'bool':
                    $placeholders[$field] = '%d'; // Boolean as integer (0/1)
                    break;
                    
                default:
                    $placeholders[$field] = '%s'; // String placeholder for everything else
            }
        }
        
        return $placeholders;
    }
}

// Example usage
$schema = [
    'id' => 'int',
    'name' => 'string',
    'email' => 'email',
    'age' => 'int',
    'subscription_fee' => 'float',
    'is_active' => 'bool',
    'registration_date' => 'date',
    'interests' => 'array'
];

// Raw user input (typically from $_POST or $_GET)
$user_input = [
    'id' => '42abc', // Non-numeric chars will be removed
    'name' => '  John Doe  ', // Extra spaces will be trimmed
    'email' => 'john.doe@example.com',
    'age' => '30',
    'subscription_fee' => '9.99',
    'is_active' => 1,
    'registration_date' => '2023-05-15',
    'interests' => ['sports', 'music', 'reading']
];

// Sanitize data
$sanitized_data = DataSanitizer::sanitize($user_input, $schema);

// Get SQL placeholders
$placeholders = DataSanitizer::getSqlPlaceholders($schema);

// Display results
echo "&lt;h4&gt;Data Sanitization Example&lt;/h4&gt;";

echo "&lt;h5&gt;Raw Input Data:&lt;/h5&gt;";
echo "&lt;pre&gt;";
print_r($user_input);
echo "&lt;/pre&gt;";

echo "&lt;h5&gt;Sanitized Data:&lt;/h5&gt;";
echo "&lt;pre&gt;";
print_r($sanitized_data);
echo "&lt;/pre&gt;";

echo "&lt;h5&gt;SQL Placeholders:&lt;/h5&gt;";
echo "&lt;pre&gt;";
print_r($placeholders);
echo "&lt;/pre&gt;";

// Example of how this might be used in a prepared statement (pseudo-code)
echo "&lt;h5&gt;Example SQL Query:&lt;/h5&gt;";
$fields = implode(', ', array_keys($sanitized_data));
$placeholders_str = implode(', ', array_map(function($field) use ($placeholders) {
    return $placeholders[$field];
}, array_keys($sanitized_data)));

echo "INSERT INTO users ($fields) VALUES ($placeholders_str)&lt;br&gt;";
echo "&lt;em&gt;With values: " . implode(', ', array_map(function($value) {
    return is_array($value) ? 'Array' : (is_string($value) ? "'$value'" : $value);
}, $sanitized_data)) . "&lt;/em&gt;";
?&gt;</code></pre>
            </div>
            
            <p><strong>Analogy:</strong> Type casting is like a currency exchange. Just as you might convert dollars to euros when traveling, PHP allows you to convert variables from one "currency" (type) to another. However, just like with real currency exchange, some precision or value might be lost in the conversion process.</p>
        </section>

        <section class="type_declarations">
            <h2>Type Declarations (Type Hinting)</h2>
            <p>PHP 7.0 and later versions support type declarations for function parameters and return values. While not operators, type declarations work alongside type operators to enhance code reliability.</p>
            
            <div class="code_example">
                <h3>Basic Type Declaration Examples</h3>
                <pre><code>&lt;?php
// Type declarations for function parameters and return types

// Basic scalar type declarations
function addNumbers(int $a, int $b): int {
    return $a + $b;
}

// Class type declaration
function processUser(User $user): bool {
    // Process user...
    return true;
}

// Interface type declaration
function saveEntity(EntityInterface $entity): int {
    // Save entity...
    return 1; // ID of saved entity
}

// Array type declaration
function processItems(array $items): array {
    return array_map(function($item) {
        return $item * 2;
    }, $items);
}

// Nullable type (PHP 7.1+)
function findUser(int $id): ?User {
    // If user not found, return null
    $found = false;
    
    if ($found) {
        return new User();
    } else {
        return null;
    }
}

// Union types (PHP 8.0+)
function process(int|float $number): int|float {
    return $number * 2;
}

// Define a simple User class for the examples
class User {
    public $id;
    public $name;
    
    public function __construct($id = 0, $name = '') {
        $this->id = $id;
        $this->name = $name;
    }
}

// Define an interface for the examples
interface EntityInterface {
    public function getId();
    public function save();
}

// Implement the interface
class Product implements EntityInterface {
    private $id;
    
    public function getId() {
        return $this->id;
    }
    
    public function save() {
        // Save to database...
        return true;
    }
}

// Demo the type declarations
echo "&lt;h4&gt;Type Declaration Examples&lt;/h4&gt;";

// Add numbers
$sum = addNumbers(5, 10);
echo "5 + 10 = $sum&lt;br&gt;";

// Try with type mismatch
try {
    $result = addNumbers("5", "10"); // This would throw a TypeError in strict mode
    echo "\"5\" + \"10\" = $result (with type juggling)&lt;br&gt;";
} catch (TypeError $e) {
    echo "Type Error: " . $e->getMessage() . "&lt;br&gt;";
}

// Array type
$numbers = [1, 2, 3, 4, 5];
$processed = processItems($numbers);
echo "Processed items: " . implode(', ', $processed) . "&lt;br&gt;";

// Object type
$product = new Product();
$saved = saveEntity($product);
echo "Saved entity with ID: $saved&lt;br&gt;";

// Incorrect type
try {
    $invalid = new stdClass(); // This doesn't implement EntityInterface
    saveEntity($invalid);
} catch (TypeError $e) {
    echo "Type Error: " . $e->getMessage() . "&lt;br&gt;";
}
?&gt;</code></pre>
            </div>
            
            <div class="strict_types">
                <h3>Strict Type Mode</h3>
                <p>PHP 7.0 introduced a strict typing mode that prevents automatic type juggling in function parameters and return values:</p>
                
                <pre><code>&lt;?php
// Enable strict typing
declare(strict_types=1);

// With strict typing, this function requires exact int types
function strictAdd(int $a, int $b): int {
    return $a + $b;
}

// Without strict typing (in another file), this would work with strings
function looseAdd(int $a, int $b): int {
    return $a + $b;
}

// Demo the difference
echo "&lt;h4&gt;Strict vs. Loose Typing&lt;/h4&gt;";

try {
    $result = strictAdd(5, 10); // Works fine
    echo "strictAdd(5, 10) = $result&lt;br&gt;";
    
    $result = strictAdd("5", "10"); // Throws TypeError in strict mode
    echo "strictAdd(\"5\", \"10\") = $result&lt;br&gt;";
} catch (TypeError $e) {
    echo "Type Error in strict mode: " . $e->getMessage() . "&lt;br&gt;";
}

// Note: looseAdd would behave differently if not in a strict_types file
?&gt;</code></pre>
            </div>
            
            <div class="real_world">
                <h3>Real-World Application: Data Transfer Objects (DTOs)</h3>
                <p>Type declarations are extremely useful for creating robust data transfer objects:</p>
                
                <pre><code>&lt;?php
// Data Transfer Object example with type declarations
class UserDTO {
    private int $id;
    private string $name;
    private string $email;
    private ?string $phone;
    private array $roles;
    private bool $isActive;
    private \DateTime $createdAt;
    
    public function __construct(
        int $id,
        string $name,
        string $email,
        ?string $phone = null,
        array $roles = [],
        bool $isActive = true
    ) {
        $this->id = $id;
        $this->name = $name;
        $this->email = $email;
        $this->phone = $phone;
        $this->roles = $roles;
        $this->isActive = $isActive;
        $this->createdAt = new \DateTime();
    }
    
    // Getters with return type declarations
    public function getId(): int {
        return $this->id;
    }
    
    public function getName(): string {
        return $this->name;
    }
    
    public function getEmail(): string {
        return $this->email;
    }
    
    public function getPhone(): ?string {
        return $this->phone;
    }
    
    public function getRoles(): array {
        return $this->roles;
    }
    
    public function isActive(): bool {
        return $this->isActive;
    }
    
    public function getCreatedAt(): \DateTime {
        return $this->createdAt;
    }
    
    // Factory method to create from array
    public static function fromArray(array $data): self {
        return new self(
            (int) ($data['id'] ?? 0),
            (string) ($data['name'] ?? ''),
            (string) ($data['email'] ?? ''),
            isset($data['phone']) ? (string) $data['phone'] : null,
            (array) ($data['roles'] ?? []),
            (bool) ($data['is_active'] ?? true)
        );
    }
    
    // Convert to array
    public function toArray(): array {
        return [
            'id' => $this->id,
            'name' => $this->name,
            'email' => $this->email,
            'phone' => $this->phone,
            'roles' => $this->roles,
            'is_active' => $this->isActive,
            'created_at' => $this->createdAt->format('Y-m-d H:i:s')
        ];
    }
}

// Service that uses the DTO
class UserService {
    public function createUser(UserDTO $user): int {
        // In a real app, would save to database
        echo "Creating user: " . $user->getName() . "&lt;br&gt;";
        echo "Email: " . $user->getEmail() . "&lt;br&gt;";
        
        if ($user->getPhone() !== null) {
            echo "Phone: " . $user->getPhone() . "&lt;br&gt;";
        } else {
            echo "No phone provided&lt;br&gt;";
        }
        
        echo "Roles: " . implode(', ', $user->getRoles()) . "&lt;br&gt;";
        echo "Status: " . ($user->isActive() ? 'Active' : 'Inactive') . "&lt;br&gt;";
        echo "Created: " . $user->getCreatedAt()->format('Y-m-d H:i:s') . "&lt;br&gt;";
        
        // Return a simulated ID
        return $user->getId() ?: rand(1000, 9999);
    }
}

// Example usage
echo "&lt;h4&gt;Data Transfer Object Example&lt;/h4&gt;";

// Raw data (e.g., from a form submission)
$userData = [
    'name' => 'Jane Smith',
    'email' => 'jane@example.com',
    'phone' => '555-123-4567',
    'roles' => ['user', 'editor'],
    'is_active' => true
];

// Create DTO from data
$userDTO = UserDTO::fromArray($userData);

// Use the service
$userService = new UserService();
$newUserId = $userService->createUser($userDTO);

echo "&lt;br&gt;User created with ID: $newUserId&lt;br&gt;";

// Convert back to array (e.g., for API response)
$responseData = $userDTO->toArray();
echo "&lt;br&gt;Response data:&lt;br&gt;";
echo "&lt;pre&gt;";
print_r($responseData);
echo "&lt;/pre&gt;";
?&gt;</code></pre>
            </div>
            
            <p><strong>Analogy:</strong> Type declarations are like security checks at the entrance to a function. Just as a nightclub bouncer checks IDs to ensure only eligible people enter, type declarations verify that only variables of the correct type can enter your functions. This prevents "unauthorized" types from causing problems inside your code.</p>
        </section>

        <section class="best_practices">
            <h2>Best Practices for Type Handling</h2>
            <ul>
                <li><strong>Use instanceof for object type verification:</strong> Always verify an object's type before performing operations specific to a class or interface.</li>
                <li><strong>Prefer type declarations:</strong> Use parameter and return type declarations to make your code more robust and self-documenting.</li>
                <li><strong>Enable strict_types:</strong> When appropriate, use strict typing to prevent unexpected type juggling.</li>
                <li><strong>Validate user input:</strong> Always validate and sanitize user input using appropriate type checking functions.</li>
                <li><strong>Explicit over implicit:</strong> Use explicit type casting rather than relying on PHP's automatic type juggling.</li>
                <li><strong>Handle edge cases:</strong> Always consider how your code handles null values and edge cases.</li>
                <li><strong>Document types:</strong> Use PHPDoc comments to document expected types, especially for older code without type declarations.</li>
                <li><strong>Remember that arrays are not objects:</strong> Arrays don't pass instanceof checks for classes, even if they have similar structure.</li>
            </ul>
            
            <div class="code_example">
                <h3>Best Practices Example</h3>
                <pre><code>&lt;?php
/**
 * A best practices example for type handling
 */

// Enable strict typing
declare(strict_types=1);

/**
 * Process an order and return the total
 *
 * @param Order $order The order to process
 * @param array $options Processing options
 * @return float The total order amount
 * @throws InvalidArgumentException If the order is invalid
 */
function processOrder(Order $order, array $options = []): float {
    // Use instanceof to verify object type
    if (!$order instanceof Order) {
        throw new InvalidArgumentException('Invalid order object');
    }
    
    // Set default options using union assignment
    $options = $options + [
        'apply_discount' => true,
        'tax_rate' => 0.0825,
        'include_shipping' => true
    ];
    
    // Validate options
    $options['apply_discount'] = (bool) $options['apply_discount'];
    $options['tax_rate'] = (float) $options['tax_rate'];
    $options['include_shipping'] = (bool) $options['include_shipping'];
    
    // Calculate the subtotal
    $subtotal = 0.0;
    foreach ($order->getItems() as $item) {
        $subtotal += $item->getPrice() * $item->getQuantity();
    }
    
    // Apply discount if enabled
    $discount = 0.0;
    if ($options['apply_discount'] && $order->hasDiscount()) {
        $discount = $order->getDiscountAmount();
        $subtotal -= $discount;
    }
    
    // Add tax
    $tax = $subtotal * $options['tax_rate'];
    
    // Add shipping if enabled
    $shipping = 0.0;
    if ($options['include_shipping']) {
        $shipping = $order->getShippingCost();
    }
    
    // Calculate total
    $total = $subtotal + $tax + $shipping;
    
    // Ensure the return value is a float
    return (float) $total;
}

// Define Order class for the example
class Order {
    private array $items = [];
    private ?float $discount = null;
    private float $shippingCost = 0.0;
    
    public function addItem(OrderItem $item): self {
        $this->items[] = $item;
        return $this;
    }
    
    public function getItems(): array {
        return $this->items;
    }
    
    public function setDiscount(float $amount): self {
        $this->discount = $amount > 0 ? $amount : null;
        return $this;
    }
    
    public function hasDiscount(): bool {
        return $this->discount !== null && $this->discount > 0;
    }
    
    public function getDiscountAmount(): float {
        return $this->discount ?? 0.0;
    }
    
    public function setShippingCost(float $cost): self {
        $this->shippingCost = $cost >= 0 ? $cost : 0.0;
        return $this;
    }
    
    public function getShippingCost(): float {
        return $this->shippingCost;
    }
}

// Define OrderItem class for the example
class OrderItem {
    private string $name;
    private float $price;
    private int $quantity;
    
    public function __construct(string $name, float $price, int $quantity = 1) {
        $this->name = $name;
        $this->price = $price > 0 ? $price : 0.0;
        $this->quantity = $quantity > 0 ? $quantity : 1;
    }
    
    public function getName(): string {
        return $this->name;
    }
    
    public function getPrice(): float {
        return $this->price;
    }
    
    public function getQuantity(): int {
        return $this->quantity;
    }
}

// Example usage
echo "&lt;h4&gt;Order Processing Example&lt;/h4&gt;";

// Create an order with items
$order = new Order();
$order->addItem(new OrderItem("Product A", 19.99, 2))
      ->addItem(new OrderItem("Product B", 24.99, 1))
      ->setDiscount(5.00)
      ->setShippingCost(7.50);

// Process the order
try {
    $total = processOrder($order, [
        'tax_rate' => 0.07 // Custom tax rate
    ]);
    
    echo "Order processed successfully!&lt;br&gt;";
    echo "Total: $" . number_format($total, 2) . "&lt;br&gt;";
} catch (InvalidArgumentException $e) {
    echo "Error: " . $e->getMessage() . "&lt;br&gt;";
}

// Try with invalid input (would throw a TypeError in strict mode)
try {
    $notAnOrder = new stdClass();
    $total = processOrder($notAnOrder);
} catch (TypeError $e) {
    echo "&lt;br&gt;Type Error: " . $e->getMessage() . "&lt;br&gt;";
}
?&gt;</code></pre>
            </div>
        </section>

        <section class="practice_exercises">
            <h2>Practice Exercises</h2>
            <p>Test your understanding of PHP type operators with these exercises:</p>
            
            <div class="exercise">
                <h3>Exercise 1: Type-Safe Collection Class</h3>
                <p>Create a class that ensures all items added to it are of the same type.</p>
                <pre><code>&lt;?php
/*
 * 1. Create a TypedCollection class that only accepts items of a specified type
 * 2. Implement add(), remove(), and getItems() methods
 * 3. Use instanceof and type checking to ensure type safety
 * 4. Test with different types of objects
 */
?&gt;</code></pre>
            </div>
            
            <div class="exercise">
                <h3>Exercise 2: Type Validator Function</h3>
                <p>Create a function that validates input data against a schema.</p>
                <pre><code>&lt;?php
/*
 * 1. Create a validateData($data, $schema) function
 * 2. The schema should specify types for each field (e.g., 'int', 'string', 'email', etc.)
 * 3. Return validation errors for any field that doesn't match its expected type
 * 4. Test with various types of input data
 */
?&gt;</code></pre>
            </div>
            
            <div class="exercise">
                <h3>Exercise 3: Plugin Framework</h3>
                <p>Create a simple plugin framework using interfaces and instanceof checks.</p>
                <pre><code>&lt;?php
/*
 * 1. Define a PluginInterface with methods like install(), activate(), and execute()
 * 2. Create a PluginManager class that can register and run plugins
 * 3. Use instanceof to ensure only proper plugins can be registered
 * 4. Create a few example plugins that implement the interface
 * 5. Demonstrate registering and running the plugins
 */
?&gt;</code></pre>
            </div>
        </section>

        <section class="summary">
            <h2>Summary</h2>
            <p>In this session, we've explored PHP's type operators and related type handling mechanisms:</p>
            
            <ul>
                <li><strong>instanceof Operator:</strong> Checks if an object is an instance of a specified class, implements an interface, or is a child of a specified class. It's essential for polymorphism and type validation in object-oriented PHP code.</li>
                <li><strong>Type Checking Functions:</strong> Functions like is_string(), is_int(), and is_array() that verify variable types. These are essential for validating input and ensuring your code behaves predictably.</li>
                <li><strong>isset() and empty():</strong> Special constructs for checking variable existence and "emptiness" - particularly useful for form data and potentially undefined variables.</li>
                <li><strong>Type Casting:</strong> Operations that convert variables from one type to another, either explicitly ((int), (string), etc.) or implicitly through PHP's type juggling.</li>
                <li><strong>Type Declarations:</strong> Modern PHP's ability to specify expected types for function parameters and return values, enabling more robust code and better documentation.</li>
            </ul>
            
            <p>We've also covered important concepts like:</p>
            
            <ul>
                <li><strong>Strict typing mode:</strong> For preventing automatic type juggling and enforcing explicit type conformance.</li>
                <li><strong>Type juggling:</strong> PHP's automatic conversion between types in certain contexts.</li>
                <li><strong>Real-world applications:</strong> Plugin systems, form validation, data sanitization, and data transfer objects that rely on PHP's type handling features.</li>
            </ul>
            
            <p>Understanding type operators and type handling is fundamental to writing robust PHP applications, especially when working with user input or integrating with external systems. These tools help prevent bugs, improve code reliability, and make your intentions clearer to other developers.</p>
        </section>

        <section class="next_session">
            <h2>Next Session Preview</h2>
            <p>In our next session, we'll explore PHP Control Structures, which allow you to control the flow of your programs. We'll learn about if/else statements, switch statements, loops, and other constructs that let you make decisions and repeat actions in your PHP applications, often using the type operators we've learned about today.</p>
        </section>

        <section class="additional_resources">
            <h2>Additional Resources</h2>
            <ul>
                <li><a href="https://www.php.net/manual/en/language.operators.type.php" target="_blank">PHP Manual: Type Operators</a></li>
                <li><a href="https://www.php.net/manual/en/language.types.type-juggling.php" target="_blank">PHP Manual: Type Juggling</a></li>
                <li><a href="https://www.php.net/manual/en/language.types.declarations.php" target="_blank">PHP Manual: Type Declarations</a></li>
                <li><a href="https://www.php.net/manual/en/language.operators.type.php" target="_blank">PHP Manual: instanceof</a></li>
                <li><a href="https://www.php.net/manual/en/function.is-object.php" target="_blank">PHP Manual: is_object() and Other Type Functions</a></li>
                <li><a href="https://www.php.net/manual/en/function.gettype.php" target="_blank">PHP Manual: gettype() Function</a></li>
            </ul>
        </section>
    </main>
    
    <footer>
        <p>&copy; 2025 PHP WordPress Development Course</p>
       
    </footer>
</body>
</html>
