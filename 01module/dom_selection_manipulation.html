<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selecting and Manipulating DOM Elements</title>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="icon" href="/favicon.png">
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <header>
        <h1>Selecting and Manipulating DOM Elements</h1>
        <p><a href="index.html">← Back to Syllabus</a> | <a href="module1.html">← Back to Module 1</a></p>
    </header>
    
    <main>
        <section class="introduction">
            <h2>The Power of DOM Selection and Manipulation</h2>
            <p>The ability to select and manipulate DOM elements is what makes JavaScript the powerhouse of web interactivity. This skill allows you to create dynamic, responsive web applications that react to user input and update in real-time without requiring page refreshes.</p>
            
            <div class="analogy">
                <h3>DOM Manipulation as Puppetry</h3>
                <p>Think of DOM manipulation like puppetry. Your HTML creates the puppets (elements), CSS designs their appearance, and JavaScript is the puppeteer that brings them to life by moving strings (selecting elements) and making them dance (manipulating their properties and content).</p>
            </div>

            <div class="mermaid-container">
                <div class="mermaid">
                    graph LR
                    A[HTML] -->|Creates Structure| D[DOM Tree]
                    B[CSS] -->|Styles| D
                    C[JavaScript] -->|"Selects & Manipulates"| D
                    D -->|Renders| E[Web Page]
                    style A fill:#f8d7da,stroke:#333,stroke-width:1px
                    style B fill:#d1ecf1,stroke:#333,stroke-width:1px
                    style C fill:#fff3cd,stroke:#333,stroke-width:1px
                    style D fill:#d4edda,stroke:#333,stroke-width:1px
                    style E fill:#e2e3e5,stroke:#333,stroke-width:1px
                </div>
            </div>
        </section>

        <section class="dom-selection">
            <h2>Selecting DOM Elements</h2>
            <p>Before you can manipulate elements, you need to select them. JavaScript provides multiple ways to find and select elements in the DOM. Let's explore them from most specific to most general.</p>

            <svg width="800" height="250" xmlns="http://www.w3.org/2000/svg">
                <!-- Background -->
                <rect x="0" y="0" width="800" height="250" fill="#f8f9fa" rx="10" ry="10"/>
                
                <!-- Method boxes -->
                <rect x="50" y="30" width="700" height="40" fill="#e9ecef" rx="5" ry="5" stroke="#ced4da" stroke-width="1"/>
                <rect x="50" y="80" width="700" height="40" fill="#e9ecef" rx="5" ry="5" stroke="#ced4da" stroke-width="1"/>
                <rect x="50" y="130" width="700" height="40" fill="#e9ecef" rx="5" ry="5" stroke="#ced4da" stroke-width="1"/>
                <rect x="50" y="180" width="700" height="40" fill="#e9ecef" rx="5" ry="5" stroke="#ced4da" stroke-width="1"/>
                
                <!-- Method names -->
                <text x="70" y="55" font-family="monospace" font-size="14" fill="#495057">document.getElementById('unique-id')</text>
                <text x="70" y="105" font-family="monospace" font-size="14" fill="#495057">document.getElementsByClassName('some-class')</text>
                <text x="70" y="155" font-family="monospace" font-size="14" fill="#495057">document.getElementsByTagName('div')</text>
                <text x="70" y="205" font-family="monospace" font-size="14" fill="#495057">document.querySelector('.class') / document.querySelectorAll('div > p')</text>
                
                <!-- Return type -->
                <text x="600" y="55" font-family="sans-serif" font-size="14" fill="#6c757d">Returns: Single Element</text>
                <text x="600" y="105" font-family="sans-serif" font-size="14" fill="#6c757d">Returns: HTMLCollection (live)</text>
                <text x="600" y="155" font-family="sans-serif" font-size="14" fill="#6c757d">Returns: HTMLCollection (live)</text>
                <text x="560" y="205" font-family="sans-serif" font-size="14" fill="#6c757d">Returns: Element / NodeList (static)</text>
                
                <!-- Arrows showing specificity -->
                <text x="25" y="50" font-family="sans-serif" font-size="12" fill="#dc3545" text-anchor="end">Most</text>
                <text x="25" y="65" font-family="sans-serif" font-size="12" fill="#dc3545" text-anchor="end">Specific</text>
                <text x="25" y="195" font-family="sans-serif" font-size="12" fill="#0d6efd" text-anchor="end">Most</text>
                <text x="25" y="210" font-family="sans-serif" font-size="12" fill="#0d6efd" text-anchor="end">Flexible</text>
                <line x1="25" y1="70" x2="25" y2="180" stroke="#6c757d" stroke-width="2" stroke-dasharray="5,5"/>
                <polygon points="25,180 20,170 30,170" fill="#0d6efd"/>
            </svg>

            <h3>Selection Methods in Detail</h3>
            
            <div class="method-group">
                <h4>Selection by ID</h4>
                <p>The most direct way to select a single element with a unique identifier.</p>
                <div class="code-example">
                    <pre><code>// HTML
&lt;div id="main-content"&gt;This is the main content area&lt;/div&gt;

// JavaScript
const mainContent = document.getElementById('main-content');
console.log(mainContent); // Returns the div element</code></pre>
                </div>
                <div class="example-explanation">
                    <p><strong>Real-world use:</strong> Use this when you need to select a specific, unique element - like a form, a main container, or a special button.</p>
                    <p><strong>Performance:</strong> This is the fastest selection method since IDs must be unique in a document.</p>
                </div>
            </div>

            <div class="method-group">
                <h4>Selection by Class Name</h4>
                <p>Used to select multiple elements that share the same class.</p>
                <div class="code-example">
                    <pre><code>// HTML
&lt;div class="product"&gt;Product 1&lt;/div&gt;
&lt;div class="product"&gt;Product 2&lt;/div&gt;
&lt;div class="product featured"&gt;Product 3&lt;/div&gt;

// JavaScript
const products = document.getElementsByClassName('product');
console.log(products); // HTMLCollection of all divs with class "product"
console.log(products.length); // 3
console.log(products[0]); // First product div</code></pre>
                </div>
                <div class="example-explanation">
                    <p><strong>Real-world use:</strong> Ideal for working with groups of related elements such as navigation items, product cards, or form fields.</p>
                    <p><strong>Note:</strong> Returns a live HTMLCollection which updates automatically if elements are added or removed.</p>
                </div>
            </div>

            <div class="method-group">
                <h4>Selection by Tag Name</h4>
                <p>Selects all elements of a specific HTML tag type.</p>
                <div class="code-example">
                    <pre><code>// JavaScript
const paragraphs = document.getElementsByTagName('p');
console.log(paragraphs); // HTMLCollection of all paragraph elements
console.log(paragraphs.length); // Number of paragraphs in the document

// You can also search within a specific context
const container = document.getElementById('container');
const spanInsideContainer = container.getElementsByTagName('span');</code></pre>
                </div>
                <div class="example-explanation">
                    <p><strong>Real-world use:</strong> When you need to work with all elements of a specific type, such as modifying all images, links, or list items.</p>
                    <p><strong>Practical example:</strong> Adding target="_blank" to all external links.</p>
                </div>
            </div>

            <div class="method-group">
                <h4>Selection with CSS Selectors</h4>
                <p>The most flexible and powerful selection methods, using the same syntax as CSS selectors.</p>
                <div class="code-example">
                    <pre><code>// querySelector - returns first matching element
const firstButton = document.querySelector('button');
const submitButton = document.querySelector('.submit-btn');
const navigationLink = document.querySelector('nav > ul > li:first-child > a');

// querySelectorAll - returns all matching elements as a NodeList
const allButtons = document.querySelectorAll('button');
const productItems = document.querySelectorAll('.product-item');
const oddListItems = document.querySelectorAll('li:nth-child(odd)');</code></pre>
                </div>
                <div class="example-explanation">
                    <p><strong>Real-world use:</strong> Ideal for complex selections using CSS selector combinations. Particularly useful for modern web applications with complex DOM structures.</p>
                    <p><strong>Note:</strong> querySelector is slower than getElementById but offers much more flexibility.</p>
                </div>
            </div>

            <h3>Working with Collections</h3>
            <p>Many selection methods return collections of elements rather than a single element:</p>
            
            <table>
                <thead>
                    <tr>
                        <th>Collection Type</th>
                        <th>Returned By</th>
                        <th>Characteristics</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>HTMLCollection</td>
                        <td>getElementsByClassName<br>getElementsByTagName</td>
                        <td>
                            <ul>
                                <li>Live collection (auto-updates)</li>
                                <li>Array-like but not an array</li>
                                <li>Access items with bracket notation: collection[0]</li>
                                <li>No forEach, map, filter, etc. methods</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td>NodeList</td>
                        <td>querySelectorAll</td>
                        <td>
                            <ul>
                                <li>Static collection (does not auto-update)</li>
                                <li>Array-like but not an array</li>
                                <li>Has forEach method</li>
                                <li>No map, filter, etc. methods</li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>

            <div class="important-tip">
                <h4>Converting Collections to Arrays</h4>
                <p>To use array methods on these collections, convert them to arrays:</p>
                <div class="code-example">
                    <pre><code>// Using Array.from()
const buttons = document.querySelectorAll('button');
const buttonArray = Array.from(buttons);
buttonArray.forEach(button => {
  console.log(button.textContent);
});

// Using spread operator (...)
const paragraphs = document.getElementsByTagName('p');
const paragraphArray = [...paragraphs];
paragraphArray.map(p => p.textContent);</code></pre>
                </div>
            </div>

            <div class="analogy">
                <h3>DOM Selection as Fishing</h3>
                <p>Different selection methods are like different fishing techniques:</p>
                <ul>
                    <li><strong>getElementById</strong> is like spearfishing - targeting one specific fish (element) you can see clearly.</li>
                    <li><strong>getElementsByClassName</strong> is like net fishing for a particular species - you'll catch all fish (elements) of that type.</li>
                    <li><strong>getElementsByTagName</strong> is like casting a wide net for a general category of fish.</li>
                    <li><strong>querySelector/querySelectorAll</strong> is like sport fishing with customizable equipment - you can create complex rules to catch exactly the fish you want, but it takes more effort to set up.</li>
                </ul>
            </div>
        </section>

        <section class="dom-manipulation">
            <h2>Manipulating DOM Elements</h2>
            <p>Once you've selected elements, the real power of JavaScript becomes apparent - you can modify content, attributes, styles, and more to create dynamic interactions.</p>

            <h3>Changing Text and HTML Content</h3>
            <div class="code-example">
                <pre><code>const heading = document.querySelector('h1');

// Changing text content (safer when dealing with user input)
heading.textContent = 'Updated Heading';

// Changing HTML content (can insert HTML elements)
heading.innerHTML = 'Updated &lt;span&gt;Heading&lt;/span&gt; with Emphasis';

// innerText vs textContent
// textContent gets all content including text in &lt;script&gt; and &lt;style&gt; elements
// innerText is aware of styling and won't return hidden text
console.log(element.textContent); // Gets all text content
console.log(element.innerText); // Gets visible text content</code></pre>
            </div>

            <div class="real-world-example">
                <h4>Real-World Example: Dynamic Content Updates</h4>
                <p>Consider a word counter for a text area:</p>
                <div class="code-example">
                    <pre><code>// HTML
&lt;textarea id="message" placeholder="Type your message here..."&gt;&lt;/textarea&gt;
&lt;div id="counter"&gt;0 characters&lt;/div&gt;

// JavaScript
const textarea = document.getElementById('message');
const counter = document.getElementById('counter');

textarea.addEventListener('input', function() {
  const count = textarea.value.length;
  counter.textContent = `${count} character${count !== 1 ? 's' : ''}`;
  
  // Add visual feedback
  if (count > 200) {
    counter.style.color = 'red';
  } else {
    counter.style.color = 'black';
  }
});</code></pre>
                </div>
            </div>

            <h3>Working with Element Attributes</h3>
            <div class="code-example">
                <pre><code>const link = document.querySelector('a');

// Getting attribute values
const href = link.getAttribute('href');
console.log(href); // e.g., "https://example.com"

// Setting attribute values
link.setAttribute('href', 'https://newdomain.com');
link.setAttribute('target', '_blank');
link.setAttribute('data-category', 'external');

// Checking if an attribute exists
if (link.hasAttribute('target')) {
  console.log('This link opens in a new tab');
}

// Removing attributes
link.removeAttribute('target');

// Direct property access for common attributes
link.href = 'https://anotherdomain.com'; // Same as setAttribute for common properties
link.id = 'main-link';
console.log(link.href); // Same as getAttribute for common properties</code></pre>
            </div>

            <div class="important-tip">
                <h4>HTML5 Custom Data Attributes</h4>
                <p>HTML5 introduced custom data attributes that let you store extra information on elements:</p>
                <div class="code-example">
                    <pre><code>// HTML
&lt;div id="product" data-id="1234" data-category="electronics" data-price="499.99"&gt;
  Smartphone X
&lt;/div&gt;

// JavaScript
const product = document.getElementById('product');

// Access using getAttribute
const productId = product.getAttribute('data-id');

// Access using dataset property (modern approach)
console.log(product.dataset.id); // "1234"
console.log(product.dataset.category); // "electronics"

// Modify using dataset
product.dataset.price = "449.99";
product.dataset.inStock = "true"; // Adds a new data-in-stock attribute</code></pre>
                </div>
            </div>

            <h3>Managing CSS Classes</h3>
            <p>One of the most common DOM manipulations is changing CSS classes to alter appearance and behavior:</p>
            <div class="code-example">
                <pre><code>const card = document.querySelector('.card');

// Old approach (still works)
// Reading the className property returns a space-separated string
console.log(card.className); // e.g., "card product featured"

// Setting completely replaces all classes
card.className = 'card product';

// Modern approach: classList API
// Check if an element has a class
if (card.classList.contains('featured')) {
  console.log('This is a featured card');
}

// Add classes (can add multiple)
card.classList.add('active');
card.classList.add('highlighted', 'selected');

// Remove classes
card.classList.remove('featured');
card.classList.remove('highlighted', 'selected');

// Toggle a class (add if missing, remove if present)
card.classList.toggle('expanded'); // Returns true if added, false if removed

// Replace one class with another
card.classList.replace('inactive', 'active');</code></pre>
            </div>

            <div class="real-world-example">
                <h4>Real-World Example: Interactive Accordion</h4>
                <p>Using classList to create an interactive accordion component:</p>
                <div class="code-example">
                    <pre><code>// HTML
&lt;div class="accordion"&gt;
  &lt;div class="accordion-item"&gt;
    &lt;div class="accordion-header"&gt;Section 1&lt;/div&gt;
    &lt;div class="accordion-content"&gt;Content for section 1...&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="accordion-item"&gt;
    &lt;div class="accordion-header"&gt;Section 2&lt;/div&gt;
    &lt;div class="accordion-content"&gt;Content for section 2...&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

// CSS (simplified)
.accordion-content {
  display: none;
  padding: 10px;
}
.accordion-item.active .accordion-content {
  display: block;
}
.accordion-header {
  cursor: pointer;
  padding: 10px;
  background-color: #f0f0f0;
}
.accordion-item.active .accordion-header {
  background-color: #e0e0e0;
}

// JavaScript
const accordionHeaders = document.querySelectorAll('.accordion-header');

accordionHeaders.forEach(header => {
  header.addEventListener('click', function() {
    // Toggle the active class on the parent item
    const item = this.parentElement;
    item.classList.toggle('active');
    
    // Optional: Close other items when opening one
    const allItems = document.querySelectorAll('.accordion-item');
    allItems.forEach(otherItem => {
      if (otherItem !== item) {
        otherItem.classList.remove('active');
      }
    });
  });
});</code></pre>
                </div>
            </div>

            <h3>Manipulating Inline Styles</h3>
            <p>You can directly modify the inline styles of elements using the style property:</p>
            <div class="code-example">
                <pre><code>const box = document.querySelector('.box');

// Setting individual style properties
box.style.backgroundColor = 'skyblue';
box.style.width = '200px';
box.style.height = '100px';
box.style.border = '2px solid navy';
box.style.borderRadius = '10px';
box.style.marginTop = '20px';

// CSS properties with hyphens must be camelCased in JavaScript
// CSS: background-color → JS: backgroundColor
// CSS: border-radius → JS: borderRadius

// Reading computed styles (what's actually applied after all CSS)
const computedStyle = window.getComputedStyle(box);
console.log(computedStyle.backgroundColor);
console.log(computedStyle.width);

// Setting multiple styles at once
Object.assign(box.style, {
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  color: 'white',
  fontWeight: 'bold'
});</code></pre>
            </div>

            <div class="important-tip">
                <h4>Best Practice: Prefer Classes Over Inline Styles</h4>
                <p>While direct style manipulation is convenient, using CSS classes is generally better practice:</p>
                <ul>
                    <li>Better separation of concerns (HTML/JS for structure/behavior, CSS for appearance)</li>
                    <li>More maintainable and reusable styling</li>
                    <li>Better performance for multiple style changes</li>
                    <li>Easier to adapt for responsive design</li>
                </ul>
                <p>Use direct style manipulation for:</p>
                <ul>
                    <li>Dynamic values (e.g., positions based on calculations)</li>
                    <li>Temporary state changes (e.g., animations)</li>
                    <li>When adding a class would be overkill</li>
                </ul>
            </div>

            <h3>Manipulating Element Properties</h3>
            <p>DOM elements have many properties beyond attributes and styles:</p>
            <div class="code-example">
                <pre><code>// Form element properties
const nameInput = document.getElementById('name');
nameInput.value = 'John Doe'; // Set input value
nameInput.disabled = true; // Disable input
nameInput.readOnly = true; // Make input read-only

// Checkbox/radio properties
const checkbox = document.getElementById('terms');
checkbox.checked = true; // Check the box
console.log(checkbox.checked); // true

// Image properties
const logo = document.getElementById('logo');
logo.src = '/images/new-logo.png';
logo.alt = 'Company Logo';

// Accessibility properties
const menuButton = document.getElementById('menu-button');
menuButton.ariaExpanded = 'false';
menuButton.ariaLabel = 'Open navigation menu';</code></pre>
            </div>
        </section>

        <section class="creating-elements">
            <h2>Creating and Managing DOM Elements</h2>
            <p>Beyond manipulating existing elements, JavaScript allows you to create, insert, and remove elements entirely.</p>

            <h3>Creating New Elements</h3>
            <div class="code-example">
                <pre><code>// Create a new element
const newParagraph = document.createElement('p');

// Add content and attributes to it
newParagraph.textContent = 'This is a dynamically created paragraph.';
newParagraph.className = 'dynamic-content';
newParagraph.id = 'intro-text';

// Create more complex elements
const newLink = document.createElement('a');
newLink.href = 'https://example.com';
newLink.textContent = 'Visit Example';
newLink.target = '_blank';

// Append the link to the paragraph
newParagraph.appendChild(newLink);</code></pre>
            </div>

            <h3>Inserting Elements into the DOM</h3>
            <div class="mermaid">
                graph TD
                parent[Parent Element]
                firstChild[First Child]
                middleChild[Middle Child]
                lastChild[Last Child]
                newElement[New Element]
                
                parent --> firstChild
                parent --> middleChild
                parent --> lastChild
                
                parent -.appendChild.-> newElement
                parent -.insertBefore.-> newElement
                firstChild -.before.-> newElement
                middleChild -.after.-> newElement
                parent -.prepend.-> newElement
                
                style newElement fill:#ffcccc,stroke:#ff0000,stroke-width:2px
            </div>

            <div class="code-example">
                <pre><code>const container = document.querySelector('.container');
const referenceElement = document.querySelector('.existing-element');

// Old methods
// Append as the last child
container.appendChild(newParagraph);

// Insert before a specific element
container.insertBefore(newParagraph, referenceElement);

// Modern methods
// Append one or more elements as the last children
container.append(newParagraph, newLink); // Can append multiple elements

// Prepend as the first child(ren)
container.prepend(newParagraph);

// Insert before a specific element
referenceElement.before(newParagraph);

// Insert after a specific element
referenceElement.after(newParagraph);</code></pre>
            </div>

            <h3>Removing Elements</h3>
            <div class="code-example">
                <pre><code>// Modern method
element.remove();

// Old method (still works everywhere)
element.parentNode.removeChild(element);

// Removing all children from an element
// Method 1: Clear innerHTML
container.innerHTML = '';

// Method 2: Remove children in a loop
while (container.firstChild) {
  container.removeChild(container.firstChild);
}

// Method 3: Modern approach
container.replaceChildren(); // Removes all children</code></pre>
            </div>

            <h3>Cloning Elements</h3>
            <div class="code-example">
                <pre><code>// Clone an element (false means don't clone children)
const shallowCopy = element.cloneNode(false);

// Clone an element and all its descendants (deep copy)
const deepCopy = element.cloneNode(true);

// Clone, modify, and insert
const template = document.querySelector('.card-template');
const newCard = template.cloneNode(true);
newCard.querySelector('.card-title').textContent = 'New Product';
newCard.querySelector('.card-price').textContent = '$49.99';
container.appendChild(newCard);</code></pre>
            </div>

            <div class="real-world-example">
                <h4>Real-World Example: Dynamic List Generation</h4>
                <p>Creating a list of items from data:</p>
                <div class="code-example">
                    <pre><code>// Data from an API or other source
const products = [
  { id: 1, name: 'Smartphone', price: 699, inStock: true },
  { id: 2, name: 'Laptop', price: 1299, inStock: false },
  { id: 3, name: 'Headphones', price: 199, inStock: true },
  { id: 4, name: 'Tablet', price: 499, inStock: true }
];

// Get container element
const productList = document.getElementById('product-list');

// Clear existing content
productList.innerHTML = '';

// Create and append product elements
products.forEach(product => {
  // Create elements
  const productCard = document.createElement('div');
  const productName = document.createElement('h3');
  const productPrice = document.createElement('p');
  const productStatus = document.createElement('span');
  const addButton = document.createElement('button');
  
  // Add classes and content
  productCard.className = 'product-card';
  productCard.dataset.productId = product.id;
  
  productName.textContent = product.name;
  productName.className = 'product-name';
  
  productPrice.textContent = `$${product.price}`;
  productPrice.className = 'product-price';
  
  productStatus.textContent = product.inStock ? 'In Stock' : 'Out of Stock';
  productStatus.className = product.inStock ? 'in-stock' : 'out-of-stock';
  
  addButton.textContent = 'Add to Cart';
  addButton.className = 'add-to-cart';
  addButton.disabled = !product.inStock;
  
  // Add event listener to button
  addButton.addEventListener('click', function() {
    console.log(`Added ${product.name} to cart`);
    // Add to cart functionality would go here
  });
  
  // Assemble the card
  productCard.appendChild(productName);
  productCard.appendChild(productPrice);
  productCard.appendChild(productStatus);
  productCard.appendChild(addButton);
  
  // Add to the list
  productList.appendChild(productCard);
});</code></pre>
                </div>
            </div>
        </section>

        <section class="efficiency-performance">
            <h2>Efficiency and Performance Considerations</h2>
            <p>DOM manipulation can be expensive in terms of performance. Here are best practices to keep your web applications fast and responsive:</p>

            <h3>Document Fragments</h3>
            <p>When adding multiple elements, use a DocumentFragment to batch changes and reduce reflows:</p>
            <div class="code-example">
                <pre><code>// Inefficient way (causes multiple reflows)
const list = document.getElementById('large-list');
for (let i = 0; i < 100; i++) {
  const item = document.createElement('li');
  item.textContent = `Item ${i}`;
  list.appendChild(item); // Browser reflows each time!
}

// Efficient way using DocumentFragment
const list = document.getElementById('large-list');
const fragment = document.createDocumentFragment(); // Create a fragment

for (let i = 0; i < 100; i++) {
  const item = document.createElement('li');
  item.textContent = `Item ${i}`;
  fragment.appendChild(item); // Append to fragment (no reflow)
}

list.appendChild(fragment); // Single DOM update and reflow</code></pre>
            </div>

            <div class="analogy">
                <h3>Document Fragment as a Shopping List</h3>
                <p>Think of DOM manipulation without fragments like making many trips to the grocery store, buying one item at a time. Using DocumentFragment is like making a complete shopping list first, then making a single trip to buy everything at once.</p>
            </div>

            <h3>Batch DOM Operations</h3>
            <p>Group your DOM operations to minimize style recalculations and layout reflows:</p>
            <div class="code-example">
                <pre><code>// Inefficient pattern
element.style.width = '100px';
element.style.height = '100px';
element.style.backgroundColor = 'red';
element.style.fontSize = '14px';
element.style.border = '1px solid black';

// More efficient pattern
// Option 1: Use cssText
element.style.cssText = 'width: 100px; height: 100px; background-color: red; font-size: 14px; border: 1px solid black;';

// Option 2: Use a class instead of inline styles
element.className = 'styled-box';

// Option 3: Batch operations with Object.assign
Object.assign(element.style, {
  width: '100px',
  height: '100px',
  backgroundColor: 'red',
  fontSize: '14px',
  border: '1px solid black'
});</code></pre>
            </div>

            <h3>Read Properties First, Then Write</h3>
            <p>Grouping read operations and write operations can prevent forced synchronous layouts:</p>
            <div class="code-example">
                <pre><code>// Inefficient pattern (forces layout recalculation)
for (let i = 0; i < elements.length; i++) {
  const height = elements[i].offsetHeight; // Read
  elements[i].style.height = (height * 2) + 'px'; // Write
  // Browser recalculates layout before reading next height
}

// More efficient pattern
const heights = [];
// Read phase
for (let i = 0; i < elements.length; i++) {
  heights.push(elements[i].offsetHeight);
}
// Write phase
for (let i = 0; i < elements.length; i++) {
  elements[i].style.height = (heights[i] * 2) + 'px';
}</code></pre>
            </div>

            <h3>Avoid Frequent DOM Updates</h3>
            <p>Minimize updates, especially in loops or frequently firing events like scroll:</p>
            <div class="code-example">
                <pre><code>// Poor performance with many updates
window.addEventListener('scroll', function() {
  element.style.opacity = getOpacityValue();
  element.style.transform = getTransformValue();
});

// Better performance with throttling
let ticking = false;

window.addEventListener('scroll', function() {
  if (!ticking) {
    window.requestAnimationFrame(function() {
      element.style.opacity = getOpacityValue();
      element.style.transform = getTransformValue();
      ticking = false;
    });
    ticking = true;
  }
});</code></pre>
            </div>
        </section>

        <section class="practical-examples">
            <h2>Practical Examples</h2>
            
            <h3>Image Gallery with Filtering</h3>
            <p>Create an interactive image gallery with category filtering:</p>
            <div class="code-example">
                <pre><code>// HTML structure
&lt;div class="gallery-filters"&gt;
  &lt;button class="filter-btn active" data-filter="all"&gt;All&lt;/button&gt;
  &lt;button class="filter-btn" data-filter="nature"&gt;Nature&lt;/button&gt;
  &lt;button class="filter-btn" data-filter="architecture"&gt;Architecture&lt;/button&gt;
  &lt;button class="filter-btn" data-filter="people"&gt;People&lt;/button&gt;
&lt;/div&gt;

&lt;div class="gallery"&gt;
  &lt;div class="gallery-item" data-category="nature"&gt;
    &lt;img src="nature1.jpg" alt="Forest"&gt;
    &lt;h3&gt;Forest&lt;/h3&gt;
  &lt;/div&gt;
  &lt;div class="gallery-item" data-category="architecture"&gt;
    &lt;img src="building1.jpg" alt="Modern Building"&gt;
    &lt;h3&gt;Modern Building&lt;/h3&gt;
  &lt;/div&gt;
  &lt;!-- More gallery items... --&gt;
&lt;/div&gt;

// JavaScript
document.addEventListener('DOMContentLoaded', function() {
  const filterButtons = document.querySelectorAll('.filter-btn');
  const galleryItems = document.querySelectorAll('.gallery-item');
  
  // Add click event to filter buttons
  filterButtons.forEach(button => {
    button.addEventListener('click', function() {
      // Remove active class from all buttons
      filterButtons.forEach(btn => btn.classList.remove('active'));
      
      // Add active class to clicked button
      this.classList.add('active');
      
      // Get filter value
      const filterValue = this.getAttribute('data-filter');
      
      // Filter gallery items
      galleryItems.forEach(item => {
        if (filterValue === 'all' || item.getAttribute('data-category') === filterValue) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    });
  });
});</code></pre>
            </div>

            <h3>Dynamic Form Fields</h3>
            <p>Adding and removing form fields dynamically:</p>
            <div class="code-example">
                <pre><code>// HTML
&lt;form id="dynamic-form"&gt;
  &lt;div id="fields-container"&gt;
    &lt;div class="form-field"&gt;
      &lt;input type="text" name="item[]" placeholder="Enter item"&gt;
      &lt;button type="button" class="remove-field" disabled&gt;Remove&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;button type="button" id="add-field-btn"&gt;Add Another Item&lt;/button&gt;
  &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;

// JavaScript
document.addEventListener('DOMContentLoaded', function() {
  const form = document.getElementById('dynamic-form');
  const fieldsContainer = document.getElementById('fields-container');
  const addButton = document.getElementById('add-field-btn');
  
  // Add new field when button is clicked
  addButton.addEventListener('click', function() {
    // Create new field
    const newField = document.createElement('div');
    newField.className = 'form-field';
    
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.name = 'item[]';
    newInput.placeholder = 'Enter item';
    
    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.className = 'remove-field';
    removeButton.textContent = 'Remove';
    
    // Add event listener to remove button
    removeButton.addEventListener('click', function() {
      fieldsContainer.removeChild(newField);
      updateRemoveButtons();
    });
    
    // Assemble and append the new field
    newField.appendChild(newInput);
    newField.appendChild(removeButton);
    fieldsContainer.appendChild(newField);
    
    // Update remove buttons
    updateRemoveButtons();
  });
  
  // Function to update remove buttons state
  function updateRemoveButtons() {
    const fields = fieldsContainer.querySelectorAll('.form-field');
    const removeButtons = fieldsContainer.querySelectorAll('.remove-field');
    
    // Disable remove buttons if only one field
    if (fields.length === 1) {
      removeButtons[0].disabled = true;
    } else {
      // Enable all remove buttons
      removeButtons.forEach(button => {
        button.disabled = false;
      });
    }
  }
  
  // Form submission
  form.addEventListener('submit', function(event) {
    event.preventDefault();
    
    // Get all input values
    const inputs = form.querySelectorAll('input[name="item[]"]');
    const values = Array.from(inputs).map(input => input.value);
    
    console.log('Submitted values:', values);
    // Submit to server would go here
  });
});</code></pre>
            </div>

            <h3>Interactive Data Table</h3>
            <p>Creating a sortable, filterable data table:</p>
            <div class="code-example">
                <pre><code>// HTML
&lt;div class="table-controls"&gt;
  &lt;input type="text" id="table-search" placeholder="Search..."&gt;
&lt;/div&gt;

&lt;table id="data-table"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th data-sort="name"&gt;Name&lt;/th&gt;
      &lt;th data-sort="age"&gt;Age&lt;/th&gt;
      &lt;th data-sort="city"&gt;City&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;!-- Data rows will be inserted here --&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

// JavaScript
document.addEventListener('DOMContentLoaded', function() {
  // Sample data
  const people = [
    { id: 1, name: 'John Smith', age: 32, city: 'New York' },
    { id: 2, name: 'Jane Doe', age: 28, city: 'Los Angeles' },
    { id: 3, name: 'Bob Johnson', age: 45, city: 'Chicago' },
    { id: 4, name: 'Alice Williams', age: 24, city: 'Miami' }
    // More data...
  ];
  
  const table = document.getElementById('data-table');
  const tableBody = table.querySelector('tbody');
  const searchInput = document.getElementById('table-search');
  const sortHeaders = table.querySelectorAll('th[data-sort]');
  
  // Variables to track sort state
  let sortColumn = 'name';
  let sortDirection = 'asc';
  
  // Initial render
  renderTable(people);
  
  // Add search functionality
  searchInput.addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase();
    const filteredData = people.filter(person => {
      return (
        person.name.toLowerCase().includes(searchTerm) ||
        person.city.toLowerCase().includes(searchTerm) ||
        person.age.toString().includes(searchTerm)
      );
    });
    renderTable(filteredData);
  });
  
  // Add sorting functionality
  sortHeaders.forEach(header => {
    header.addEventListener('click', function() {
      const column = this.getAttribute('data-sort');
      
      // Update sort direction
      if (sortColumn === column) {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        sortColumn = column;
        sortDirection = 'asc';
      }
      
      // Update UI to show sort direction
      sortHeaders.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
      this.classList.add(`sort-${sortDirection}`);
      
      // Sort and render data
      const sortedData = [...people].sort((a, b) => {
        if (sortDirection === 'asc') {
          return a[column] > b[column] ? 1 : -1;
        } else {
          return a[column] < b[column] ? 1 : -1;
        }
      });
      
      renderTable(sortedData);
    });
  });
  
  // Function to render table
  function renderTable(data) {
    // Clear existing rows
    tableBody.innerHTML = '';
    
    // Create document fragment for better performance
    const fragment = document.createDocumentFragment();
    
    // Add data rows
    data.forEach(person => {
      const row = document.createElement('tr');
      
      const nameCell = document.createElement('td');
      nameCell.textContent = person.name;
      
      const ageCell = document.createElement('td');
      ageCell.textContent = person.age;
      
      const cityCell = document.createElement('td');
      cityCell.textContent = person.city;
      
      row.appendChild(nameCell);
      row.appendChild(ageCell);
      row.appendChild(cityCell);
      
      fragment.appendChild(row);
    });
    
    // Add to table in one operation
    tableBody.appendChild(fragment);
  }
});</code></pre>
            </div>
        </section>

        <section class="advanced-topics">
            <h2>Advanced DOM Manipulation Techniques</h2>
            
            <h3>Template Elements</h3>
            <p>Using the HTML5 <code>&lt;template&gt;</code> element for reusable DOM fragments:</p>
            <div class="code-example">
                <pre><code>// HTML
&lt;template id="user-card-template"&gt;
  &lt;div class="user-card"&gt;
    &lt;img class="user-avatar" src="" alt="User"&gt;
    &lt;h3 class="user-name"&gt;&lt;/h3&gt;
    &lt;p class="user-email"&gt;&lt;/p&gt;
    &lt;button class="contact-btn"&gt;Contact&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;div id="user-container"&gt;&lt;/div&gt;

// JavaScript
const template = document.getElementById('user-card-template');
const container = document.getElementById('user-container');

// Sample user data
const users = [
  { id: 1, name: 'Alex Johnson', email: 'alex@example.com', avatar: 'avatar1.jpg' },
  { id: 2, name: 'Sarah Williams', email: 'sarah@example.com', avatar: 'avatar2.jpg' }
];

users.forEach(user => {
  // Clone the template content
  const userCard = template.content.cloneNode(true);
  
  // Update content
  userCard.querySelector('.user-name').textContent = user.name;
  userCard.querySelector('.user-email').textContent = user.email;
  userCard.querySelector('.user-avatar').src = user.avatar;
  
  // Add event listener
  userCard.querySelector('.contact-btn').addEventListener('click', function() {
    console.log(`Contact ${user.name}`);
  });
  
  // Add to the container
  container.appendChild(userCard);
});</code></pre>
            </div>

            <h3>DOM Range API</h3>
            <p>Working with text selections and ranges:</p>
            <div class="code-example">
                <pre><code>// Create a range
const range = document.createRange();

// Select content between nodes
const startNode = document.getElementById('start-content');
const endNode = document.getElementById('end-content');
range.setStartAfter(startNode);
range.setEndBefore(endNode);

// Extract content
const documentFragment = range.extractContents();
container.appendChild(documentFragment);

// Delete content
range.deleteContents();

// Insert content
const newNode = document.createElement('p');
newNode.textContent = 'New content';
range.insertNode(newNode);</code></pre>
            </div>

            <h3>DOM Mutation Observer</h3>
            <p>Watching for changes in the DOM:</p>
            <div class="code-example">
                <pre><code>// Select the node to observe
const targetNode = document.getElementById('watched-content');

// Configure the observer
const config = { 
  attributes: true, 
  childList: true, 
  subtree: true,
  attributeOldValue: true
};

// Callback function to execute when mutations are observed
const callback = function(mutationsList, observer) {
  for (const mutation of mutationsList) {
    if (mutation.type === 'childList') {
      console.log('A child node has been added or removed');
      console.log('Added nodes:', mutation.addedNodes);
      console.log('Removed nodes:', mutation.removedNodes);
    }
    else if (mutation.type === 'attributes') {
      console.log(`The ${mutation.attributeName} attribute was modified`);
      console.log('Old value:', mutation.oldValue);
      console.log('New value:', mutation.target.getAttribute(mutation.attributeName));
    }
  }
};

// Create an observer instance linked to the callback function
const observer = new MutationObserver(callback);

// Start observing the target node
observer.observe(targetNode, config);

// Later, you can stop observing
// observer.disconnect();</code></pre>
            </div>
        </section>

        <section class="browser-compatibility">
            <h2>Browser Compatibility Considerations</h2>
            <p>While modern browsers mostly implement DOM APIs consistently, some differences remain:</p>
            
            <h3>Feature Detection</h3>
            <p>Always check if a feature is available before using it:</p>
            <div class="code-example">
                <pre><code>// Check if a method exists
if (element.classList) {
  element.classList.add('active');
} else {
  // Fallback for older browsers
  const classes = element.className.split(' ');
  if (classes.indexOf('active') === -1) {
    element.className += ' active';
  }
}

// Check for modern DOM methods
if ('querySelector' in document) {
  // Use querySelector
} else {
  // Use older methods like getElementById
}

// Check for template element support
const supportsTemplate = 'content' in document.createElement('template');
if (supportsTemplate) {
  // Use template element
} else {
  // Fallback implementation
}</code></pre>
            </div>

            <h3>Browser Vendor Prefixes</h3>
            <p>Some CSS properties in JavaScript still need vendor prefixes:</p>
            <div class="code-example">
                <pre><code>// Apply transform with vendor prefixes
function setTransform(element, transformValue) {
  element.style.webkitTransform = transformValue;
  element.style.mozTransform = transformValue;
  element.style.msTransform = transformValue;
  element.style.oTransform = transformValue;
  element.style.transform = transformValue;
}</code></pre>
            </div>
        </section>

        <section class="summary">
            <h2>Key Takeaways</h2>
            <ul>
                <li><strong>Selection Methods:</strong> Choose the right method based on specificity and flexibility needs (getElementById, querySelector, etc.)</li>
                <li><strong>Content Manipulation:</strong> Use textContent for text-only changes (safer) and innerHTML when HTML structure changes are needed</li>
                <li><strong>Class Manipulation:</strong> Use classList API for modern, clean class manipulation</li>
                <li><strong>Attributes & Properties:</strong> Understand the difference between attributes and properties</li>
                <li><strong>Element Creation:</strong> Use createElement for dynamic content generation</li>
                <li><strong>Performance:</strong> Batch DOM operations and use DocumentFragment for better performance</li>
                <li><strong>Best Practices:</strong> Prefer class manipulation over direct style manipulation when possible</li>
            </ul>
        </section>

        <section class="exercises">
            <h2>Practice Exercises</h2>
            <ol>
                <li>
                    <strong>Tabbed Interface:</strong> Create a tabbed interface where clicking tab headers shows different content panels.
                </li>
                <li>
                    <strong>Dynamic Shopping List:</strong> Build a shopping list that allows adding, editing, and removing items with local storage persistence.
                </li>
                <li>
                    <strong>Image Carousel:</strong> Create an image carousel/slider that cycles through images with next/previous buttons.
                </li>
                <li>
                    <strong>Form Validation:</strong> Build a registration form with real-time validation and error messages.
                </li>
                <li>
                    <strong>DOM Tree Visualizer:</strong> Create a tool that displays a visual representation of a simple DOM structure.
                </li>
            </ol>
        </section>

        <section class="further-resources">
            <h2>Further Resources</h2>
            <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">MDN Web Docs: Document Object Model</a></li>
                <li><a href="https://javascript.info/dom-nodes">JavaScript.info: DOM Nodes</a></li>
                <li><a href="https://www.w3schools.com/js/js_htmldom.asp">W3Schools: JavaScript HTML DOM</a></li>
                <li><a href="https://htmldom.dev/">HTML DOM: Practical DOM manipulation tasks</a></li>
            </ul>
        </section>
    </main>
    
    <footer>
        <p>&copy; 2025 PHP WordPress Development Course</p>
        <p><a href="module1.html">← Back to Module 1</a> | <a href="modern_javascript_jquery.html">Next Session: Modern JavaScript & jQuery →</a></p>
    </footer>
</body>
</html>
