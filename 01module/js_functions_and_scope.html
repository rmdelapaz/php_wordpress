<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="ie=edge" http-equiv="X-UA-Compatible"/>
<!-- SEO Meta Tags -->
<title>JavaScript Functions and Scope</title>
<meta content="JavaScript Functions and Scope" name="description"/>
<meta content="PHP, WordPress, web development, functions, and, scope" name="keywords"/>
<meta content="PHP WordPress Course" name="author"/>
<!-- Favicon -->
<link href="/favicon.png" rel="icon" type="image/png"/>
<link href="/favicon.png" rel="apple-touch-icon"/>
<!-- CSS -->
<link href="/assets/css/main.css" rel="stylesheet"/>
<!-- Mermaid for diagrams -->
<script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true
            },
            securityLevel: 'loose'
        });
    </script>
</head>
<body>
<!-- Skip to main content -->
<a class="sr-only" href="#main-content">Skip to main content</a>
<div class="page-wrapper">
<!-- Header -->
<header class="site-header" role="banner">
<div class="header-container">
<div class="site-branding">
<a class="site-logo" href="/">
<h1 class="site-title">PHP WordPress Development</h1>
</a>
</div>
<nav aria-label="Main navigation" class="main-navigation" role="navigation">
<button aria-expanded="false" aria-label="Toggle navigation" class="mobile-menu-btn">
<span></span>
<span></span>
<span></span>
</button>
<div class="nav-menu">
<ul class="nav-list">
<li class="nav-item"><a class="nav-link" href="/">Home</a></li>
<li class="nav-item dropdown">
<button aria-haspopup="true" class="nav-link dropdown-toggle active">Modules</button>
<div class="dropdown-menu">
<a class="dropdown-item active" href="/module1.html">Module 1: Web Fundamentals</a>
<a class="dropdown-item" href="/module2.html">Module 2: PHP Fundamentals</a>
<a class="dropdown-item" href="/module3.html">Module 3: MySQL Database</a>
<a class="dropdown-item" href="/module4.html">Module 4: WordPress &amp; Docker</a>
<a class="dropdown-item" href="/module5.html">Module 5: Theme Development</a>
<a class="dropdown-item" href="/module6.html">Module 6: Plugin Development</a>
<a class="dropdown-item" href="/module7.html">Module 7: Advanced WordPress</a>
<a class="dropdown-item" href="/module8.html">Module 8: Deployment</a>
<a class="dropdown-item" href="/module9.html">Module 9: Final Project</a>
</div>
</li>
<li class="nav-item"><a class="nav-link" href="/resources.html">Resources</a></li>
<li class="nav-item"><a class="nav-link" href="/about.html">About</a></li>
</ul>
</div>
</nav>
<div class="search-container">
<div class="search-input-wrapper">
<svg class="search-icon" fill="currentColor" height="20" viewbox="0 0 20 20" width="20">
<path clip-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" fill-rule="evenodd"></path>
</svg>
<input aria-label="Search" class="search-input" placeholder="Search lessons..." type="search"/>
</div>
<div class="search-results"></div>
</div>
</div>
</header>
<!-- Progress Bar -->
<div class="progress-container">
<div class="progress-header">
<h2 class="progress-title">Course Progress</h2>
<span class="progress-text">Loading...</span>
</div>
<div class="progress-bar">
<div class="progress-bar-fill">
<span class="progress-bar-text"></span>
</div>
</div>
</div>
<!-- Breadcrumb -->
<nav aria-label="Breadcrumb" class="breadcrumb container">
<ol class="breadcrumb-list">
<li class="breadcrumb-item">
<a href="/">Home</a>
<span class="breadcrumb-separator">/</span>
</li>
<li class="breadcrumb-item">
<a href="/module1.html">Module 1</a>
<span class="breadcrumb-separator">/</span>
</li>
<li class="breadcrumb-item">
<span aria-current="page">Functions and Scope</span>
</li>
</ol>
</nav>
<!-- Main Content -->
<main class="main-content" id="main-content" role="main">
<div class="container">
<div class="content-with-sidebar">
<!-- Sidebar -->
<aside class="sidebar">

<div class="sidebar-nav">
<h3 class="sidebar-title">Module 1: Web Fundamentals</h3>
<div class="sidebar-section">
<h4 class="sidebar-section-title">Lessons</h4>
<ul class="sidebar-menu">
<li><a class="sidebar-link" href="/01module/course_introduction.html">1.1 Course Introduction</a></li>
<li><a class="sidebar-link" href="/01module/first_html_page.html">1.2 Your First HTML Page</a></li>
<li><a class="sidebar-link" href="/01module/introduction_to_css.html">1.3 Introduction to CSS</a></li>
<li><a class="sidebar-link" href="/01module/js_intro.html">1.4 JavaScript Introduction</a></li>
<li><a class="sidebar-link" href="/01module/php_and_wordpress.html">1.5 PHP and WordPress Overview</a></li>
<li><a class="sidebar-link" href="/01module/php_header_footer.html">1.6 PHP Headers and Footers</a></li>
<li><a class="sidebar-link" href="/01module/project_static_site.html">1.7 Project: Static Website</a></li>
</ul>
</div>
<div class="sidebar-section">
<h4 class="sidebar-section-title">Module Resources</h4>
<ul class="sidebar-menu">
<li><a class="sidebar-link" href="/module1.html">Module Overview</a></li>
<li><a class="sidebar-link" href="/resources.html">Additional Resources</a></li>
</ul>
</div>
</div></aside>
<!-- Main Lesson Content -->
<article class="lesson-content">
<header class="lesson-header">
<h1>JavaScript Functions and Scope</h1>
<div class="lesson-meta">
<div class="lesson-meta-item">
<svg fill="currentColor" height="20" width="20">
<path d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<span>Duration: 45 minutes</span>
</div>
<div class="lesson-meta-item">
<svg fill="currentColor" height="20" width="20">
<path d="M12 14l9-5-9-5-9 5 9 5z"></path>
</svg>
<span>Module 1: JavaScript Fundamentals</span>
</div>
</div>
</header>
<!-- Learning Objectives -->
<div class="lesson-objectives">
<h2>Learning Objectives</h2>
<ul>
<li>Master the concepts in this lesson</li>
<li>Apply knowledge through practice</li>
<li>Build practical skills</li>
<li>Prepare for next topics</li>
</ul>
</div>
<!-- Lesson Body -->
<div class="lesson-body">
<section class="introduction">
<h2>Understanding Functions: The Building Blocks of JavaScript</h2>
<p>Functions are one of the fundamental building blocks in JavaScript. Think of functions as self-contained recipes or instruction sets that perform specific tasks. They allow you to structure your code into reusable, modular components that make your programs more organized, maintainable, and efficient.</p>
<div class="concept-visualization">
<pre class="mermaid">
                    graph TD
                    A[JavaScript Functions] --&gt; B[Code Reusability]
                    A --&gt; C[Modularity]
                    A --&gt; D[Abstraction]
                    A --&gt; E[Encapsulation]
                    
                    B --&gt; B1["Write once,<br/>use many times"]
                    C --&gt; C1["Break complex problems<br/>into smaller parts"]
                    D --&gt; D1["Hide implementation<br/>details"]
                    E --&gt; E1["Group related code<br/>and data together"]
                </pre>
</div>
<p>In everyday life, we frequently follow procedures that are similar to functions. For example, making coffee might involve several steps: boiling water, measuring coffee grounds, filtering, and pouring. Rather than explaining these steps in detail every time you want coffee, you simply say "I'm making coffee." Functions in programming work the same way—they package a set of instructions under a single name that can be "called" whenever needed.</p>
<div class="real-world-analogy">
<h3>Function Analogy: Vending Machine</h3>
<div class="svg-container">
<svg viewbox="0 0 600 300" xmlns="http://www.w3.org/2000/svg">
<!-- Vending Machine Outline -->
<rect fill="#d0d0d0" height="250" rx="10" stroke="#333" stroke-width="2" width="200" x="50" y="30"></rect>
<!-- Machine Display -->
<rect fill="#333" height="30" rx="5" width="160" x="70" y="50"></rect>
<text fill="white" font-family="Arial" font-size="14" text-anchor="middle" x="150" y="70">SELECT PRODUCT</text>
<!-- Product Buttons -->
<rect fill="#f0f0f0" height="30" rx="3" stroke="#333" width="30" x="80" y="100"></rect>
<text font-family="Arial" font-size="14" text-anchor="middle" x="95" y="120">A1</text>
<rect fill="#f0f0f0" height="30" rx="3" stroke="#333" width="30" x="130" y="100"></rect>
<text font-family="Arial" font-size="14" text-anchor="middle" x="145" y="120">A2</text>
<rect fill="#f0f0f0" height="30" rx="3" stroke="#333" width="30" x="180" y="100"></rect>
<text font-family="Arial" font-size="14" text-anchor="middle" x="195" y="120">A3</text>
<!-- Coin Slot -->
<rect fill="#555" height="10" rx="2" width="50" x="80" y="160"></rect>
<text font-family="Arial" font-size="12" text-anchor="middle" x="105" y="185">INSERT COINS</text>
<!-- Dispensing Area -->
<rect fill="#444" height="40" rx="5" stroke="#222" width="120" x="90" y="220"></rect>
<text fill="white" font-family="Arial" font-size="12" text-anchor="middle" x="150" y="245">PRODUCT HERE</text>
<!-- Arrow -->
<line marker-end="url(#arrow)" stroke="#000" stroke-width="2" x1="260" x2="330" y1="150" y2="150"></line>
<!-- Function Representation -->
<rect fill="#f0f0f0" height="250" rx="10" stroke="#333" stroke-width="2" width="220" x="340" y="30"></rect>
<text font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" x="450" y="60">getProduct(money, selection)</text>
<!-- Function Internals -->
<rect fill="#fff" height="170" rx="5" stroke="#999" width="180" x="360" y="80"></rect>
<!-- Function Steps -->
<text font-family="Arial" font-size="14" x="370" y="110">1. Validate money input</text>
<text font-family="Arial" font-size="14" x="370" y="140">2. Check product availability</text>
<text font-family="Arial" font-size="14" x="370" y="170">3. Process selection</text>
<text font-family="Arial" font-size="14" x="370" y="200">4. Dispense product</text>
<text font-family="Arial" font-size="14" x="370" y="230">5. Return any change</text>
<!-- Arrow definition -->
<defs>
<marker id="arrow" markerheight="10" markerwidth="10" orient="auto" refx="9" refy="3">
<path d="M0,0 L0,6 L9,3 z" fill="#000"></path>
</marker>
</defs>
</svg>
</div>
<p>A vending machine is an excellent analogy for a function. You provide inputs (money and a product selection), and after some internal processing that you don't need to understand, you receive an output (your selected product and possibly change). The vending machine encapsulates the complexity of product dispensing behind a simple interface.</p>
</div>
</section>
<section class="function_basics">
<h2>Function Basics: Declaration, Execution, and Return Values</h2>
<p>Let's start by exploring how to create and use functions in JavaScript. There are several ways to define functions, but we'll begin with the most common approach.</p>
<h3>Function Declaration Syntax</h3>
<div class="code-example">
<pre><code>// Basic function declaration
function functionName(parameter1, parameter2, ...) {
    // Function body - the code to be executed
    
    // Optional return statement
    return value;
}

// Example: Simple greeting function
function greet(name) {
    return "Hello, " + name + "!";
}

// Calling/invoking the function
let greeting = greet("John");
console.log(greeting);  // Output: "Hello, John!"</code></pre>
</div>
<pre class="mermaid">
                flowchart TD
                    A[Function Declaration] --&gt; B[Function Name]
                    A --&gt; C[Parameters<br/>list]
                    A --&gt; D[Function Body]
                    D --&gt; E[Code to Execute]
                    D --&gt; F[Return Statement<br/>optional]
                    
                    G[Function Invocation] --&gt; H["functionName(arguments)"]
                    H --&gt; I[Execute Function Body]
                    I --&gt; J[Return Value to Caller]
            </pre>
<h3>Function Components</h3>
<div class="components-explanation">
<ul>
<li><strong>Function Keyword</strong>: The <code>function</code> keyword is used to declare a function</li>
<li><strong>Function Name</strong>: An identifier that follows JavaScript naming rules (starts with letter, $, or _, followed by letters, numbers, $, or _)</li>
<li><strong>Parameters</strong>: Placeholders for values that are passed to the function (inputs)</li>
<li><strong>Function Body</strong>: The code block containing statements that are executed when the function is called</li>
<li><strong>Return Statement</strong>: Specifies the value that the function sends back to the caller (output)</li>
<li><strong>Arguments</strong>: The actual values passed to the function when it's called</li>
</ul>
</div>
<h3>Function Invocation (Calling a Function)</h3>
<div class="code-example">
<pre><code>// Different ways to call a function
function multiplyNumbers(a, b) {
    return a * b;
}

// 1. Direct invocation
let result1 = multiplyNumbers(5, 3);  // result1 = 15

// 2. Using the result in an expression
let total = 100 + multiplyNumbers(4, 2);  // total = 108

// 3. Passing the result to another function
console.log(multiplyNumbers(7, 6));  // Output: 42

// 4. Using function call as an argument to another function
function applyOperation(x, y, operation) {
    return operation(x, y);
}

let result2 = applyOperation(8, 4, multiplyNumbers);  // result2 = 32</code></pre>
</div>
<h3>Return Values</h3>
<p>The <code>return</code> statement specifies the value that a function outputs. Once a return statement is executed, the function immediately terminates and sends the value back to where the function was called.</p>
<div class="code-example">
<pre><code>// Functions with return values
function add(a, b) {
    return a + b;  // Returns the sum of a and b
}

// No explicit return - functions return undefined by default
function logMessage(message) {
    console.log(message);
    // No return statement, so this function returns undefined
}

// Multiple return statements (with conditional logic)
function getAbsoluteValue(number) {
    if (number &gt;= 0) {
        return number;  // Return positive numbers as-is
    } else {
        return -number;  // Negate negative numbers
    }
}

// Early return pattern
function validateUsername(username) {
    // Check for minimum length
    if (username.length &lt; 3) {
        return "Username must be at least 3 characters long";
    }
    
    // Check for invalid characters
    if (!/^[a-zA-Z0-9_]+$/.test(username)) {
        return "Username can only contain letters, numbers, and underscores";
    }
    
    // If we get here, the username is valid
    return true;
}</code></pre>
</div>
<div class="important-note">
<h3>Important Notes About Return Values</h3>
<ul>
<li>A function can have multiple <code>return</code> statements, but only one will be executed</li>
<li>If no <code>return</code> statement is encountered, the function returns <code>undefined</code></li>
<li>A function can return any type of value (number, string, boolean, object, array, another function, etc.)</li>
<li>The <code>return</code> statement without a value (<code>return;</code>) also returns <code>undefined</code></li>
<li>Code after a <code>return</code> statement is unreachable (never executed)</li>
</ul>
</div>
<h3>Parameters and Arguments</h3>
<p>Parameters are the names listed in the function definition, while arguments are the actual values passed to the function when it's called.</p>
<div class="code-example">
<pre><code>// Parameters vs Arguments
//              parameters
function createGreeting(greeting, name) {
    return `${greeting}, ${name}!`;
}

//                   arguments
let message = createGreeting("Good morning", "Sarah");

// Default parameters (ES6+)
function calculateTotal(price, taxRate = 0.07, shipping = 5.99) {
    return price + (price * taxRate) + shipping;
}

// Using default parameters
let total1 = calculateTotal(29.99);  // Uses default taxRate and shipping
let total2 = calculateTotal(29.99, 0.05);  // Uses default shipping only
let total3 = calculateTotal(29.99, 0.05, 0);  // Specifies all parameters

// Rest parameters (ES6+) - handling multiple arguments
function sum(...numbers) {
    let total = 0;
    for (let number of numbers) {
        total += number;
    }
    return total;
}

console.log(sum(1, 2));  // 3
console.log(sum(1, 2, 3, 4, 5));  // 15</code></pre>
</div>
<h3>Function Expressions</h3>
<p>Besides function declarations, JavaScript allows functions to be defined using expressions. A function expression defines a function as part of a larger expression, typically a variable assignment.</p>
<div class="code-example">
<pre><code>// Function expression
const multiply = function(a, b) {
    return a * b;
};

// Using the function expression
let product = multiply(4, 6);  // 24

// Anonymous function expression (no name)
const greet = function(name) {
    return `Hello, ${name}!`;
};

// Named function expression (useful for recursion and debugging)
const factorial = function calculateFactorial(n) {
    if (n &lt;= 1) return 1;
    return n * calculateFactorial(n - 1);
};

console.log(factorial(5));  // 120</code></pre>
</div>
<div class="comparison-table">
<h3>Function Declarations vs. Function Expressions</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Function Declaration</th>
<th>Function Expression</th>
</tr>
</thead>
<tbody>
<tr>
<td>Syntax</td>
<td><code>function name() {}</code></td>
<td><code>const name = function() {}</code></td>
</tr>
<tr>
<td>Hoisting</td>
<td>Fully hoisted (can call before definition)</td>
<td>Not hoisted (cannot call before definition)</td>
</tr>
<tr>
<td>Name</td>
<td>Name is required</td>
<td>Name is optional</td>
</tr>
<tr>
<td>Usage</td>
<td>Standalone functions</td>
<td>When functions are assigned to variables/properties</td>
</tr>
<tr>
<td>Mental Model</td>
<td>"This is a function"</td>
<td>"This is a variable that holds a function"</td>
</tr>
</tbody>
</table>
</div>
</section>
<section class="arrow_functions">
<h2>Arrow Functions: Modern JavaScript Syntax</h2>
<p>Introduced in ES6 (2015), arrow functions provide a more concise syntax for writing function expressions. They're especially useful for short, simple functions and have some important differences in behavior compared to regular functions.</p>
<div class="code-example">
<h3>Arrow Function Syntax</h3>
<pre><code>// Traditional function expression
const add = function(a, b) {
    return a + b;
};

// Equivalent arrow function
const add = (a, b) =&gt; {
    return a + b;
};

// Even more concise: implicit return for single expressions
const add = (a, b) =&gt; a + b;

// For functions with a single parameter, parentheses are optional
const square = x =&gt; x * x;

// For functions with no parameters, empty parentheses are required
const getRandomNumber = () =&gt; Math.random();

// For functions that return object literals, wrap the object in parentheses
const createPerson = (name, age) =&gt; ({ name: name, age: age });

// Arrow functions in array methods
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num =&gt; num * 2);  // [2, 4, 6, 8, 10]</code></pre>
</div>
<div class="important-note">
<h3>Arrow Functions vs. Regular Functions</h3>
<p>Arrow functions differ from regular functions in several important ways:</p>
<ol>
<li><strong>No <code>this</code> binding</strong>: Arrow functions do not have their own <code>this</code> context. Instead, they inherit <code>this</code> from the surrounding code.</li>
<li><strong>No <code>arguments</code> object</strong>: Arrow functions don't have access to the special <code>arguments</code> object.</li>
<li><strong>Cannot be used as constructors</strong>: You cannot use <code>new</code> with arrow functions.</li>
<li><strong>No duplicate named parameters</strong>: Arrow functions cannot have duplicate parameter names (strict mode).</li>
<li><strong>No <code>prototype</code> property</strong>: Arrow functions don't have a <code>prototype</code> property.</li>
</ol>
</div>
<div class="code-example">
<h3>The <code>this</code> Context in Arrow Functions</h3>
<pre><code>// Regular function vs. arrow function with 'this'

// Regular function: 'this' is determined by how the function is called
const person = {
    name: 'Alice',
    regularFunction: function() {
        console.log(this.name);  // 'this' refers to person object, outputs: "Alice"
    },
    arrowFunction: () =&gt; {
        console.log(this.name);  // 'this' refers to surrounding scope (likely window/global)
                                 // likely outputs: undefined
    }
};

person.regularFunction();  // "Alice"
person.arrowFunction();    // undefined

// Where arrow functions shine - callbacks
const counter = {
    count: 0,
    
    // Problem with regular function
    startCountingProblem: function() {
        setInterval(function() {
            this.count++;  // 'this' refers to the setInterval function, not counter
            console.log(this.count);  // NaN
        }, 1000);
    },
    
    // Solution with arrow function
    startCountingSolution: function() {
        setInterval(() =&gt; {
            this.count++;  // 'this' refers to counter object
            console.log(this.count);  // 1, 2, 3, ...
        }, 1000);
    }
};</code></pre>
</div>
<div class="best-practices">
<h3>When to Use Arrow Functions</h3>
<ul>
<li><strong>Best for</strong>: Short, single-purpose functions and callbacks</li>
<li><strong>Excellent for</strong>: Array methods like map, filter, reduce</li>
<li><strong>Good for</strong>: Event handlers where you want to preserve the context</li>
<li><strong>Avoid in</strong>: Object methods where you need to access the object with 'this'</li>
<li><strong>Avoid in</strong>: Functions that need to use 'arguments' object or constructors</li>
</ul>
</div>
</section>
<section class="function_applications">
<h2>Practical Function Applications</h2>
<p>Let's explore some common ways functions are used in real-world JavaScript applications.</p>
<h3>Event Handlers</h3>
<p>Functions are commonly used as event handlers in web applications, executing code in response to user interactions.</p>
<div class="code-example">
<pre><code>// Event handler with function declaration
function handleClick() {
    alert('Button clicked!');
}
document.getElementById('myButton').addEventListener('click', handleClick);

// Event handler with anonymous function expression
document.getElementById('myButton').addEventListener('click', function() {
    alert('Button clicked!');
});

// Event handler with arrow function
document.getElementById('myButton').addEventListener('click', () =&gt; {
    alert('Button clicked!');
});</code></pre>
</div>
<h3>Callback Functions</h3>
<p>Callback functions are functions passed as arguments to other functions, to be executed after a specific event or operation completes.</p>
<div class="code-example">
<pre><code>// Callback with setTimeout
setTimeout(function() {
    console.log('This runs after 2 seconds');
}, 2000);

// Callback with array methods
const numbers = [1, 2, 3, 4, 5];

// map with callback
const squared = numbers.map(function(number) {
    return number * number;
});

// filter with callback
const evenNumbers = numbers.filter(function(number) {
    return number % 2 === 0;
});

// Custom function with callback
function fetchData(url, onSuccess, onError) {
    // Simulating fetch operation
    const success = Math.random() &gt; 0.2;  // 80% success rate
    
    setTimeout(() =&gt; {
        if (success) {
            const data = { id: 123, name: 'Sample Data' };
            onSuccess(data);
        } else {
            onError('Failed to fetch data');
        }
    }, 1000);
}

// Using the function with callbacks
fetchData(
    'https://api.example.com/data',
    function(data) {
        console.log('Success:', data);
    },
    function(error) {
        console.error('Error:', error);
    }
);</code></pre>
</div>
<h3>Higher-Order Functions</h3>
<p>Higher-order functions are functions that either take one or more functions as arguments or return a function as their result. They're a powerful concept in functional programming.</p>
<div class="code-example">
<pre><code>// Higher-order function that takes a function as an argument
function applyOperation(x, y, operation) {
    return operation(x, y);
}

// Using applyOperation with different function arguments
const sum = applyOperation(5, 3, (a, b) =&gt; a + b);  // 8
const difference = applyOperation(5, 3, (a, b) =&gt; a - b);  // 2
const product = applyOperation(5, 3, (a, b) =&gt; a * b);  // 15

// Higher-order function that returns a function (function factory)
function createMultiplier(factor) {
    // Returns a function that multiplies its argument by factor
    return function(number) {
        return number * factor;
    };
}

// Create specific multiplier functions
const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15

// Function composition
function compose(f, g) {
    // Returns a function that applies f after g
    return function(x) {
        return f(g(x));
    };
}

const roundAndToString = compose(
    String,
    Math.round
);

console.log(roundAndToString(3.7));  // "4"</code></pre>
</div>
<h3>Function Currying</h3>
<p>Currying is a functional programming technique that transforms a function with multiple arguments into a sequence of functions each with a single argument.</p>
<div class="code-example">
<pre><code>// Regular function with three parameters
function calculateVolume(length, width, height) {
    return length * width * height;
}

// Curried version
function curriedVolume(length) {
    return function(width) {
        return function(height) {
            return length * width * height;
        };
    };
}

// Using the curried function
console.log(calculateVolume(2, 3, 4));  // 24
console.log(curriedVolume(2)(3)(4));  // 24

// Partial application with currying
const volumeWithLength2 = curriedVolume(2);
const volumeWithLength2Width3 = volumeWithLength2(3);

console.log(volumeWithLength2Width3(4));  // 24
console.log(volumeWithLength2Width3(5));  // 30

// With arrow functions, currying looks cleaner
const curriedVolumeArrow = length =&gt; width =&gt; height =&gt; length * width * height;

console.log(curriedVolumeArrow(2)(3)(4));  // 24</code></pre>
</div>
<h3>Practical Example: Form Validation</h3>
<div class="code-example">
<pre><code>// Form validation with functions

// Create a validator function factory
function createValidator(validationFunction, errorMessage) {
    return function(value) {
        if (validationFunction(value)) {
            return { valid: true };
        } else {
            return { valid: false, error: errorMessage };
        }
    };
}

// Create specific validators
const validateRequired = createValidator(
    value =&gt; value.trim().length &gt; 0,
    'This field is required'
);

const validateEmail = createValidator(
    value =&gt; /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
    'Please enter a valid email address'
);

const validatePassword = createValidator(
    value =&gt; value.length &gt;= 8 &amp;&amp; /[A-Z]/.test(value) &amp;&amp; /[0-9]/.test(value),
    'Password must be at least 8 characters with at least one uppercase letter and one number'
);

// Form validation function
function validateForm(formData) {
    const errors = {};
    
    // Validate username
    const usernameResult = validateRequired(formData.username);
    if (!usernameResult.valid) {
        errors.username = usernameResult.error;
    }
    
    // Validate email
    const emailRequiredResult = validateRequired(formData.email);
    if (!emailRequiredResult.valid) {
        errors.email = emailRequiredResult.error;
    } else {
        const emailFormatResult = validateEmail(formData.email);
        if (!emailFormatResult.valid) {
            errors.email = emailFormatResult.error;
        }
    }
    
    // Validate password
    const passwordRequiredResult = validateRequired(formData.password);
    if (!passwordRequiredResult.valid) {
        errors.password = passwordRequiredResult.error;
    } else {
        const passwordStrengthResult = validatePassword(formData.password);
        if (!passwordStrengthResult.valid) {
            errors.password = passwordStrengthResult.error;
        }
    }
    
    // Return validation result
    return {
        isValid: Object.keys(errors).length === 0,
        errors: errors
    };
}

// Usage
const formData = {
    username: 'johndoe',
    email: 'john.doe@example.com',
    password: 'Password123'
};

const validationResult = validateForm(formData);
console.log(validationResult);  // { isValid: true, errors: {} }</code></pre>
</div>
</section>
<section class="function_scope">
<h2>Understanding Scope in JavaScript</h2>
<p>Scope determines the accessibility of variables, functions, and objects in your code. It defines where these entities can be referenced or accessed and where they're not available.</p>
<div class="concept-visualization">
<pre class="mermaid">
                    graph TD
                    A[JavaScript Scope] --&gt; B[Global Scope]
                    A --&gt; C[Function Scope]
                    A --&gt; D[Block Scope<br/>ES6+]
                    
                    B --&gt; B1["Accessible everywhere"]
                    C --&gt; C1["Accessible only<br/>within the function"]
                    D --&gt; D1["Accessible only<br/>within the block"]
                </pre>
</div>
<div class="scope-analogy">
<h3>Scope Analogy: Building Access</h3>
<p>Think of scope like a building with multiple rooms, each secured by key cards:</p>
<ul>
<li><strong>Global scope</strong> is like the building's lobby—everyone can access it.</li>
<li><strong>Function scope</strong> is like individual offices—only people with the right key card can enter.</li>
<li><strong>Block scope</strong> is like secured areas within offices—requiring additional clearance beyond the office key card.</li>
</ul>
<p>Variables are like documents: those in the lobby (global scope) can be viewed by anyone, while documents in offices (function scope) or secure areas (block scope) are only accessible to those with appropriate permissions.</p>
</div>
<h3>Global Scope</h3>
<p>Variables declared outside any function or block have global scope and are accessible from anywhere in your code.</p>
<div class="code-example">
<pre><code>// Global scope
const appName = 'MyAwesomeApp';  // Global variable
let userCount = 0;               // Global variable

function incrementUserCount() {
    userCount++;  // Accessing the global variable
    console.log(`${appName} now has ${userCount} users`);
}

function getUserCount() {
    return userCount;  // Accessing the global variable
}

incrementUserCount();
console.log(getUserCount());  // 1</code></pre>
</div>
<div class="important-note">
<h3>Global Scope Cautions</h3>
<ul>
<li><strong>Naming conflicts</strong>: Variables in global scope can clash with other scripts or libraries</li>
<li><strong>Unintended modifications</strong>: Code anywhere can modify global variables</li>
<li><strong>Harder debugging</strong>: Problems with global variables can be difficult to trace</li>
<li><strong>Memory usage</strong>: Global variables live throughout the application's lifetime</li>
</ul>
<p>As a best practice, minimize the use of global variables and keep your global namespace clean.</p>
</div>
<h3>Function Scope</h3>
<p>Variables declared within a function are only accessible inside that function. They are created when the function is called and typically removed from memory when the function completes.</p>
<div class="code-example">
<pre><code>// Function scope
function calculateTotal(price, quantity) {
    const tax = 0.07;  // Function-scoped variable
    const subtotal = price * quantity;  // Function-scoped variable
    
    function calculateTax() {
        return subtotal * tax;  // Can access parent function's variables
    }
    
    const taxAmount = calculateTax();
    return subtotal + taxAmount;
}

console.log(calculateTotal(29.99, 2));  // 64.1786

// These would cause errors - can't access function-scoped variables
// console.log(tax);        // ReferenceError
// console.log(subtotal);   // ReferenceError
// console.log(taxAmount);  // ReferenceError</code></pre>
</div>
<div class="scope-illustration">
<svg viewbox="0 0 600 300" xmlns="http://www.w3.org/2000/svg">
<!-- Global Scope -->
<rect fill="#f0f0f0" height="250" rx="10" stroke="#333" stroke-width="2" width="500" x="50" y="30"></rect>
<text font-family="Arial" font-size="16" font-weight="bold" x="70" y="60">Global Scope</text>
<!-- Function Scope -->
<rect fill="#e6f7ff" height="160" rx="8" stroke="#0099cc" stroke-width="2" width="400" x="100" y="80"></rect>
<text font-family="Arial" font-size="14" font-weight="bold" x="120" y="110">Function Scope: calculateTotal()</text>
<text font-family="Arial" font-size="12" x="120" y="140">Variables: tax, subtotal, taxAmount</text>
<!-- Nested Function Scope -->
<rect fill="#ffece6" height="60" rx="8" stroke="#ff6600" stroke-width="2" width="300" x="150" y="160"></rect>
<text font-family="Arial" font-size="12" font-weight="bold" x="170" y="190">Function Scope: calculateTax()</text>
<text font-family="Arial" font-size="12" x="170" y="210">(Can access parent variables)</text>
</svg>
</div>
<h3>Block Scope (ES6+)</h3>
<p>Introduced in ES6, block scope restricts variables declared with <code>let</code> and <code>const</code> to be accessible only within the block (denoted by curly braces) where they're defined.</p>
<div class="code-example">
<pre><code>// Block scope
function processArray(array) {
    // Function-scoped variable
    let result = [];
    
    if (array.length &gt; 0) {
        // Block-scoped variables
        const firstItem = array[0];
        let processingStatus = "active";
        
        // These are accessible inside this if block
        console.log(firstItem);
        console.log(processingStatus);
        
        result.push(firstItem);
    }
    
    // These would cause errors - can't access block-scoped variables
    // console.log(firstItem);       // ReferenceError
    // console.log(processingStatus); // ReferenceError
    
    for (let i = 1; i &lt; array.length; i++) {
        // 'i' is block-scoped to this for loop
        result.push(array[i]);
    }
    
    // This would cause an error - 'i' is not accessible here
    // console.log(i);  // ReferenceError
    
    return result;
}

// var vs let/const
function scopeExample() {
    if (true) {
        var oldWay = "I'm accessible outside the block";  // Function-scoped
        let newWay = "I'm only accessible in this block";  // Block-scoped
    }
    
    console.log(oldWay);  // "I'm accessible outside the block"
    // console.log(newWay);  // ReferenceError
}</code></pre>
</div>
<div class="comparison-table">
<h3>var vs let vs const</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>var</th>
<th>let</th>
<th>const</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scope</td>
<td>Function-scoped</td>
<td>Block-scoped</td>
<td>Block-scoped</td>
</tr>
<tr>
<td>Hoisting</td>
<td>Hoisted (initialized as undefined)</td>
<td>Hoisted (not initialized - "temporal dead zone")</td>
<td>Hoisted (not initialized - "temporal dead zone")</td>
</tr>
<tr>
<td>Reassignment</td>
<td>Can be reassigned</td>
<td>Can be reassigned</td>
<td>Cannot be reassigned</td>
</tr>
<tr>
<td>Redeclaration</td>
<td>Can be redeclared</td>
<td>Cannot be redeclared</td>
<td>Cannot be redeclared</td>
</tr>
<tr>
<td>Global scope</td>
<td>Creates property on window</td>
<td>Doesn't create property on window</td>
<td>Doesn't create property on window</td>
</tr>
</tbody>
</table>
</div>
</section>
<section class="scope_chain">
<h2>Lexical Scope and Scope Chain</h2>
<p>JavaScript uses lexical scoping, which means the scope of a variable is determined by its location in the source code. The scope chain is how JavaScript resolves variable names when code in one scope references a variable that might exist in multiple scopes.</p>
<h3>Lexical Scope</h3>
<p>Lexical scope means that inner functions have access to variables and functions defined in their outer scope, but not vice versa.</p>
<div class="code-example">
<pre><code>// Lexical scope example
function outer() {
    const outerVar = "I'm from outer function";
    
    function inner() {
        const innerVar = "I'm from inner function";
        console.log(outerVar);  // Can access outerVar
    }
    
    inner();
    // console.log(innerVar);  // Error - can't access innerVar here
}

outer();</code></pre>
</div>
<div class="scope-chain-illustration">
<pre class="mermaid">
                    graph TD
                    A[Global Scope] --&gt; B[outer() Function Scope]
                    B --&gt; C[inner() Function Scope]
                    
                    D[Variable Resolution Process<br/>in inner() function]
                    D --&gt; E[1. Check inner() scope first]
                    E --&gt; F[2. If not found, check outer() scope]
                    F --&gt; G[3. If not found, check global scope]
                    G --&gt; H[4. If not found anywhere,<br/>ReferenceError]
                </pre>
</div>
<h3>Scope Chain</h3>
<p>When JavaScript tries to access a variable, it first looks in the current scope. If it doesn't find it there, it looks in the outer scope, continuing up the chain until it reaches the global scope. This sequence is called the scope chain.</p>
<div class="code-example">
<pre><code>// Scope chain example
const global = "I'm global";

function firstLevel() {
    const first = "I'm from first level";
    
    function secondLevel() {
        const second = "I'm from second level";
        
        function thirdLevel() {
            const third = "I'm from third level";
            
            console.log(third);    // Found in current scope
            console.log(second);   // Found in parent scope
            console.log(first);    // Found in grandparent scope
            console.log(global);   // Found in global scope
            // console.log(undeclared);  // ReferenceError - not found in any scope
        }
        
        thirdLevel();
    }
    
    secondLevel();
}

firstLevel();</code></pre>
</div>
<h3>Variable Shadowing</h3>
<p>When a variable in an inner scope has the same name as a variable in an outer scope, the inner variable "shadows" or hides the outer one within its scope.</p>
<div class="code-example">
<pre><code>// Variable shadowing
const value = "global";

function outer() {
    const value = "outer";
    
    function inner() {
        const value = "inner";
        console.log(value);  // "inner" (shadows outer variables)
    }
    
    console.log(value);  // "outer" (shadows global variable)
    inner();
}

console.log(value);  // "global"
outer();</code></pre>
</div>
<div class="important-note">
<h3>Scope Chain Impact on Performance</h3>
<p>Variable lookups further up the scope chain can be slightly slower than local variable lookups. For performance-critical code:</p>
<ul>
<li>Store frequently accessed outer scope variables in local variables</li>
<li>Minimize scope chain depth for hot code paths</li>
<li>Be conscious of closures that maintain references to large outer scopes</li>
</ul>
</div>
</section>
<section class="closures">
<h2>Closures: Functions with Persistent Memory</h2>
<p>A closure is a function that remembers its lexical scope even when the function is executed outside that scope. This powerful concept allows for data encapsulation, private variables, and function factories.</p>
<div class="code-example">
<h3>Basic Closure Example</h3>
<pre><code>// Simple closure
function createCounter() {
    let count = 0;  // This variable is "closed over"
    
    function increment() {
        count++;
        return count;
    }
    
    return increment;  // Return the inner function
}

const counter = createCounter();
console.log(counter());  // 1
console.log(counter());  // 2
console.log(counter());  // 3

// Each closure has its own private state
const counter2 = createCounter();
console.log(counter2());  // 1 (separate from the first counter)</code></pre>
</div>
<div class="closure-visualization">
<svg viewbox="0 0 600 300" xmlns="http://www.w3.org/2000/svg">
<!-- Outer function context -->
<rect fill="#f0f0f0" height="250" rx="10" stroke="#333" stroke-width="2" width="500" x="50" y="30"></rect>
<text font-family="Arial" font-size="16" font-weight="bold" x="70" y="60">createCounter() Execution Context</text>
<!-- Local variable -->
<rect fill="#e6f7ff" height="40" rx="5" stroke="#0099cc" stroke-width="2" width="400" x="100" y="80"></rect>
<text font-family="Arial" font-size="14" x="120" y="105">let count = 0;</text>
<!-- Inner function -->
<rect fill="#ffece6" height="80" rx="8" stroke="#ff6600" stroke-width="2" width="400" x="100" y="140"></rect>
<text font-family="Arial" font-size="14" font-weight="bold" x="120" y="170">function increment() { ... }</text>
<!-- Return arrow -->
<line marker-end="url(#arrow)" stroke="#333" stroke-width="2" x1="300" x2="300" y1="240" y2="280"></line>
<text font-family="Arial" font-size="12" x="320" y="260">Return increment function</text>
<!-- Closure backpack -->
<ellipse cx="100" cy="280" fill="#d4f7d4" rx="70" ry="20" stroke="#009900" stroke-width="2"></ellipse>
<text font-family="Arial" font-size="12" font-weight="bold" text-anchor="middle" x="100" y="285">Closure: count = 0</text>
<!-- Arrow definition -->
<defs>
<marker id="arrow" markerheight="10" markerwidth="10" orient="auto" refx="9" refy="3">
<path d="M0,0 L0,6 L9,3 z" fill="#333"></path>
</marker>
</defs>
</svg>
</div>
<div class="important-note">
<h3>How Closures Work</h3>
<p>When a function is defined inside another function, it forms a closure, which consists of:</p>
<ol>
<li>The function itself</li>
<li>A reference to the environment in which the function was created, including all variables in its outer scope</li>
</ol>
<p>Think of this as the function "carrying a backpack" of referenced variables from its parent scope wherever it goes.</p>
</div>
<h3>Practical Applications of Closures</h3>
<div class="code-example">
<h4>Data Privacy</h4>
<pre><code>// Using closures for data privacy
function createBankAccount(initialBalance) {
    let balance = initialBalance;  // Private variable
    
    return {
        deposit: function(amount) {
            if (amount &gt; 0) {
                balance += amount;
                return `Deposited ${amount}. New balance: ${balance}`;
            }
            return "Invalid deposit amount";
        },
        withdraw: function(amount) {
            if (amount &gt; 0 &amp;&amp; amount &lt;= balance) {
                balance -= amount;
                return `Withdrawn ${amount}. New balance: ${balance}`;
            }
            return "Invalid withdrawal amount or insufficient funds";
        },
        getBalance: function() {
            return `Current balance: ${balance}`;
        }
    };
}

const account = createBankAccount(100);
console.log(account.getBalance());  // "Current balance: 100"
console.log(account.deposit(50));   // "Deposited 50. New balance: 150"
console.log(account.withdraw(30));  // "Withdrawn 30. New balance: 120"

// The 'balance' variable is private and cannot be accessed directly
// console.log(account.balance);  // undefined</code></pre>
<h4>Function Factories</h4>
<pre><code>// Using closures for function factories
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
const quadruple = createMultiplier(4);

console.log(double(5));     // 10
console.log(triple(5));     // 15
console.log(quadruple(5));  // 20</code></pre>
<h4>Memoization (Caching Results)</h4>
<pre><code>// Using closures for memoization
function createMemoizedFunction(fn) {
    const cache = {};  // Private cache
    
    return function(arg) {
        if (cache[arg]) {
            console.log(`Returning cached result for ${arg}`);
            return cache[arg];
        }
        
        console.log(`Calculating result for ${arg}`);
        const result = fn(arg);
        cache[arg] = result;
        return result;
    };
}

// Expensive function to calculate factorial
function factorial(n) {
    if (n === 0 || n === 1) return 1;
    return n * factorial(n - 1);
}

// Create memoized version
const memoizedFactorial = createMemoizedFunction(factorial);

// First calls calculate and cache the results
console.log(memoizedFactorial(5));  // Calculates
console.log(memoizedFactorial(3));  // Calculates

// Subsequent calls with the same argument use the cached results
console.log(memoizedFactorial(5));  // Uses cache
console.log(memoizedFactorial(3));  // Uses cache</code></pre>
<h4>Module Pattern</h4>
<pre><code>// Using closures for the module pattern
const calculator = (function() {
    // Private variables and functions
    let result = 0;
    
    function validate(value) {
        return typeof value === 'number' &amp;&amp; !isNaN(value);
    }
    
    // Public API
    return {
        add: function(value) {
            if (validate(value)) {
                result += value;
            }
            return this;  // For method chaining
        },
        subtract: function(value) {
            if (validate(value)) {
                result -= value;
            }
            return this;
        },
        multiply: function(value) {
            if (validate(value)) {
                result *= value;
            }
            return this;
        },
        divide: function(value) {
            if (validate(value) &amp;&amp; value !== 0) {
                result /= value;
            }
            return this;
        },
        getResult: function() {
            return result;
        },
        reset: function() {
            result = 0;
            return this;
        }
    };
})();  // IIFE - Immediately Invoked Function Expression

// Using the module
calculator.add(5).multiply(2).subtract(3).divide(2);
console.log(calculator.getResult());  // 3.5
calculator.reset();
console.log(calculator.getResult());  // 0</code></pre>
</div>
</section>
<section class="hoisting">
<h2>Hoisting: Variable and Function Declarations</h2>
<p>Hoisting is JavaScript's behavior of moving declarations to the top of their scope during the compilation phase. Understanding hoisting helps prevent bugs and unexpected behavior in your code.</p>
<div class="code-example">
<h3>Function Hoisting</h3>
<pre><code>// Function declarations are hoisted entirely
console.log(add(2, 3));  // 5 - Works even before declaration

function add(a, b) {
    return a + b;
}

// Function expressions are not hoisted the same way
console.log(subtract(5, 2));  // Error - subtract is not a function yet

var subtract = function(a, b) {
    return a - b;
};</code></pre>
<h3>Variable Hoisting</h3>
<pre><code>// var declarations are hoisted, but not their initializations
console.log(x);  // undefined (not an error)
var x = 5;
console.log(x);  // 5

// Same as:
var x;
console.log(x);  // undefined
x = 5;
console.log(x);  // 5

// let and const declarations are hoisted but not initialized (Temporal Dead Zone)
console.log(y);  // ReferenceError: Cannot access 'y' before initialization
let y = 10;

console.log(z);  // ReferenceError: Cannot access 'z' before initialization
const z = 15;</code></pre>
</div>
<pre class="mermaid">
                flowchart TD
                    A[JavaScript Execution] --&gt; B[Creation Phase<br/>Hoisting Occurs]
                    B --&gt; C[Create Scope]
                    B --&gt; D[Function Declarations<br/>Fully Hoisted]
                    B --&gt; E[Variable Declarations<br/>Partially Hoisted]
                    A --&gt; F[Execution Phase<br/>Code Runs Line by Line]
            </pre>
<div class="important-note">
<h3>Best Practices for Dealing with Hoisting</h3>
<ul>
<li><strong>Declare variables at the top</strong> of their scope to match how JavaScript interprets them</li>
<li><strong>Use let and const</strong> instead of var to prevent unexpected hoisting behavior</li>
<li><strong>Initialize variables</strong> when you declare them to avoid undefined values</li>
<li><strong>Be consistent</strong> with function declarations or expressions throughout your codebase</li>
</ul>
</div>
</section>
<section class="recursion">
<h2>Recursion: Functions That Call Themselves</h2>
<p>Recursion is a programming technique where a function calls itself to solve a problem. It's particularly useful for tasks that can be broken down into smaller, similar subtasks.</p>
<div class="recursion-visualization">
<pre class="mermaid">
                    graph TD
                    A[factorial(3)] --&gt; B[return 3 * factorial(2)]
                    B --&gt; C[return 2 * factorial(1)]
                    C --&gt; D[return 1 * factorial(0)]
                    D --&gt; E[return 1]
                    E --&gt; F[1 * 1 = 1]
                    F --&gt; G[2 * 1 = 2]
                    G --&gt; H[3 * 2 = 6]
                    
                    style A fill:#f9d5e5,stroke:#333
                    style B fill:#eeeeee,stroke:#333
                    style C fill:#dddddd,stroke:#333
                    style D fill:#cccccc,stroke:#333
                    style E fill:#cccccc,stroke:#333
                    style F fill:#dddddd,stroke:#333
                    style G fill:#eeeeee,stroke:#333
                    style H fill:#f9d5e5,stroke:#333
                </pre>
</div>
<div class="code-example">
<h3>Basic Recursion Example: Factorial</h3>
<pre><code>// Recursive function to calculate factorial
function factorial(n) {
    // Base case - stops the recursion
    if (n === 0 || n === 1) {
        return 1;
    }
    
    // Recursive case - function calls itself
    return n * factorial(n - 1);
}

console.log(factorial(5));  // 120 (5 * 4 * 3 * 2 * 1)</code></pre>
<h3>Understanding Recursive Functions</h3>
<p>Every recursive function has two essential components:</p>
<ol>
<li><strong>Base case</strong>: A condition that stops the recursion</li>
<li><strong>Recursive case</strong>: A condition where the function calls itself</li>
</ol>
<h3>More Recursion Examples</h3>
<pre><code>// Fibonacci sequence with recursion
function fibonacci(n) {
    // Base cases
    if (n &lt;= 0) return 0;
    if (n === 1) return 1;
    
    // Recursive case
    return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(7));  // 13

// Recursive function to traverse a nested object
function findValueInObject(obj, key) {
    // Base case 1: If obj is null or not an object
    if (obj === null || typeof obj !== 'object') {
        return undefined;
    }
    
    // Base case 2: If the key exists in the current object
    if (key in obj) {
        return obj[key];
    }
    
    // Recursive case: Search in nested objects
    for (let prop in obj) {
        if (typeof obj[prop] === 'object') {
            const result = findValueInObject(obj[prop], key);
            if (result !== undefined) {
                return result;
            }
        }
    }
    
    return undefined;
}

const data = {
    user: {
        profile: {
            name: "John Doe",
            age: 30
        },
        settings: {
            theme: "dark"
        }
    }
};

console.log(findValueInObject(data, 'name'));  // "John Doe"
console.log(findValueInObject(data, 'theme')); // "dark"
console.log(findValueInObject(data, 'email')); // undefined</code></pre>
</div>
<div class="important-note">
<h3>Recursion Pitfalls and Optimization</h3>
<ul>
<li><strong>Stack overflow</strong>: Each recursive call adds to the call stack, which has limited size. Deep recursion can cause a stack overflow error.</li>
<li><strong>Redundant calculations</strong>: Simple recursive implementations often recalculate the same values repeatedly.</li>
<li><strong>Optimization techniques</strong>:
                        <ul>
<li><strong>Tail recursion</strong>: A special form of recursion where the recursive call is the last operation in the function</li>
<li><strong>Memoization</strong>: Caching previously computed results to avoid redundant calculations</li>
<li><strong>Iterative solutions</strong>: Sometimes, recursion can be replaced with iteration for better performance</li>
</ul>
</li>
</ul>
</div>
<div class="code-example">
<h3>Optimized Recursion</h3>
<pre><code>// Memoized Fibonacci for better performance
function memoizedFibonacci() {
    const cache = {};
    
    function fib(n) {
        if (n in cache) {
            return cache[n];
        }
        
        if (n &lt;= 0) return 0;
        if (n === 1) return 1;
        
        cache[n] = fib(n - 1) + fib(n - 2);
        return cache[n];
    }
    
    return fib;
}

const fastFib = memoizedFibonacci();
console.log(fastFib(40));  // Computes quickly

// Tail-recursive factorial
function tailFactorial(n, accumulator = 1) {
    if (n === 0 || n === 1) {
        return accumulator;
    }
    
    return tailFactorial(n - 1, n * accumulator);
}

console.log(tailFactorial(5));  // 120</code></pre>
</div>
</section>
<section class="iife">
<h2>Immediately Invoked Function Expressions (IIFE)</h2>
<p>An IIFE is a JavaScript function that is defined and called immediately after creation. It's a powerful pattern for creating private scope and avoiding global namespace pollution.</p>
<div class="code-example">
<h3>Basic IIFE Syntax</h3>
<pre><code>// Basic IIFE
(function() {
    console.log("This function is executed immediately");
})();

// IIFE with parameters
(function(name) {
    console.log(`Hello, ${name}!`);
})("John");  // Output: "Hello, John!"

// IIFE that returns a value
const result = (function() {
    const x = 10;
    const y = 20;
    return x + y;
})();

console.log(result);  // 30</code></pre>
<h3>Creating Private Scope with IIFE</h3>
<pre><code>// Using IIFE to create private scope
const counter = (function() {
    // Private variables
    let count = 0;
    
    // Return object with public methods
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
})();

console.log(counter.getCount());    // 0
console.log(counter.increment());   // 1
console.log(counter.increment());   // 2
console.log(counter.decrement());   // 1
// console.log(counter.count);      // undefined (private variable)</code></pre>
<h3>IIFE for Avoiding Global Pollution</h3>
<pre><code>// Without IIFE - pollutes global namespace
var libraryName = "MyLibrary";
var version = "1.0.0";

function initialize() {
    console.log(`${libraryName} v${version} initialized`);
}

// With IIFE - keeps variables contained
(function() {
    var libraryName = "MyLibrary";
    var version = "1.0.0";
    
    function initialize() {
        console.log(`${libraryName} v${version} initialized`);
    }
    
    // Only expose what's needed to the global scope
    window.MyLibrary = {
        initialize: initialize
    };
})();

// Only MyLibrary is added to the global scope
// libraryName and version are not accessible globally</code></pre>
</div>
<div class="important-note">
<h3>Modern Alternatives to IIFE</h3>
<p>While IIFEs were essential in pre-ES6 JavaScript, modern JavaScript offers alternatives:</p>
<ul>
<li><strong>Block scoping</strong> with <code>let</code> and <code>const</code> provides similar encapsulation</li>
<li><strong>ES modules</strong> (import/export) provide better structuring for larger applications</li>
<li><strong>Classes</strong> can encapsulate related functionality</li>
</ul>
<pre><code>// Modern alternative using block scope
{
    const libraryName = "MyLibrary";
    const version = "1.0.0";
    
    function initialize() {
        console.log(`${libraryName} v${version} initialized`);
    }
    
    // Expose to global scope if needed
    window.MyLibrary = {
        initialize
    };
}</code></pre>
</div>
</section>
<section class="best_practices">
<h2>Function and Scope Best Practices</h2>
<p>Following these best practices will help you write cleaner, more maintainable, and more efficient JavaScript code.</p>
<h3>Function Best Practices</h3>
<ul>
<li><strong>Do one thing</strong>: Functions should have a single responsibility</li>
<li><strong>Keep it small</strong>: Aim for functions under 20-30 lines</li>
<li><strong>Use descriptive names</strong>: Function names should clearly describe what they do</li>
<li><strong>Be consistent</strong>: Use the same style for function definitions throughout your codebase</li>
<li><strong>Limit parameters</strong>: Try to keep the number of parameters under 3; use an object for more</li>
<li><strong>Return early</strong>: Use early returns to handle edge cases and reduce nesting</li>
<li><strong>Document with comments</strong>: Add JSDoc comments for functions that are part of your API</li>
</ul>
<div class="code-example">
<h3>Function Before and After: Applying Best Practices</h3>
<h4>Before</h4>
<pre><code>// Poor function design
function process(data, type, includeInactive, sortDirection, limit) {
    // Check data
    if (!data) {
        console.error("No data provided");
        return null;
    }
    
    // Filter based on type
    let results = [];
    if (type) {
        for (let i = 0; i &lt; data.length; i++) {
            if (data[i].type === type) {
                if (includeInactive === true) {
                    results.push(data[i]);
                } else {
                    if (data[i].active === true) {
                        results.push(data[i]);
                    }
                }
            }
        }
    } else {
        for (let i = 0; i &lt; data.length; i++) {
            if (includeInactive === true) {
                results.push(data[i]);
            } else {
                if (data[i].active === true) {
                    results.push(data[i]);
                }
            }
        }
    }
    
    // Sort the data
    if (sortDirection === "asc") {
        results.sort(function(a, b) {
            return a.value - b.value;
        });
    } else if (sortDirection === "desc") {
        results.sort(function(a, b) {
            return b.value - a.value;
        });
    }
    
    // Apply limit
    if (limit &amp;&amp; results.length &gt; limit) {
        results = results.slice(0, limit);
    }
    
    return results;
}</code></pre>
<h4>After</h4>
<pre><code>/**
 * Processes data items based on specified criteria
 * 
 * @param {Object} options - The processing options
 * @param {Array} options.data - The data to process
 * @param {string} [options.type] - Filter by this type
 * @param {boolean} [options.includeInactive=false] - Whether to include inactive items
 * @param {string} [options.sortDirection] - Sort direction ('asc' or 'desc')
 * @param {number} [options.limit] - Maximum number of results
 * @returns {Array} The processed data items
 */
function processData({ 
    data, 
    type, 
    includeInactive = false, 
    sortDirection, 
    limit 
}) {
    // Validate input
    if (!data || !Array.isArray(data)) {
        console.error("Invalid or missing data");
        return [];
    }
    
    // Filter data
    const filteredData = filterData(data, type, includeInactive);
    
    // Sort data if needed
    const sortedData = sortData(filteredData, sortDirection);
    
    // Apply limit if specified
    return applyLimit(sortedData, limit);
}

// Helper functions with single responsibilities
function filterData(data, type, includeInactive) {
    return data.filter(item =&gt; {
        const matchesType = !type || item.type === type;
        const isActiveMatch = includeInactive || item.active === true;
        return matchesType &amp;&amp; isActiveMatch;
    });
}

function sortData(data, direction) {
    if (!direction) return data;
    
    return [...data].sort((a, b) =&gt; {
        return direction === "asc" 
            ? a.value - b.value 
            : b.value - a.value;
    });
}

function applyLimit(data, limit) {
    if (!limit || data.length &lt;= limit) return data;
    return data.slice(0, limit);
}</code></pre>
</div>
<h3>Scope Best Practices</h3>
<ul>
<li><strong>Minimize global variables</strong>: Avoid polluting the global namespace</li>
<li><strong>Use block scope</strong>: Prefer <code>let</code> and <code>const</code> over <code>var</code></li>
<li><strong>Declare variables at the top</strong> of their scope for better readability</li>
<li><strong>Keep variable scope tight</strong>: Declare variables in the smallest scope needed</li>
<li><strong>Use descriptive variable names</strong> that clearly indicate their purpose</li>
<li><strong>Avoid scope shadowing</strong> when possible to prevent confusion</li>
<li><strong>Use closures carefully</strong>: Be aware of what variables are being closed over</li>
</ul>
</section>
<section class="advanced_patterns">
<h2>Advanced Function Patterns</h2>
<p>As you become more comfortable with JavaScript functions and scope, these advanced patterns will help you solve complex problems more elegantly.</p>
<h3>Function Composition</h3>
<p>Function composition is a technique where the result of one function is passed as an input to another function, creating a chain of operations.</p>
<div class="code-example">
<pre><code>// Basic function composition
function compose(f, g) {
    return function(x) {
        return f(g(x));
    };
}

// Example functions
const addOne = x =&gt; x + 1;
const double = x =&gt; x * 2;
const square = x =&gt; x * x;

// Create composed functions
const doubleAndAddOne = compose(addOne, double);
const squareAndDouble = compose(double, square);

console.log(doubleAndAddOne(3));  // 7 (double 3 = 6, add 1 = 7)
console.log(squareAndDouble(3));  // 18 (square 3 = 9, double = 18)

// Multiple function composition
function composeMultiple(...fns) {
    return function(x) {
        return fns.reduceRight((acc, fn) =&gt; fn(acc), x);
    };
}

const addOneDoubleThenSquare = composeMultiple(square, double, addOne);
console.log(addOneDoubleThenSquare(3));  // 64 (3+1=4, 4*2=8, 8^2=64)</code></pre>
</div>
<h3>Partial Application and Currying</h3>
<p>Partial application fixes some arguments of a function, returning a new function with fewer parameters. Currying transforms a function with multiple arguments into a sequence of functions, each taking a single argument.</p>
<div class="code-example">
<pre><code>// Partial application
function partial(fn, ...presetArgs) {
    return function(...laterArgs) {
        return fn(...presetArgs, ...laterArgs);
    };
}

function greet(greeting, name) {
    return `${greeting}, ${name}!`;
}

const sayHello = partial(greet, "Hello");
console.log(sayHello("John"));  // "Hello, John!"
console.log(sayHello("Sarah")); // "Hello, Sarah!"

// Advanced currying
function curry(fn) {
    return function curried(...args) {
        if (args.length &gt;= fn.length) {
            return fn(...args);
        }
        
        return function(...moreArgs) {
            return curried(...args, ...moreArgs);
        };
    };
}

function add(a, b, c) {
    return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3));   // 6
console.log(curriedAdd(1, 2)(3));   // 6
console.log(curriedAdd(1)(2, 3));   // 6
console.log(curriedAdd(1, 2, 3));   // 6</code></pre>
</div>
<h3>Memoization</h3>
<p>Memoization caches the results of expensive function calls, improving performance when the same inputs occur multiple times.</p>
<div class="code-example">
<pre><code>// Generic memoization function
function memoize(fn) {
    const cache = new Map();
    
    return function(...args) {
        // Create a key from the arguments
        const key = JSON.stringify(args);
        
        if (cache.has(key)) {
            console.log("Returning from cache");
            return cache.get(key);
        }
        
        console.log("Calculating result");
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
}

// Example of an expensive function
function fibonacci(n) {
    if (n &lt;= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Regular fibonacci is very slow for larger numbers
console.time("Regular fibonacci");
console.log(fibonacci(30));
console.timeEnd("Regular fibonacci");

// Memoized version is much faster
const memoizedFibonacci = memoize(function(n) {
    if (n &lt;= 1) return n;
    return memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2);
});

console.time("Memoized fibonacci");
console.log(memoizedFibonacci(30));
console.timeEnd("Memoized fibonacci");</code></pre>
</div>
<h3>Generator Functions</h3>
<p>Generator functions provide a way to define an iterative algorithm by writing a function that can maintain its own state and yield values one at a time.</p>
<div class="code-example">
<pre><code>// Basic generator function
function* countUp(max) {
    let count = 0;
    while (count &lt; max) {
        yield count++;
    }
}

// Using the generator
const counter = countUp(5);
console.log(counter.next().value);  // 0
console.log(counter.next().value);  // 1
console.log(counter.next().value);  // 2
console.log(counter.next().value);  // 3
console.log(counter.next().value);  // 4
console.log(counter.next().value);  // undefined (generator is done)

// Infinite sequence generator
function* fibonacci() {
    let a = 0, b = 1;
    
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

// Using the infinite generator (with a limit)
const fibGen = fibonacci();
for (let i = 0; i &lt; 10; i++) {
    console.log(fibGen.next().value);  // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
}

// Generators for async operations
function* fetchSequentially(urls) {
    for (const url of urls) {
        try {
            const response = yield fetch(url);
            const data = yield response.json();
            yield data;
        } catch (error) {
            yield { error: error.message, url };
        }
    }
}

// Using generators with async/await (would be in an async function)
async function fetchAllData(urls) {
    const gen = fetchSequentially(urls);
    let result = gen.next();
    
    while (!result.done) {
        try {
            // Handle the yielded promises
            const value = await result.value;
            result = gen.next(value);
        } catch (error) {
            result = gen.throw(error);
        }
    }
}</code></pre>
</div>
<h3>Proxy Pattern for Interception</h3>
<p>JavaScript Proxies allow you to intercept and customize operations on objects, enabling powerful patterns for validation, logging, and more.</p>
<div class="code-example">
<pre><code>// Using Proxy for validating object properties
function createValidatedObject(initialValues, validators) {
    return new Proxy(initialValues || {}, {
        set(target, property, value) {
            // Check if we have a validator for this property
            if (validators.hasOwnProperty(property)) {
                const validator = validators[property];
                const validationResult = validator(value);
                
                if (validationResult !== true) {
                    throw new Error(`Invalid value for ${property}: ${validationResult}`);
                }
            }
            
            // If valid or no validator, set the value
            target[property] = value;
            return true;
        }
    });
}

// Example usage
const user = createValidatedObject({
    name: "John",
    age: 30
}, {
    name: value =&gt; {
        if (typeof value !== 'string') return "Name must be a string";
        if (value.length &lt; 2) return "Name must be at least 2 characters";
        return true;
    },
    age: value =&gt; {
        if (typeof value !== 'number') return "Age must be a number";
        if (value &lt; 0) return "Age cannot be negative";
        if (value &gt; 120) return "Age cannot be greater than 120";
        return true;
    }
});

// Valid operations
user.name = "Jane"; // Works fine
user.age = 25;      // Works fine

// These would throw errors
// user.name = "";       // Error: Name must be at least 2 characters
// user.age = -5;        // Error: Age cannot be negative
// user.age = "thirty";  // Error: Age must be a number</code></pre>
</div>
</section>
<section class="real_world">
<h2>Real-World Example: Task Management System</h2>
<p>Let's bring together many of the concepts we've learned by building a simple task management system that demonstrates functions, scope, closures, and advanced patterns.</p>
<div class="code-example">
<pre><code>// Task Management System

// Create the task manager using an IIFE with closure for data privacy
const TaskManager = (function() {
    // Private data
    let tasks = [];
    let nextId = 1;
    
    // Private functions
    function generateId() {
        return nextId++;
    }
    
    function findTaskIndex(id) {
        return tasks.findIndex(task =&gt; task.id === id);
    }
    
    function validateTask(task) {
        if (!task.title || typeof task.title !== 'string') {
            throw new Error('Task must have a valid title');
        }
        
        if (task.priority &amp;&amp; !['low', 'medium', 'high'].includes(task.priority)) {
            throw new Error('Priority must be low, medium, or high');
        }
        
        return true;
    }
    
    // Public API
    return {
        // Add a new task
        addTask: function({ title, description = '', dueDate = null, priority = 'medium', completed = false }) {
            const newTask = {
                id: generateId(),
                title,
                description,
                dueDate: dueDate ? new Date(dueDate) : null,
                priority,
                completed,
                createdAt: new Date(),
                updatedAt: new Date()
            };
            
            validateTask(newTask);
            tasks.push(newTask);
            
            return newTask.id;
        },
        
        // Get all tasks, with optional filtering
        getTasks: function({ completed, priority } = {}) {
            return tasks.filter(task =&gt; {
                if (completed !== undefined &amp;&amp; task.completed !== completed) {
                    return false;
                }
                
                if (priority &amp;&amp; task.priority !== priority) {
                    return false;
                }
                
                return true;
            }).map(task =&gt; ({ ...task })); // Return copies to prevent mutation
        },
        
        // Get a specific task by ID
        getTask: function(id) {
            const task = tasks.find(task =&gt; task.id === id);
            return task ? { ...task } : null;
        },
        
        // Update a task
        updateTask: function(id, updates) {
            const index = findTaskIndex(id);
            
            if (index === -1) {
                throw new Error(`Task with ID ${id} not found`);
            }
            
            // Create new task with updates
            const updatedTask = {
                ...tasks[index],
                ...updates,
                updatedAt: new Date()
            };
            
            // Validate the updated task
            validateTask(updatedTask);
            
            // Update the tasks array
            tasks[index] = updatedTask;
            
            return true;
        },
        
        // Delete a task
        deleteTask: function(id) {
            const index = findTaskIndex(id);
            
            if (index === -1) {
                throw new Error(`Task with ID ${id} not found`);
            }
            
            tasks.splice(index, 1);
            return true;
        },
        
        // Mark a task as completed
        completeTask: function(id) {
            return this.updateTask(id, { completed: true });
        },
        
        // Get summary statistics
        getStats: function() {
            const total = tasks.length;
            const completed = tasks.filter(task =&gt; task.completed).length;
            const incomplete = total - completed;
            
            const priorityCounts = {
                high: 0,
                medium: 0,
                low: 0
            };
            
            tasks.forEach(task =&gt; {
                if (priorityCounts.hasOwnProperty(task.priority)) {
                    priorityCounts[task.priority]++;
                }
            });
            
            return {
                total,
                completed,
                incomplete,
                completionRate: total ? (completed / total) * 100 : 0,
                priorityCounts
            };
        }
    };
})();

// Example usage
try {
    // Add some tasks
    const task1 = TaskManager.addTask({
        title: "Complete JavaScript tutorial",
        description: "Finish the functions and scope tutorial",
        priority: "high",
        dueDate: "2025-05-01"
    });
    
    const task2 = TaskManager.addTask({
        title: "Buy groceries",
        description: "Milk, eggs, bread, and vegetables",
        priority: "medium"
    });
    
    const task3 = TaskManager.addTask({
        title: "Go for a run",
        priority: "low"
    });
    
    // Complete a task
    TaskManager.completeTask(task2);
    
    // Update a task
    TaskManager.updateTask(task3, {
        description: "30 minute jog in the park",
        dueDate: "2025-04-27"
    });
    
    // Get all incomplete tasks
    const incompleteTasks = TaskManager.getTasks({ completed: false });
    console.log("Incomplete tasks:", incompleteTasks);
    
    // Get high priority tasks
    const highPriorityTasks = TaskManager.getTasks({ priority: "high" });
    console.log("High priority tasks:", highPriorityTasks);
    
    // Get statistics
    const stats = TaskManager.getStats();
    console.log("Task statistics:", stats);
    
    // Delete a task
    TaskManager.deleteTask(task1);
    
    // Final task list
    console.log("All tasks:", TaskManager.getTasks());
} catch (error) {
    console.error("Error:", error.message);
}</code></pre>
</div>
<div class="design-explanation">
<h3>Design Patterns Demonstrated</h3>
<ul>
<li><strong>Module Pattern (IIFE)</strong>: The entire TaskManager is wrapped in an IIFE, creating private scope</li>
<li><strong>Closures</strong>: Private variables and functions are accessed by public methods through closure</li>
<li><strong>Data Encapsulation</strong>: Tasks array is private and can only be accessed through controlled methods</li>
<li><strong>Immutability Principles</strong>: Returning copies of tasks to prevent external modification</li>
<li><strong>Parameter Destructuring</strong>: Using object destructuring for cleaner function parameters</li>
<li><strong>Object Spread</strong>: Using the spread operator for creating new objects without mutation</li>
<li><strong>Higher-Order Functions</strong>: Using filter and map for data operations</li>
<li><strong>Default Parameters</strong>: Providing default values for optional parameters</li>
</ul>
</div>
</section>
<section class="exercises">
<h2>Practice Exercises</h2>
<p>Reinforce your understanding of functions and scope with these exercises, ranging from basic to advanced.</p>
<div class="exercise-list">
<h3>Basic Exercises</h3>
<ol>
<li><strong>Function Calculator</strong>: Create a calculator function that takes two numbers and an operator (+, -, *, /) as arguments and returns the result</li>
<li><strong>Array Processor</strong>: Write a function that takes an array of numbers and returns the sum, average, minimum, and maximum values</li>
<li><strong>String Formatter</strong>: Create functions to format strings (capitalize, titleCase, camelCase, etc.)</li>
</ol>
<h3>Intermediate Exercises</h3>
<ol>
<li><strong>Password Validator</strong>: Create a function that validates passwords based on multiple criteria (length, case, special characters, etc.)</li>
<li><strong>Closure Counter</strong>: Create a counter function using closures that increments, decrements, and resets</li>
<li><strong>Function Composition</strong>: Implement a compose function that combines multiple functions into one</li>
</ol>
<h3>Advanced Exercises</h3>
<ol>
<li><strong>Memoization Function</strong>: Create a generic memoization function that can be used with any pure function</li>
<li><strong>Currying Implementation</strong>: Implement a curry function that transforms multi-argument functions into curried versions</li>
<li><strong>Event System</strong>: Create a pub/sub (publish/subscribe) event system using closures and function callbacks</li>
</ol>
</div>
<div class="solution-example">
<h3>Example Solution: Closure Counter</h3>
<pre><code>function createCounter(initialValue = 0) {
    let count = initialValue;
    
    return {
        increment: function(step = 1) {
            count += step;
            return count;
        },
        decrement: function(step = 1) {
            count -= step;
            return count;
        },
        reset: function(newValue = initialValue) {
            count = newValue;
            return count;
        },
        getValue: function() {
            return count;
        }
    };
}

// Testing the counter
const counter = createCounter(10);
console.log(counter.getValue());  // 10
console.log(counter.increment());  // 11
console.log(counter.increment(5));  // 16
console.log(counter.decrement(3));  // 13
console.log(counter.reset());  // 10
console.log(counter.reset(20));  // 20</code></pre>
</div>
</section>
<section class="resources">
<h2>Additional Resources</h2>
<p>Deepen your understanding of JavaScript functions and scope with these valuable resources:</p>
<div class="resource-list">
<h3>Documentation</h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions" target="_blank">MDN: JavaScript Functions Guide</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function" target="_blank">MDN: Function Expression</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arrow_functions" target="_blank">MDN: Arrow Functions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Scope" target="_blank">MDN: JavaScript Scope</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank">MDN: Closures</a></li>
</ul>
<h3>Books</h3>
<ul>
<li>"Eloquent JavaScript" by Marijn Haverbeke (Chapter 3: Functions)</li>
<li>"You Don't Know JS: Scope &amp; Closures" by Kyle Simpson</li>
<li>"JavaScript: The Good Parts" by Douglas Crockford</li>
<li>"Functional Programming in JavaScript" by Luis Atencio</li>
</ul>
<h3>Online Courses and Tutorials</h3>
<ul>
<li><a href="https://javascript.info/function-basics" target="_blank">JavaScript.info: Functions</a></li>
<li><a href="https://javascript.info/closure" target="_blank">JavaScript.info: Closures</a></li>
<li><a href="https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/" target="_blank">freeCodeCamp: JavaScript Curriculum</a></li>
</ul>
</div>
</section>
<section class="key_takeaways">
<h2>Key Takeaways</h2>
<div class="takeaways-list">
<ul>
<li><strong>Functions are core building blocks</strong> of JavaScript that promote code reuse and modularity</li>
<li>Functions can be defined using <strong>function declarations, expressions, or arrow syntax</strong></li>
<li><strong>Scope determines variable accessibility</strong>: global, function, and block scope</li>
<li><strong>Lexical scoping</strong> means functions can access variables from their containing scope</li>
<li><strong>Closures</strong> allow functions to maintain access to variables from their parent scope even after execution</li>
<li><strong>Hoisting</strong> affects how variable and function declarations are processed</li>
<li><strong>Recursion</strong> allows functions to call themselves to solve problems with repeated steps</li>
<li><strong>IIFEs</strong> create immediately executed functions with their own scope</li>
<li><strong>Higher-order functions</strong> take or return other functions, enabling functional programming patterns</li>
<li><strong>Best practices</strong> include keeping functions small, focused, and using descriptive names</li>
</ul>
</div>
</section>
</div>
<!-- Lesson Navigation -->
<div class="lesson-navigation">
<a class="lesson-nav-button prev" href="/module1.html">
<svg fill="currentColor" height="20" viewbox="0 0 20 20" width="20">
<path d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"></path>
</svg>
<span>
<small>Previous</small><br/>
                                    Back to Overview
                                </span>
</a>
<button class="complete-lesson-btn">
                                Mark as Complete
                            </button>
<a class="lesson-nav-button next" href="/module1.html">
<span>
<small>Next</small><br/>
                                    Continue Learning
                                </span>
<svg fill="currentColor" height="20" viewbox="0 0 20 20" width="20">
<path d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"></path>
</svg>
</a>
</div>
</article>
</div>
</div>
</main>
<!-- Footer -->
<footer class="site-footer" role="contentinfo">
<div class="footer-container">
<div class="footer-content">
<div class="footer-section footer-about">
<h3>PHP WordPress Development</h3>
<p>Complete Web Development Course</p>
</div>
<div class="footer-section">
<h4>Quick Links</h4>
<ul class="footer-links">
<li><a href="/">Home</a></li>
<li><a href="/module1.html">Module 1</a></li>
<li><a href="/resources.html">Resources</a></li>
</ul>
</div>
<div class="footer-section">
<h4>Support</h4>
<ul class="footer-links">
<li><a href="/help.html">Help Center</a></li>
<li><a href="/faq.html">FAQ</a></li>
<li><a href="/contact.html">Contact</a></li>
</ul>
</div>
</div>
<div class="footer-bottom">
<div class="footer-bottom-content">
<p class="copyright">© 2025 PHP WordPress Development Course</p>
<nav class="footer-bottom-links">
<a href="/privacy.html">Privacy</a>
<span class="separator">|</span>
<a href="/terms.html">Terms</a>
</nav>
</div>
</div>
</div>
</footer>
</div>
<!-- Back to Top -->
<button aria-label="Back to top" class="back-to-top" id="back-to-top">
<svg fill="none" height="24" stroke="currentColor" stroke-width="2" viewbox="0 0 24 24" width="24">
<path d="M12 19V5M12 5l-7 7M12 5l7 7"></path>
</svg>
</button>
<!-- JavaScript -->
<script src="/assets/js/navigation.js"></script>
<script src="/assets/js/site-config.js"></script>
<!-- Mermaid fallback -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10.0.2/dist/mermaid.min.js"></script>
<script>
        // Initialize mermaid if not already initialized
        if (typeof mermaid !== 'undefined') {
            mermaid.initialize({
                startOnLoad: true,
                theme: 'default',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                },
                securityLevel: 'loose'
            });
            // Manually render any mermaid diagrams
            mermaid.init();
        }
    </script>
</body>
</html>